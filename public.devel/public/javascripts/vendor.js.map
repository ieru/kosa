{"version":3,"file":"public/javascripts/vendor.js","sources":["vendor/scripts/console-helper.js","vendor/scripts/jquery-1.10.2.min.js","vendor/scripts/underscore-1.3.3.js","vendor/scripts/backbone-0.9.9.js","vendor/scripts/backbone-mediator.js","vendor/scripts/jit.js","vendor/scripts/select2.min.js","node_modules/auto-reload-brunch/vendor/auto-reload.js","node_modules/handlebars-brunch/vendor/handlebars.runtime-1.0.rc.1.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCXA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCniCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC7/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCpzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A","sourcesContent":["// Make it safe to do console.log() always.\n(function (con) {\n  var method;\n  var dummy = function() {};\n  var methods = ('assert,count,debug,dir,dirxml,error,exception,group,' +\n     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,' + \n     'time,timeEnd,trace,warn').split(',');\n  while (method = methods.pop()) {\n    con[method] = con[method] || dummy;\n  }\n})(window.console = window.console || {});\n","/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license\n//@ sourceMappingURL=jquery-1.10.2.min.map\n*/\n(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f=\"1.10.2\",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,T=/\\S+/g,C=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,N=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,k=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,E=/^[\\],:{}\\s]*$/,S=/(?:^|:|,)(?:\\s*\\[)+/g,A=/\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,j=/\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,D=/^-ms-/,L=/-([\\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||\"load\"===e.type||\"complete\"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener(\"DOMContentLoaded\",q,!1),e.removeEventListener(\"load\",q,!1)):(a.detachEvent(\"onreadystatechange\",q),e.detachEvent(\"onload\",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if(\"string\"==typeof e){if(i=\"<\"===e.charAt(0)&&\">\"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:\"\",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(\"boolean\"==typeof s&&(c=s,s=arguments[1]||{},l=2),\"object\"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger(\"ready\").off(\"ready\"))}},isFunction:function(e){return\"function\"===x.type(e)},isArray:Array.isArray||function(e){return\"array\"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?c[y.call(e)]||\"object\":typeof e},isPlainObject:function(e){var n;if(!e||\"object\"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,\"constructor\")&&!v.call(e.constructor.prototype,\"isPrototypeOf\"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||\"string\"!=typeof e)return null;\"boolean\"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:\"string\"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,\"@\").replace(j,\"]\").replace(S,\"\")))?Function(\"return \"+n)():(x.error(\"Invalid JSON: \"+n),t)},parseXML:function(n){var r,i;if(!n||\"string\"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,\"text/xml\")):(r=new ActiveXObject(\"Microsoft.XMLDOM\"),r.async=\"false\",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName(\"parsererror\").length||x.error(\"Invalid XML: \"+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,\"ms-\").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call(\"\\ufeff\\u00a0\")?function(e){return null==e?\"\":b.call(e)}:function(e){return null==e?\"\":(e+\"\").replace(C,\"\")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,\"string\"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if(\"number\"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return\"string\"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if(\"object\"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),\"complete\"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener(\"DOMContentLoaded\",q,!1),e.addEventListener(\"load\",q,!1);else{a.attachEvent(\"onreadystatechange\",q),e.attachEvent(\"onload\",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll(\"left\")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(e,t){c[\"[object \"+t+\"]\"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:\"array\"===n||\"function\"!==n&&(0===t||\"number\"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b=\"sizzle\"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",P=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",R=\"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",W=R.replace(\"w\",\"w#\"),$=\"\\\\[\"+P+\"*(\"+R+\")\"+P+\"*(?:([*^$|!~]?=)\"+P+\"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\"+W+\")|)|)\"+P+\"*\\\\]\",I=\":(\"+R+\")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+$.replace(3,8)+\")*)|.*)\\\\)|)\",z=RegExp(\"^\"+P+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+P+\"+$\",\"g\"),X=RegExp(\"^\"+P+\"*,\"+P+\"*\"),U=RegExp(\"^\"+P+\"*([>+~]|\"+P+\")\"+P+\"*\"),V=RegExp(P+\"*[+~]\"),Y=RegExp(\"=\"+P+\"*([^\\\\]'\\\"]*)\"+P+\"*\\\\]\",\"g\"),J=RegExp(I),G=RegExp(\"^\"+W+\"$\"),Q={ID:RegExp(\"^#(\"+R+\")\"),CLASS:RegExp(\"^\\\\.(\"+R+\")\"),TAG:RegExp(\"^(\"+R.replace(\"w\",\"w*\")+\")\"),ATTR:RegExp(\"^\"+$),PSEUDO:RegExp(\"^\"+I),CHILD:RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+P+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+P+\"*(?:([+-]|)\"+P+\"*(\\\\d+)|))\"+P+\"*\\\\)|)\",\"i\"),bool:RegExp(\"^(?:\"+B+\")$\",\"i\"),needsContext:RegExp(\"^\"+P+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+P+\"*((?:-\\\\d)?\\\\d*)\"+P+\"*\\\\)|)(?=[^-]|$)\",\"i\")},K=/^[^{]+\\{\\s*\\[native \\w/,Z=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\\d$/i,nt=/'|\\\\/g,rt=RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+P+\"?|(\"+P+\")|.)\",\"ig\"),it=function(e,t,n){var r=\"0x\"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||\"string\"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&\"object\"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute(\"id\"))?m=d.replace(nt,\"\\\\$&\"):t.setAttribute(\"id\",m),m=\"[id='\"+m+\"'] \",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(\",\")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute(\"id\")}}}return kt(e.replace(z,\"$1\"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=\" \")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement(\"div\");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split(\"|\"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return\"input\"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return(\"input\"===n||\"button\"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?\"HTML\"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent(\"onbeforeunload\",function(){p()}),r.attributes=ut(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML=\"<div class='a'></div><div class='a i'></div>\",e.firstChild.className=\"i\",2===e.getElementsByClassName(\"i\").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute(\"id\")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode(\"id\");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML=\"<select><option selected=''></option></select>\",e.querySelectorAll(\"[selected]\").length||g.push(\"\\\\[\"+P+\"*(?:value|\"+B+\")\"),e.querySelectorAll(\":checked\").length||g.push(\":checked\")}),ut(function(e){var t=n.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"t\",\"\"),e.querySelectorAll(\"[t^='']\").length&&g.push(\"[*^$]=\"+P+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":enabled\").length||g.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),g.push(\",.*:\")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,\"div\"),y.call(e,\"[s!='']:x\"),m.push(\"!=\",I)}),g=g.length&&RegExp(g.join(\"|\")),m=m.length&&RegExp(m.join(\"|\")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,\"='$1']\"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error(\"Syntax error, unrecognized expression: \"+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||\"\").replace(rt,it),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(\")\",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+\" \"];return t||(t=RegExp(\"(^|\"+P+\")\"+e+\"(\"+P+\"|$)\"))&&N(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute(\"class\")||\"\")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?\"!=\"===t:t?(i+=\"\",\"=\"===t?i===n:\"!=\"===t?i!==n:\"^=\"===t?n&&0===i.indexOf(n):\"*=\"===t?n&&i.indexOf(n)>-1:\"$=\"===t?n&&i.slice(-n.length)===n:\"~=\"===t?(\" \"+i+\" \").indexOf(n)>-1:\"|=\"===t?i===n||i.slice(0,n.length+1)===n+\"-\":!1):!0}},CHILD:function(e,t,n,r,i){var o=\"nth\"!==e.slice(0,3),a=\"last\"!==e.slice(-4),s=\"of-type\"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?\"nextSibling\":\"previousSibling\",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g=\"only\"===e&&!h&&\"nextSibling\"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error(\"unsupported pseudo: \"+e);return r[b]?r(t):r.length>1?(n=[e,e,\"\",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,\"$1\"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||\"\")||at.error(\"unsupported lang: \"+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute(\"xml:lang\")||t.getAttribute(\"lang\"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+\"-\");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>\"@\"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+\" \"];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z,\" \")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r=\"\";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&\"parentNode\"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+\" \"+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||\"*\",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[\" \"],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:\" \"===e[l-2].type?\"*\":\"\"})).replace(z,\"$1\"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b=\"0\",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG(\"*\",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+\" \"];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&\"ID\"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split(\"\").sort(A).join(\"\")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement(\"div\"))}),ut(function(e){return e.innerHTML=\"<a href='#'></a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||ct(\"type|href|height|width\",function(e,n,r){return r?t:e.getAttribute(n,\"type\"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML=\"<input/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||ct(\"value\",function(e,n,r){return r||\"input\"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute(\"disabled\")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[\":\"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e=\"string\"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);\"function\"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&\"string\"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[[\"resolve\",\"done\",x.Callbacks(\"once memory\"),\"resolved\"],[\"reject\",\"fail\",x.Callbacks(\"once memory\"),\"rejected\"],[\"notify\",\"progress\",x.Callbacks(\"memory\")]],n=\"pending\",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+\"With\"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+\"With\"](this===i?r:this,arguments),this},i[o[0]+\"With\"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement(\"div\");if(d.setAttribute(\"className\",\"t\"),d.innerHTML=\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\",n=d.getElementsByTagName(\"*\")||[],r=d.getElementsByTagName(\"a\")[0],!r||!r.style||!n.length)return t;s=a.createElement(\"select\"),u=s.appendChild(a.createElement(\"option\")),o=d.getElementsByTagName(\"input\")[0],r.style.cssText=\"top:1px;float:left;opacity:.5\",t.getSetAttribute=\"t\"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName(\"tbody\").length,t.htmlSerialize=!!d.getElementsByTagName(\"link\").length,t.style=/top/.test(r.getAttribute(\"style\")),t.hrefNormalized=\"/a\"===r.getAttribute(\"href\"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement(\"form\").enctype,t.html5Clone=\"<:nav></:nav>\"!==a.createElement(\"nav\").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement(\"input\"),o.setAttribute(\"value\",\"\"),t.input=\"\"===o.getAttribute(\"value\"),o.value=\"t\",o.setAttribute(\"type\",\"radio\"),t.radioValue=\"t\"===o.value,o.setAttribute(\"checked\",\"t\"),o.setAttribute(\"name\",\"t\"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent(\"onclick\",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c=\"on\"+f,\"t\"),t[f+\"Bubbles\"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip=\"content-box\",d.cloneNode(!0).style.backgroundClip=\"\",t.clearCloneStyle=\"content-box\"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast=\"0\"!==f,x(function(){var n,r,o,s=\"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",l=a.getElementsByTagName(\"body\")[0];l&&(n=a.createElement(\"div\"),n.style.cssText=\"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\",l.appendChild(n).appendChild(d),d.innerHTML=\"<table><tr><td></td><td>t</td></tr></table>\",o=d.getElementsByTagName(\"td\"),o[0].style.cssText=\"padding:0;margin:0;border:0;display:none\",p=0===o[0].offsetHeight,o[0].style.display=\"\",o[1].style.display=\"none\",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML=\"\",d.style.cssText=\"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition=\"1%\"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable=\"4px\"===(e.getComputedStyle(d,null)||{width:\"4px\"}).width,r=d.appendChild(a.createElement(\"div\")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width=\"0\",d.style.width=\"1px\",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML=\"\",d.style.cssText=s+\"width:1px;padding:1px;display:inline;zoom:1\",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display=\"block\",d.innerHTML=\"<div></div>\",d.firstChild.style.width=\"5px\",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t\n}({});var B=/(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||\"string\"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),(\"object\"==typeof n||\"function\"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),\"string\"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(\" \")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute(\"classid\")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,\"parsedAttrs\"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf(\"data-\")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,\"parsedAttrs\",!0)}return o}return\"object\"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i=\"data-\"+n.replace(P,\"-$1\").toLowerCase();if(r=e.getAttribute(i),\"string\"==typeof r){try{r=\"true\"===r?!0:\"false\"===r?!1:\"null\"===r?null:+r+\"\"===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if((\"data\"!==t||!x.isEmptyObject(e[t]))&&\"toJSON\"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||\"fx\")+\"queue\",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||\"fx\";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks(\"once memory\").add(function(){x._removeData(e,t+\"queue\"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return\"string\"!=typeof e&&(n=e,e=\"fx\",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),\"fx\"===e&&\"inprogress\"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||\"fx\",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};\"string\"!=typeof e&&(n=e,e=t),e=e||\"fx\";while(s--)r=x._data(a[s],e+\"queueHooks\"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\\t\\r\\n\\f]/g,V=/\\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=\"string\"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||\"\").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(\" \"+n.className+\" \").replace(U,\" \"):\" \")){o=0;while(i=t[o++])0>r.indexOf(\" \"+i+\" \")&&(r+=i+\" \");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||\"string\"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||\"\").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(\" \"+n.className+\" \").replace(U,\" \"):\"\")){o=0;while(i=t[o++])while(r.indexOf(\" \"+i+\" \")>=0)r=r.replace(\" \"+i+\" \",\" \");n.className=e?x.trim(r):\"\"}return this},toggleClass:function(e,t){var n=typeof e;return\"boolean\"==typeof t&&\"string\"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(\"string\"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||\"boolean\"===n)&&(this.className&&x._data(this,\"__className__\",this.className),this.className=this.className||e===!1?\"\":x._data(this,\"__className__\")||\"\")})},hasClass:function(e){var t=\" \"+e+\" \",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(\" \"+this[n].className+\" \").replace(U,\" \").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o=\"\":\"number\"==typeof o?o+=\"\":x.isArray(o)&&(o=x.map(o,function(e){return null==e?\"\":e+\"\"})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&\"set\"in r&&r.set(this,o,\"value\")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&\"get\"in r&&(n=r.get(o,\"value\"))!==t?n:(n=o.value,\"string\"==typeof n?n.replace(V,\"\"):null==n?\"\":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,\"value\");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o=\"select-one\"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute(\"disabled\"))||n.parentNode.disabled&&x.nodeName(n.parentNode,\"optgroup\"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&\"get\"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&\"set\"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+\"\"),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase(\"default-\"+n)]=e[r]=!1:x.attr(e,n,\"\"),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&\"radio\"===t&&x.nodeName(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&\"set\"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&\"get\"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,\"tabindex\");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase(\"default-\"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase(\"default-\"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,\"input\")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+=\"\",\"value\"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&\"\"!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,\"\"===t?!1:t,n)}},x.each([\"width\",\"height\"],function(e,n){x.attrHooks[n]={set:function(e,r){return\"\"===r?(e.setAttribute(n,\"auto\"),r):t}}})),x.support.hrefNormalized||x.each([\"href\",\"src\"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+\"\"}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype=\"encoding\"),x.each([\"radio\",\"checkbox\"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||\"\").match(T)||[\"\"],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||\"\").split(\".\").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(\".\")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent(\"on\"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||\"\").match(T)||[\"\"],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||\"\").split(\".\").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&(\"**\"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,\"events\"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,\"type\")?n.type:n,m=v.call(n,\"namespace\")?n.namespace.split(\".\"):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(\".\")>=0&&(m=g.split(\".\"),g=m.shift(),m.sort()),l=0>g.indexOf(\":\")&&\"on\"+g,n=n[x.expando]?n:new x.Event(g,\"object\"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join(\".\"),n.namespace_re=n.namespace?RegExp(\"(^|\\\\.)\"+m.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,\"events\")||{})[n.type]&&x._data(u,\"handle\"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,\"events\")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||\"click\"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||\"click\"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+\" \",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:\"focusin\"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:\"focusout\"},click:{trigger:function(){return x.nodeName(this,\"input\")&&\"checkbox\"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,\"a\")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r=\"on\"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,\"form\")?!1:(x.event.add(this,\"click._submit keypress._submit\",function(e){var n=e.target,r=x.nodeName(n,\"input\")||x.nodeName(n,\"button\")?n.form:t;r&&!x._data(r,\"submitBubbles\")&&(x.event.add(r,\"submit._submit\",function(e){e._submit_bubble=!0}),x._data(r,\"submitBubbles\",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate(\"submit\",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,\"form\")?!1:(x.event.remove(this,\"._submit\"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?((\"checkbox\"===this.type||\"radio\"===this.type)&&(x.event.add(this,\"propertychange._change\",function(e){\"checked\"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,\"click._change\",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate(\"change\",this,e,!0)})),!1):(x.event.add(this,\"beforeactivate._change\",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,\"changeBubbles\")&&(x.event.add(t,\"change._change\",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate(\"change\",this.parentNode,e,!0)}),x._data(t,\"changeBubbles\",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||\"radio\"!==n.type&&\"checkbox\"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,\"._change\"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if(\"object\"==typeof e){\"string\"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&(\"string\"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+\".\"+i.namespace:i.origType,i.selector,i.handler),this;if(\"object\"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||\"function\"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\\[\\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if(\"string\"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+\" \"+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,\"string\"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||\"string\"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?\"string\"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n=\"string\"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,\"parentNode\")},parentsUntil:function(e,t,n){return x.dir(e,\"parentNode\",n)},next:function(e){return pt(e,\"nextSibling\")},prev:function(e){return pt(e,\"previousSibling\")},nextAll:function(e){return x.dir(e,\"nextSibling\")},prevAll:function(e){return x.dir(e,\"previousSibling\")},nextUntil:function(e,t,n){return x.dir(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return x.dir(e,\"previousSibling\",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,\"iframe\")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return\"Until\"!==e.slice(-5)&&(r=n),r&&\"string\"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if(\"string\"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split(\"|\"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht=\"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",gt=/ jQuery\\d+=\"(?:null|\\d+)\"/g,mt=RegExp(\"<(?:\"+ht+\")[\\\\s/>]\",\"i\"),yt=/^\\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,bt=/<([\\w:]+)/,xt=/<tbody/i,wt=/<|&#?\\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\\s*(?:[^=]|=\\s*.checked.)/i,kt=/^$|\\/(?:java|ecma)script/i,Et=/^true\\/(.*)/,St=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,At={option:[1,\"<select multiple='multiple'>\",\"</select>\"],legend:[1,\"<fieldset>\",\"</fieldset>\"],area:[1,\"<map>\",\"</map>\"],param:[1,\"<object>\",\"</object>\"],thead:[1,\"<table>\",\"</table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],col:[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:x.support.htmlSerialize?[0,\"\",\"\"]:[1,\"X<div>\",\"</div>\"]},jt=dt(a),Dt=jt.appendChild(a.createElement(\"div\"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,\"script\")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,\"select\")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,\"\"):t;if(!(\"string\"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||[\"\",\"\"])[1].toLowerCase()])){e=e.replace(vt,\"<$1></$2>\");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||\"string\"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,\"script\"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,\"script\"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||\"\")&&!x._data(i,\"globalEval\")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||\"\").replace(St,\"\")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,\"table\")&&x.nodeName(1===t.nodeType?t:t.firstChild,\"tr\")?e.getElementsByTagName(\"tbody\")[0]||e.appendChild(e.ownerDocument.createElement(\"tbody\")):e}function Ht(e){return e.type=(null!==x.find.attr(e,\"type\"))+\"/\"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute(\"type\"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,\"globalEval\",!t||x._data(t[r],\"globalEval\"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}\"script\"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):\"object\"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):\"input\"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):\"option\"===n?t.defaultSelected=t.selected=e.defaultSelected:(\"input\"===n||\"textarea\"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||\"*\"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||\"*\"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test(\"<\"+e.nodeName+\">\")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,\"script\"),r.length>0&&_t(r,!l&&Ft(e,\"script\")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if(\"object\"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement(\"div\")),l=(bt.exec(o)||[\"\",\"\"])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,\"<$1></$2>\")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o=\"table\"!==l||xt.test(o)?\"<table>\"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],\"tbody\")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent=\"\";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,\"input\"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),\"script\"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||\"\")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);\nu[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:\"GET\",dataType:\"script\",async:!1,global:!1,\"throws\":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,\"body\")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\\([^)]*\\)/i,It=/opacity\\s*=\\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp(\"^(\"+w+\")(.*)$\",\"i\"),Yt=RegExp(\"^(\"+w+\")(?!px)[a-z%]+$\",\"i\"),Jt=RegExp(\"^([+-])=(\"+w+\")\",\"i\"),Gt={BODY:\"block\"},Qt={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Kt={letterSpacing:0,fontWeight:400},Zt=[\"Top\",\"Right\",\"Bottom\",\"Left\"],en=[\"Webkit\",\"O\",\"Moz\",\"ms\"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,\"none\"===x.css(e,\"display\")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,\"olddisplay\"),n=r.style.display,t?(o[a]||\"none\"!==n||(r.style.display=\"\"),\"\"===r.style.display&&nn(r)&&(o[a]=x._data(r,\"olddisplay\",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&\"none\"!==n||!i)&&x._data(r,\"olddisplay\",i?n:x.css(r,\"display\"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&\"none\"!==r.style.display&&\"\"!==r.style.display||(r.style.display=t?o[a]||\"\":\"none\"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":x.support.cssFloat?\"cssFloat\":\"styleFloat\"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&\"get\"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,\"string\"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a=\"number\"),!(null==r||\"number\"===a&&isNaN(r)||(\"number\"!==a||x.cssNumber[l]||(r+=\"px\"),x.support.clearCloneStyle||\"\"!==r||0!==n.indexOf(\"background\")||(u[n]=\"inherit\"),s&&\"set\"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&\"get\"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),\"normal\"===a&&n in Kt&&(a=Kt[n]),\"\"===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(\"\"!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left=\"fontSize\"===n?\"1em\":l,l=u.pixelLeft+\"px\",u.left=i,a&&(o.left=a)),\"\"===l?\"auto\":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||\"px\"):t}function an(e,t,n,r,i){var o=n===(r?\"border\":\"content\")?4:\"width\"===t?1:0,a=0;for(;4>o;o+=2)\"margin\"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?(\"content\"===n&&(a-=x.css(e,\"padding\"+Zt[o],!0,i)),\"margin\"!==n&&(a-=x.css(e,\"border\"+Zt[o]+\"Width\",!0,i))):(a+=x.css(e,\"padding\"+Zt[o],!0,i),\"padding\"!==n&&(a+=x.css(e,\"border\"+Zt[o]+\"Width\",!0,i)));return a}function sn(e,t,n){var r=!0,i=\"width\"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&\"border-box\"===x.css(e,\"boxSizing\",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?\"border\":\"content\"),r,o)+\"px\"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),\"none\"!==n&&n||(Pt=(Pt||x(\"<iframe frameborder='0' width='0' height='0'/>\").css(\"cssText\",\"display:block !important\")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write(\"<!doctype html><html><body>\"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],\"display\");return n.remove(),r}x.each([\"height\",\"width\"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,\"display\"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&\"border-box\"===x.css(e,\"boxSizing\",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||\"\")?.01*parseFloat(RegExp.$1)+\"\":t?\"1\":\"\"},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?\"alpha(opacity=\"+100*t+\")\":\"\",o=r&&r.filter||n.filter||\"\";n.zoom=1,(t>=1||\"\"===t)&&\"\"===x.trim(o.replace($t,\"\"))&&n.removeAttribute&&(n.removeAttribute(\"filter\"),\"\"===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+\" \"+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:\"inline-block\"},Wt,[e,\"marginRight\"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each([\"top\",\"left\"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+\"px\":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&\"none\"===(e.style&&e.style.display||x.css(e,\"display\"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:\"\",padding:\"\",border:\"Width\"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o=\"string\"==typeof n?n.split(\" \"):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\\[\\]$/,fn=/\\r?\\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,\"elements\");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(\":disabled\")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,\"\\r\\n\")}}):{name:t.name,value:n.replace(fn,\"\\r\\n\")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?\"\":t,i[i.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join(\"&\").replace(cn,\"+\")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+\"[\"+(\"object\"==typeof i?t:\"\")+\"]\",i,n,r)});else if(n||\"object\"!==x.type(t))r(e,t);else for(i in t)gn(e+\"[\"+i+\"]\",t[i],n,r)}x.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)}});var mn,yn,vn=x.now(),bn=/\\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\\/\\//,En=/^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn=\"*/\".concat(\"*\");try{yn=o.href}catch(Ln){yn=a.createElement(\"a\"),yn.href=\"\",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){\"string\"!=typeof t&&(n=t,t=\"*\");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])\"+\"===r[0]?(r=r.slice(1)||\"*\",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return\"string\"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o[\"*\"]&&s(\"*\")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if(\"string\"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(\" \");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&\"object\"==typeof n&&(a=\"POST\"),s.length>0&&x.ajax({url:e,type:a,dataType:\"html\",data:n}).done(function(e){o=arguments,s.html(i?x(\"<div>\").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:\"GET\",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Dn,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":x.parseJSON,\"text xml\":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){\"object\"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks(\"once memory\"),m=p.statusCode||{},y={},v={},b=0,w=\"canceled\",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+\"\").replace(xn,\"\").replace(kn,mn[1]+\"//\"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||\"*\").toLowerCase().match(T)||[\"\"],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||(\"http:\"===r[1]?\"80\":\"443\"))===(mn[3]||(\"http:\"===mn[1]?\"80\":\"443\")))),p.data&&p.processData&&\"string\"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger(\"ajaxStart\"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?\"&\":\"?\")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,\"$1_=\"+vn++):o+(bn.test(o)?\"&\":\"?\")+\"_=\"+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader(\"If-Modified-Since\",x.lastModified[o]),x.etag[o]&&C.setRequestHeader(\"If-None-Match\",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader(\"Content-Type\",p.contentType),C.setRequestHeader(\"Accept\",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+(\"*\"!==p.dataTypes[0]?\", \"+Dn+\"; q=0.01\":\"\"):p.accepts[\"*\"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w=\"abort\";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger(\"ajaxSend\",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort(\"timeout\")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,\"No Transport\");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||\"\",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader(\"Last-Modified\"),T&&(x.lastModified[o]=T),T=C.getResponseHeader(\"etag\"),T&&(x.etag[o]=T)),204===e||\"HEAD\"===p.type?N=\"nocontent\":304===e?N=\"notmodified\":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N=\"error\",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+\"\",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?\"ajaxSuccess\":\"ajaxError\",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger(\"ajaxComplete\",[C,p]),--x.active||x.event.trigger(\"ajaxStop\")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,\"json\")},getScript:function(e,n){return x.get(e,t,n,\"script\")}}),x.each([\"get\",\"post\"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader(\"Content-Type\"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+\" \"+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if(\"*\"===o)o=l;else if(\"*\"!==l&&l!==o){if(a=u[l+\" \"+o]||u[\"* \"+o],!a)for(i in u)if(s=i.split(\" \"),s[1]===o&&(a=u[l+\" \"+s[0]]||u[\"* \"+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(p){return{state:\"parsererror\",error:a?p:\"No conversion from \"+l+\" to \"+o}}}return{state:\"success\",data:t}}x.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/(?:java|ecma)script/},converters:{\"text script\":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter(\"script\",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\",e.global=!1)}),x.ajaxTransport(\"script\",function(e){if(e.crossDomain){var n,r=a.head||x(\"head\")[0]||a.documentElement;return{send:function(t,i){n=a.createElement(\"script\"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,\"success\"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\\?(?=&|$)|\\?\\?/;x.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Fn.pop()||x.expando+\"_\"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter(\"json jsonp\",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?\"url\":\"string\"==typeof n.data&&!(n.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Bn.test(n.data)&&\"data\");return l||\"jsonp\"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,\"$1\"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?\"&\":\"?\")+n.jsonp+\"=\"+o),n.converters[\"script json\"]=function(){return s||x.error(o+\" was not called\"),s[0]},n.dataTypes[0]=\"json\",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),\"script\"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&\"withCredentials\"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i[\"X-Requested-With\"]||(i[\"X-Requested-With\"]=\"XMLHttpRequest\");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),\"string\"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=\"\"}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp(\"^(?:([+-])=|)(\"+w+\")([a-z%]*)$\",\"i\"),Jn=/queueHooks$/,Gn=[nr],Qn={\"*\":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?\"\":\"px\"),a=(x.cssNumber[e]||\"px\"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||\".5\",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn[\"*\"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&\"expand\"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=[\"*\"]):e=e.split(\" \");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,\"fxshow\");n.queue||(s=x._queueHooks(e,\"fx\"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,\"fx\").length||s.empty.fire()})})),1===e.nodeType&&(\"height\"in t||\"width\"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],\"inline\"===x.css(e,\"display\")&&\"none\"===x.css(e,\"float\")&&(x.support.inlineBlockNeedsLayout&&\"inline\"!==ln(e.nodeName)?p.zoom=1:p.display=\"inline-block\")),n.overflow&&(p.overflow=\"hidden\",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||\"toggle\"===i,i===(f?\"hide\":\"show\"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?\"hidden\"in d&&(f=d.hidden):d=x._data(e,\"fxshow\",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,\"fxshow\");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start=\"width\"===r||\"height\"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||\"swing\",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?\"\":\"px\")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,\"\"),t&&\"auto\"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each([\"toggle\",\"show\",\"hide\"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||\"boolean\"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,\"finish\"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return\"string\"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||\"fx\",[]),this.each(function(){var t=!0,n=null!=e&&e+\"queueHooks\",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||\"fx\"),this.each(function(){var t,n=x._data(this),r=n[e+\"queue\"],i=n[e+\"queueHooks\"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r[\"margin\"+n]=r[\"padding\"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir(\"show\"),slideUp:ir(\"hide\"),slideToggle:ir(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&\"object\"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:\"number\"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,\"position\");\"static\"===r&&(e.style.position=\"relative\");var i=x(e),o=i.offset(),a=x.css(e,\"top\"),s=x.css(e,\"left\"),l=(\"absolute\"===r||\"fixed\"===r)&&x.inArray(\"auto\",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),\"using\"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return\"fixed\"===x.css(r,\"position\")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],\"html\")||(n=e.offset()),n.top+=x.css(e[0],\"borderTopWidth\",!0),n.left+=x.css(e[0],\"borderLeftWidth\",!0)),{top:t.top-n.top-x.css(r,\"marginTop\",!0),left:t.left-n.left-x.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,\"html\")&&\"static\"===x.css(e,\"position\"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:\"height\",Width:\"width\"},function(e,n){x.each({padding:\"inner\"+e,content:n,\"\":\"outer\"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||\"boolean\"!=typeof i),s=r||(i===!0||o===!0?\"margin\":\"border\");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement[\"client\"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body[\"scroll\"+e],o[\"scroll\"+e],n.body[\"offset\"+e],o[\"offset\"+e],o[\"client\"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,\"object\"==typeof module&&module&&\"object\"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return x}))})(window);\n","//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);\n","//     Backbone.js 0.9.9\n\n//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(){\n\n  // Initial Setup\n  // -------------\n\n  // Save a reference to the global object (`window` in the browser, `exports`\n  // on the server).\n  var root = this;\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create a local reference to array methods.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var splice = array.splice;\n\n  // The top-level namespace. All public Backbone classes and modules will\n  // be attached to this. Exported for both CommonJS and the browser.\n  var Backbone;\n  if (typeof exports !== 'undefined') {\n    Backbone = exports;\n  } else {\n    Backbone = root.Backbone = {};\n  }\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '0.9.9';\n\n  // Require Underscore, if we're on the server, and it's not already present.\n  var _ = root._;\n  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');\n\n  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.\n  Backbone.$ = root.jQuery || root.Zepto || root.ender;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n    } else if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n    } else {\n      return true;\n    }\n  };\n\n  // Optimized internal dispatch function for triggering events. Tries to\n  // keep the usual cases speedy (most Backbone events have 3 arguments).\n  var triggerEvents = function(obj, events, args) {\n    var ev, i = -1, l = events.length;\n    switch (args.length) {\n    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx);\n    return;\n    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0]);\n    return;\n    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1]);\n    return;\n    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1], args[2]);\n    return;\n    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n    }\n  };\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind one or more space separated events, or an events map,\n    // to a `callback` function. Passing `\"all\"` will bind the callback to\n    // all events fired.\n    on: function(name, callback, context) {\n      if (!(eventsApi(this, 'on', name, [callback, context]) && callback)) return this;\n      this._events || (this._events = {});\n      var list = this._events[name] || (this._events[name] = []);\n      list.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind events to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!(eventsApi(this, 'once', name, [callback, context]) && callback)) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      this.on(name, once, context);\n      return this;\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `events` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var list, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = {};\n        return this;\n      }\n\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (list = this._events[name]) {\n          events = [];\n          if (callback || context) {\n            for (j = 0, k = list.length; j < k; j++) {\n              ev = list[j];\n              if ((callback && callback !== (ev.callback._callback || ev.callback)) ||\n                  (context && context !== ev.context)) {\n                events.push(ev);\n              }\n            }\n          }\n          this._events[name] = events;\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(this, events, args);\n      if (allEvents) triggerEvents(this, allEvents, arguments);\n      return this;\n    },\n\n    // An inversion-of-control version of `on`. Tell *this* object to listen to\n    // an event in another object ... keeping track of what it's listening to.\n    listenTo: function(object, events, callback) {\n      var listeners = this._listeners || (this._listeners = {});\n      var id = object._listenerId || (object._listenerId = _.uniqueId('l'));\n      listeners[id] = object;\n      object.on(events, callback || this, this);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(object, events, callback) {\n      var listeners = this._listeners;\n      if (!listeners) return;\n      if (object) {\n        object.off(events, callback, this);\n        if (!events && !callback) delete listeners[object._listenerId];\n      } else {\n        for (var id in listeners) {\n          listeners[id].off(null, null, this);\n        }\n        this._listeners = {};\n      }\n      return this;\n    }\n  };\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Create a new model, with defined attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var defaults;\n    var attrs = attributes || {};\n    this.cid = _.uniqueId('c');\n    this.changed = {};\n    this.attributes = {};\n    this._changes = [];\n    if (options && options.collection) this.collection = options.collection;\n    if (options && options.parse) attrs = this.parse(attrs);\n    if (defaults = _.result(this, 'defaults')) _.defaults(attrs, defaults);\n    this.set(attrs, {silent: true});\n    this._currentAttributes = _.clone(this.attributes);\n    this._previousAttributes = _.clone(this.attributes);\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"` unless\n    // you choose to silence it.\n    set: function(key, val, options) {\n      var attr, attrs;\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (_.isObject(key)) {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      // Extract attributes and options.\n      var silent = options && options.silent;\n      var unset = options && options.unset;\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      var now = this.attributes;\n\n      // For each `set` attribute...\n      for (attr in attrs) {\n        val = attrs[attr];\n\n        // Update or delete the current value, and track the change.\n        unset ? delete now[attr] : now[attr] = val;\n        this._changes.push(attr, val);\n      }\n\n      // Signal that the model's state has potentially changed, and we need\n      // to recompute the actual changes.\n      this._hasComputed = false;\n\n      // Fire the `\"change\"` events.\n      if (!silent) this.change(options);\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"` unless you choose\n    // to silence it. `unset` is a noop if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"` unless you choose\n    // to silence it.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overriden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp, status, xhr) {\n        if (!model.set(model.parse(resp), options)) return false;\n        if (success) success(model, resp, options);\n      };\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      var attrs, current, done;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (key == null || _.isObject(key)) {\n        attrs = key;\n        options = val;\n      } else if (key != null) {\n        (attrs = {})[key] = val;\n      }\n      options = options ? _.clone(options) : {};\n\n      // If we're \"wait\"-ing to set changed attributes, validate early.\n      if (options.wait) {\n        if (attrs && !this._validate(attrs, options)) return false;\n        current = _.clone(this.attributes);\n      }\n\n      // Regular saves `set` attributes before persisting to the server.\n      var silentOptions = _.extend({}, options, {silent: true});\n      if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {\n        return false;\n      }\n\n      // Do not persist invalid models.\n      if (!attrs && !this._validate(null, options)) return false;\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      var model = this;\n      var success = options.success;\n      options.success = function(resp, status, xhr) {\n        done = true;\n        var serverAttrs = model.parse(resp);\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n        if (!model.set(serverAttrs, options)) return false;\n        if (success) success(model, resp, options);\n      };\n\n      // Finish configuring and sending the Ajax request.\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method == 'patch') options.attrs = attrs;\n      var xhr = this.sync(method, this, options);\n\n      // When using `wait`, reset attributes to original values unless\n      // `success` has been called already.\n      if (!done && options.wait) {\n        this.clear(silentOptions);\n        this.set(current, silentOptions);\n      }\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var destroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (options.wait || model.isNew()) destroy();\n        if (success) success(model, resp, options);\n      };\n\n      if (this.isNew()) {\n        options.success();\n        return false;\n      }\n\n      var xhr = this.sync('delete', this, options);\n      if (!options.wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();\n      if (this.isNew()) return base;\n      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return this.id == null;\n    },\n\n    // Call this method to manually fire a `\"change\"` event for this model and\n    // a `\"change:attribute\"` event for each changed attribute.\n    // Calling this will cause all objects observing the model to update.\n    change: function(options) {\n      var changing = this._changing;\n      this._changing = true;\n\n      // Generate the changes to be triggered on the model.\n      var triggers = this._computeChanges(true);\n\n      this._pending = !!triggers.length;\n\n      for (var i = triggers.length - 2; i >= 0; i -= 2) {\n        this.trigger('change:' + triggers[i], this, triggers[i + 1], options);\n      }\n\n      if (changing) return this;\n\n      // Trigger a `change` while there have been changes.\n      while (this._pending) {\n        this._pending = false;\n        this.trigger('change', this, options);\n        this._previousAttributes = _.clone(this.attributes);\n      }\n\n      this._changing = false;\n      return this;\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (!this._hasComputed) this._computeChanges();\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false, old = this._previousAttributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Looking at the built up list of `set` attribute changes, compute how\n    // many of the attributes have actually changed. If `loud`, return a\n    // boiled-down list of only the real changes.\n    _computeChanges: function(loud) {\n      this.changed = {};\n      var already = {};\n      var triggers = [];\n      var current = this._currentAttributes;\n      var changes = this._changes;\n\n      // Loop through the current queue of potential model changes.\n      for (var i = changes.length - 2; i >= 0; i -= 2) {\n        var key = changes[i], val = changes[i + 1];\n        if (already[key]) continue;\n        already[key] = true;\n\n        // Check if the attribute has been modified since the last change,\n        // and update `this.changed` accordingly. If we're inside of a `change`\n        // call, also add a trigger to the list.\n        if (current[key] !== val) {\n          this.changed[key] = val;\n          if (!loud) continue;\n          triggers.push(key, val);\n          current[key] = val;\n        }\n      }\n      if (loud) this._changes = [];\n\n      // Signals `this.changed` is current to prevent duplicate calls from `this.hasChanged`.\n      this._hasComputed = true;\n      return triggers;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. If a specific `error` callback has\n    // been passed, call that instead of firing the general `\"error\"` event.\n    _validate: function(attrs, options) {\n      if (!this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validate(attrs, options);\n      if (!error) return true;\n      if (options && options.error) options.error(this, error, options);\n      this.trigger('error', this, error, options);\n      return false;\n    }\n\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // Provides a standard collection class for our sets of models, ordered\n  // or unordered. If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set. Pass **silent** to avoid\n    // firing the `add` event for every new model.\n    add: function(models, options) {\n      var i, args, length, model, existing, needsSort;\n      var at = options && options.at;\n      var sort = ((options && options.sort) == null ? true : options.sort);\n      models = _.isArray(models) ? models.slice() : [models];\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      for (i = models.length - 1; i >= 0; i--) {\n        if(!(model = this._prepareModel(models[i], options))) {\n          this.trigger(\"error\", this, models[i], options);\n          models.splice(i, 1);\n          continue;\n        }\n        models[i] = model;\n\n        existing = model.id != null && this._byId[model.id];\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        if (existing || this._byCid[model.cid]) {\n          if (options && options.merge && existing) {\n            existing.set(model.attributes, options);\n            needsSort = sort;\n          }\n          models.splice(i, 1);\n          continue;\n        }\n\n        // Listen to added models' events, and index models for lookup by\n        // `id` and by `cid`.\n        model.on('all', this._onModelEvent, this);\n        this._byCid[model.cid] = model;\n        if (model.id != null) this._byId[model.id] = model;\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      if (models.length) needsSort = sort;\n      this.length += models.length;\n      args = [at != null ? at : this.models.length, 0];\n      push.apply(args, models);\n      splice.apply(this.models, args);\n\n      // Sort the collection if appropriate.\n      if (needsSort && this.comparator && at == null) this.sort({silent: true});\n\n      if (options && options.silent) return this;\n\n      // Trigger `add` events.\n      while (model = models.shift()) {\n        model.trigger('add', model, this, options);\n      }\n\n      return this;\n    },\n\n    // Remove a model, or a list of models from the set. Pass silent to avoid\n    // firing the `remove` event for every model removed.\n    remove: function(models, options) {\n      var i, l, index, model;\n      options || (options = {});\n      models = _.isArray(models) ? models.slice() : [models];\n      for (i = 0, l = models.length; i < l; i++) {\n        model = this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byCid[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model);\n      }\n      return this;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      model = this._prepareModel(model, options);\n      this.add(model, _.extend({at: this.length}, options));\n      return model;\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      model = this._prepareModel(model, options);\n      this.add(model, _.extend({at: 0}, options));\n      return model;\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function(begin, end) {\n      return this.models.slice(begin, end);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj.id != null ? obj.id : obj] || this._byCid[obj.cid || obj];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of `filter`.\n    where: function(attrs) {\n      if (_.isEmpty(attrs)) return [];\n      return this.filter(function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      if (!this.comparator) {\n        throw new Error('Cannot sort a set without a comparator');\n      }\n\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\n        this.models = this.sortBy(this.comparator, this);\n      } else {\n        this.models.sort(_.bind(this.comparator, this));\n      }\n\n      if (!options || !options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Smartly update a collection with a change set of models, adding,\n    // removing, and merging as necessary.\n    update: function(models, options) {\n      var model, i, l, existing;\n      var add = [], remove = [], modelMap = {};\n      var idAttr = this.model.prototype.idAttribute;\n      options = _.extend({add: true, merge: true, remove: true}, options);\n      if (options.parse) models = this.parse(models);\n\n      // Allow a single model (or no argument) to be passed.\n      if (!_.isArray(models)) models = models ? [models] : [];\n\n      // Proxy to `add` for this case, no need to iterate...\n      if (options.add && !options.remove) return this.add(models, options);\n\n      // Determine which models to add and merge, and which to remove.\n      for (i = 0, l = models.length; i < l; i++) {\n        model = models[i];\n        existing = this.get(model.id || model.cid || model[idAttr]);\n        if (options.remove && existing) modelMap[existing.cid] = true;\n        if ((options.add && !existing) || (options.merge && existing)) {\n          add.push(model);\n        }\n      }\n      if (options.remove) {\n        for (i = 0, l = this.models.length; i < l; i++) {\n          model = this.models[i];\n          if (!modelMap[model.cid]) remove.push(model);\n        }\n      }\n\n      // Remove models (if applicable) before we add and merge the rest.\n      if (remove.length) this.remove(remove, options);\n      if (add.length) this.add(add, options);\n      return this;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any `add` or `remove` events. Fires `reset` when finished.\n    reset: function(models, options) {\n      options || (options = {});\n      if (options.parse) models = this.parse(models);\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i]);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      if (models) this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return this;\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `add: true` is passed, appends the\n    // models to the collection instead of resetting.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var collection = this;\n      var success = options.success;\n      options.success = function(resp, status, xhr) {\n        var method = options.update ? 'update' : 'reset';\n        collection[method](resp, options);\n        if (success) success(collection, resp, options);\n      };\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      var collection = this;\n      options = options ? _.clone(options) : {};\n      model = this._prepareModel(model, options);\n      if (!model) return false;\n      if (!options.wait) collection.add(model, options);\n      var success = options.success;\n      options.success = function(model, resp, options) {\n        if (options.wait) collection.add(model, options);\n        if (success) success(model, resp, options);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models);\n    },\n\n    // Proxy to _'s chain. Can't be proxied the same way the rest of the\n    // underscore methods are proxied because it relies on the underscore\n    // constructor.\n    chain: function() {\n      return _(this.models).chain();\n    },\n\n    // Reset all internal state. Called when the collection is reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n      this._byCid = {};\n    },\n\n    // Prepare a model or hash of attributes to be added to this collection.\n    _prepareModel: function(attrs, options) {\n      if (attrs instanceof Model) {\n        if (!attrs.collection) attrs.collection = this;\n        return attrs;\n      }\n      options || (options = {});\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model._validate(attrs, options)) return false;\n      return model;\n    },\n\n    // Internal method to remove a model's ties to a collection.\n    _removeReference: function(model) {\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'sortedIndex', 'toArray', 'size', 'first', 'head', 'take',\n    'initial', 'rest', 'tail', 'last', 'without', 'indexOf', 'shuffle',\n    'lastIndexOf', 'isEmpty'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];\n\n  // Use attributes instead of properties.\n  _.each(attributeMethods, function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (!callback) callback = this[name];\n      Backbone.history.route(route, _.bind(function(fragment) {\n        var args = this._extractParameters(route, fragment);\n        callback && callback.apply(this, args);\n        this.trigger.apply(this, ['route:' + name].concat(args));\n        Backbone.history.trigger('route', this, name, args);\n      }, this));\n      return this;\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, '([^\\/]+)')\n                   .replace(splatParam, '(.*?)');\n      return new RegExp('^' + route + '$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted parameters.\n    _extractParameters: function(route, fragment) {\n      return route.exec(fragment).slice(1);\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on URL fragments. If the\n  // browser does not support `onhashchange`, falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = this.location.pathname;\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({}, {root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        this.iframe = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\" />').hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Backbone.$(window).bind('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        Backbone.$(window).bind('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n      var atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n\n      // If we've started off with a route from a `pushState`-enabled browser,\n      // but we're currently in a browser that doesn't support it...\n      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\n        this.fragment = this.getFragment(null, true);\n        this.location.replace(this.root + this.location.search + '#' + this.fragment);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\n        this.fragment = this.getHash().replace(routeStripper, '');\n        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Backbone.$(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);\n      clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl() || this.loadUrl(this.getHash());\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragmentOverride) {\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\n      var matched = _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n      return matched;\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: options};\n      fragment = this.getFragment(fragment || '');\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n      var url = this.root + fragment;\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Backbone.View\n  // -------------\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    this._configure(options || {});\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be prefered to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this.$el.remove();\n      this.stopListening();\n      return this;\n    },\n\n    // For small amounts of DOM Elements, where a full-blown template isn't\n    // needed, use **make** to manufacture elements, one at a time.\n    //\n    //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));\n    //\n    make: function(tagName, attributes, content) {\n      var el = document.createElement(tagName);\n      if (attributes) Backbone.$(el).attr(attributes);\n      if (content != null) Backbone.$(el).html(content);\n      return el;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save'\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = _.result(this, 'events')))) return;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) throw new Error('Method \"' + events[key] + '\" does not exist');\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.bind(eventName, method);\n        } else {\n          this.$el.delegate(selector, eventName, method);\n        }\n      }\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.unbind('.delegateEvents' + this.cid);\n    },\n\n    // Performs the initial configuration of a View with a set of options.\n    // Keys with special meaning *(model, collection, id, className)*, are\n    // attached directly to the view.\n    _configure: function(options) {\n      if (this.options) options = _.extend({}, _.result(this, 'options'), options);\n      _.extend(this, _.pick(options, viewOptions));\n      this.options = options;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        this.setElement(this.make(_.result(this, 'tagName'), attrs), false);\n      } else {\n        this.setElement(_.result(this, 'el'), false);\n      }\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    var success = options.success;\n    options.success = function(resp, status, xhr) {\n      if (success) success(resp, status, xhr);\n      model.trigger('sync', model, resp, options);\n    };\n\n    var error = options.error;\n    options.error = function(xhr, status, thrown) {\n      if (error) error(model, xhr, options);\n      model.trigger('error', model, xhr, options);\n    };\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n}).call(this);\n","/**\n * |-------------------|\n * | Backbone-Mediator |\n * |-------------------|\n *  Backbone-Mediator is freely distributable under the MIT license.\n *\n *  <a href=\"https://github.com/chalbert/Backbone-Mediator\">More details & documentation</a>\n *\n * @author Nicolas Gilbert\n *\n * @requires _\n * @requires Backbone\n */\n(function(factory){\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'backbone'], factory);\n  } else {\n    factory(_, Backbone);\n  }\n\n})(function (_, Backbone){\n  'use strict';\n\n  /**\n   * @static\n   */\n  var channels = {},\n      Subscriber,\n      /** @borrows Backbone.View#delegateEvents */\n      delegateEvents = Backbone.View.prototype.delegateEvents,\n      /** @borrows Backbone.View#delegateEvents */\n      undelegateEvents = Backbone.View.prototype.undelegateEvents;\n\n  /**\n   * @class\n   */\n  Backbone.Mediator = {\n\n    /**\n     * Subscribe to a channel\n     *\n     * @param channel\n     */\n    subscribe: function(channel, subscription, context, once) {\n      if (!channels[channel]) channels[channel] = [];\n      channels[channel].push({fn: subscription, context: context || this, once: once});\n    },\n\n    /**\n     * Trigger all callbacks for a channel\n     *\n     * @param channel\n     * @params N Extra parametter to pass to handler\n     */\n    publish: function(channel) {\n      if (!channels[channel]) return;\n\n      var args = [].slice.call(arguments, 1),\n          subscription;\n\n      for (var i = 0; i < channels[channel].length; i++) {\n        subscription = channels[channel][i];\n        subscription.fn.apply(subscription.context, args);\n        if (subscription.once) {\n          Backbone.Mediator.unsubscribe(channel, subscription.fn, subscription.context);\n          i--;\n        }\n      }\n    },\n\n    /**\n     * Cancel subscription\n     *\n     * @param channel\n     * @param fn\n     * @param context\n     */\n\n    unsubscribe: function(channel, fn, context){\n      if (!channels[channel]) return;\n\n      var subscription;\n      for (var i = 0; i < channels[channel].length; i++) {\n        subscription = channels[channel][i];\n        if (subscription.fn === fn && subscription.context === context) {\n          channels[channel].splice(i, 1);\n          i--;\n        }\n      }\n    },\n\n    /**\n     * Subscribing to one event only\n     *\n     * @param channel\n     * @param subscription\n     * @param context\n     */\n    subscribeOnce: function (channel, subscription, context) {\n      Backbone.Mediator.subscribe(channel, subscription, context, true);\n    }\n\n  };\n\n  /**\n   * Allow to define convention-based subscriptions\n   * as an 'subscriptions' hash on a view. Subscriptions\n   * can then be easily setup and cleaned.\n   *\n   * @class\n   */\n\n\n  Subscriber = {\n\n    /**\n     * Extend delegateEvents() to set subscriptions\n     */\n    delegateEvents: function(){\n      delegateEvents.apply(this, arguments);\n      this.setSubscriptions();\n    },\n\n    /**\n     * Extend undelegateEvents() to unset subscriptions\n     */\n    undelegateEvents: function(){\n      undelegateEvents.apply(this, arguments);\n      this.unsetSubscriptions();\n    },\n\n    /** @property {Object} List of subscriptions, to be defined */\n    subscriptions: {},\n\n    /**\n     * Subscribe to each subscription\n     * @param {Object} [subscriptions] An optional hash of subscription to add\n     */\n\n    setSubscriptions: function(subscriptions){\n      if (subscriptions) _.extend(this.subscriptions || {}, subscriptions);\n      subscriptions = subscriptions || this.subscriptions;\n      if (!subscriptions || _.isEmpty(subscriptions)) return;\n      // Just to be sure we don't set duplicate\n      this.unsetSubscriptions(subscriptions);\n\n      _.each(subscriptions, function(subscription, channel){\n        var once;\n        if (subscription.$once) {\n          subscription = subscription.$once;\n          once = true;\n        }\n        if (_.isString(subscription)) {\n          subscription = this[subscription];\n        }\n        Backbone.Mediator.subscribe(channel, subscription, this, once);\n      }, this);\n    },\n\n    /**\n     * Unsubscribe to each subscription\n     * @param {Object} [subscriptions] An optional hash of subscription to remove\n     */\n    unsetSubscriptions: function(subscriptions){\n      subscriptions = subscriptions || this.subscriptions;\n      if (!subscriptions || _.isEmpty(subscriptions)) return;\n      _.each(subscriptions, function(subscription, channel){\n        if (_.isString(subscription)) {\n          subscription = this[subscription];\n        }\n        Backbone.Mediator.unsubscribe(channel, subscription.$once || subscription, this);\n      }, this);\n    }\n  };\n\n  /**\n   * @lends Backbone.View.prototype\n   */\n  _.extend(Backbone.View.prototype, Subscriber);\n\n  /**\n   * @lends Backbone.Mediator\n   */\n  _.extend(Backbone.Mediator, {\n    /**\n     * Shortcut for publish\n     * @function\n     */\n    pub: Backbone.Mediator.publish,\n    /**\n     * Shortcut for subscribe\n     * @function\n     */\n    sub: Backbone.Mediator.subscribe\n  });\n\n  return Backbone;\n\n});","/*\nCopyright (c) 2011 Sencha Inc. - Author: Nicolas Garcia Belmonte (http://philogb.github.com/)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n */\n(function() {\n    window.$jit = function(x) {\n        x = x || window;\n        for (var y in $jit) {\n            if ($jit[y].$extend) {\n                x[y] = $jit[y]\n            }\n        }\n    };\n    $jit.version = \"2.0.1\";\n    var c = function(w) {\n        return document.getElementById(w)\n    };\n    c.empty = function() {};\n    c.extend = function(y, w) {\n        for (var x in (w || {})) {\n            y[x] = w[x]\n        }\n        return y\n    };\n    c.lambda = function(w) {\n        return (typeof w == \"function\") ? w : function() {\n            return w\n        }\n    };\n    c.time = Date.now || function() {\n        return + new Date\n    };\n    c.splat = function(x) {\n        var w = c.type(x);\n        return w ? ((w != \"array\") ? [x] : x) : []\n    };\n    c.type = function(x) {\n        var w = c.type.s.call(x).match(/^\\[object\\s(.*)\\]$/)[1].toLowerCase();\n        if (w != \"object\") {\n            return w\n        }\n        if (x && x.$$family) {\n            return x.$$family\n        }\n        return (x && x.nodeName && x.nodeType == 1) ? \"element\" : w\n    };\n    c.type.s = Object.prototype.toString;\n    c.each = function(B, A) {\n        var z = c.type(B);\n        if (z == \"object\") {\n            for (var y in B) {\n                A(B[y], y)\n            }\n        } else {\n            for (var x = 0, w = B.length; x < w; x++) {\n                A(B[x], x)\n            }\n        }\n    };\n    c.indexOf = function(z, y) {\n        if (Array.indexOf) {\n            return z.indexOf(y)\n        }\n        for (var x = 0, w = z.length; x < w; x++) {\n            if (z[x] === y) {\n                return x\n            }\n        }\n        return -1\n    };\n    c.map = function(y, x) {\n        var w = [];\n        c.each(y, function(A, z) {\n            w.push(x(A, z))\n        });\n        return w\n    };\n    c.reduce = function(A, y, x) {\n        var w = A.length;\n        if (w == 0) {\n            return x\n        }\n        var z = arguments.length == 3 ? x: A[--w];\n        while (w--) {\n            z = y(z, A[w])\n        }\n        return z\n    };\n    c.merge = function() {\n        var A = {};\n        for (var z = 0, w = arguments.length; z < w; z++) {\n            var x = arguments[z];\n            if (c.type(x) != \"object\") {\n                continue\n            }\n            for (var y in x) {\n                var C = x[y], B = A[y];\n                A[y] = (B && c.type(C) == \"object\" && c.type(B) == \"object\") ? c.merge(B, C) : c.unlink(C)\n            }\n        }\n        return A\n    };\n    c.unlink = function(y) {\n        var x;\n        switch (c.type(y)) {\n        case\"object\":\n            x = {};\n            for (var A in y) {\n                x[A] = c.unlink(y[A])\n            }\n            break;\n        case\"array\":\n            x = [];\n            for (var z = 0, w = y.length; z < w; z++) {\n                x[z] = c.unlink(y[z])\n            }\n            break;\n        default:\n            return y\n        }\n        return x\n    };\n    c.zip = function() {\n        if (arguments.length === 0) {\n            return []\n        }\n        for (var y = 0, x = [], w = arguments.length, B = arguments[0].length; y < B; y++) {\n            for (var z = 0, A = []; z < w; z++) {\n                A.push(arguments[z][y])\n            }\n            x.push(A)\n        }\n        return x\n    };\n    c.rgbToHex = function(A, z) {\n        if (A.length < 3) {\n            return null\n        }\n        if (A.length == 4 && A[3] == 0&&!z) {\n            return \"transparent\"\n        }\n        var x = [];\n        for (var w = 0; w < 3; w++) {\n            var y = (A[w]-0).toString(16);\n            x.push(y.length == 1 ? \"0\" + y : y)\n        }\n        return z ? x : \"#\" + x.join(\"\")\n    };\n    c.hexToRgb = function(y) {\n        if (y.length != 7) {\n            y = y.match(/^#?(\\w{1,2})(\\w{1,2})(\\w{1,2})$/);\n            y.shift();\n            if (y.length != 3) {\n                return null\n            }\n            var w = [];\n            for (var x = 0; x < 3; x++) {\n                var z = y[x];\n                if (z.length == 1) {\n                    z += z\n                }\n                w.push(parseInt(z, 16))\n            }\n            return w\n        } else {\n            y = parseInt(y.slice(1), 16);\n            return [y>>16, y>>8 & 255, y & 255]\n        }\n    };\n    c.destroy = function(w) {\n        c.clean(w);\n        if (w.parentNode) {\n            w.parentNode.removeChild(w)\n        }\n        if (w.clearAttributes) {\n            w.clearAttributes()\n        }\n    };\n    c.clean = function(z) {\n        for (var y = z.childNodes, x = 0, w = y.length; x < w; x++) {\n            c.destroy(y[x])\n        }\n    };\n    c.addEvent = function(y, x, w) {\n        if (y.addEventListener) {\n            y.addEventListener(x, w, false)\n        } else {\n            y.attachEvent(\"on\" + x, w)\n        }\n    };\n    c.addEvents = function(x, y) {\n        for (var w in y) {\n            c.addEvent(x, w, y[w])\n        }\n    };\n    c.hasClass = function(x, w) {\n        return (\" \" + x.className + \" \").indexOf(\" \" + w + \" \")>-1\n    };\n    c.addClass = function(x, w) {\n        if (!c.hasClass(x, w)) {\n            x.className = (x.className + \" \" + w)\n        }\n    };\n    c.removeClass = function(x, w) {\n        x.className = x.className.replace(new RegExp(\"(^|\\\\s)\" + w + \"(?:\\\\s|$)\"), \"$1\")\n    };\n    c.getPos = function(y) {\n        var B = A(y);\n        var w = z(y);\n        return {\n            x: B.x - w.x,\n            y: B.y - w.y\n        };\n        function A(D) {\n            var C = {\n                x: 0,\n                y: 0\n            };\n            while (D&&!x(D)) {\n                C.x += D.offsetLeft;\n                C.y += D.offsetTop;\n                D = D.offsetParent\n            }\n            return C\n        }\n        function z(D) {\n            var C = {\n                x: 0,\n                y: 0\n            };\n            while (D&&!x(D)) {\n                C.x += D.scrollLeft;\n                C.y += D.scrollTop;\n                D = D.parentNode\n            }\n            return C\n        }\n        function x(C) {\n            return (/^(?:body|html)$/i).test(C.tagName)\n        }\n    };\n    c.event = {\n        get: function(x, w) {\n            w = w || window;\n            return x || w.event\n        },\n        getWheel: function(w) {\n            return w.wheelDelta ? w.wheelDelta / 120 : - (w.detail || 0) / 3\n        },\n        isRightClick: function(w) {\n            return (w.which == 3 || w.button == 2)\n        },\n        getPos: function(z, y) {\n            y = y || window;\n            z = z || y.event;\n            var x = y.document;\n            x = x.documentElement || x.body;\n            if (z.touches && z.touches.length) {\n                z = z.touches[0]\n            }\n            var w = {\n                x: z.pageX || (z.clientX + x.scrollLeft),\n                y: z.pageY || (z.clientY + x.scrollTop)\n            };\n            return w\n        },\n        stop: function(w) {\n            if (w.stopPropagation) {\n                w.stopPropagation()\n            }\n            w.cancelBubble = true;\n            if (w.preventDefault) {\n                w.preventDefault()\n            } else {\n                w.returnValue = false\n            }\n        }\n    };\n    $jit.util = $jit.id = c;\n    var q = function(x) {\n        x = x || {};\n        var w = function() {\n            for (var A in this) {\n                if (typeof this[A] != \"function\") {\n                    this[A] = c.unlink(this[A])\n                }\n            }\n            this.constructor = w;\n            if (q.prototyping) {\n                return this\n            }\n            var z = this.initialize ? this.initialize.apply(this, arguments): this;\n            this.$$family = \"class\";\n            return z\n        };\n        for (var y in q.Mutators) {\n            if (!x[y]) {\n                continue\n            }\n            x = q.Mutators[y](x, x[y]);\n            delete x[y]\n        }\n        c.extend(w, this);\n        w.constructor = q;\n        w.prototype = x;\n        return w\n    };\n    q.Mutators = {\n        Implements: function(w, x) {\n            c.each(c.splat(x), function(z) {\n                q.prototyping = z;\n                var y = (typeof z == \"function\") ? new z: z;\n                for (var A in y) {\n                    if (!(A in w)) {\n                        w[A] = y[A]\n                    }\n                }\n                delete q.prototyping\n            });\n            return w\n        }\n    };\n    c.extend(q, {\n        inherit: function(w, z) {\n            for (var y in z) {\n                var x = z[y];\n                var B = w[y];\n                var A = c.type(x);\n                if (B && A == \"function\") {\n                    if (x != B) {\n                        q.override(w, y, x)\n                    }\n                } else {\n                    if (A == \"object\") {\n                        w[y] = c.merge(B, x)\n                    } else {\n                        w[y] = x\n                    }\n                }\n            }\n            return w\n        },\n        override: function(x, w, A) {\n            var z = q.prototyping;\n            if (z && x[w] != z[w]) {\n                z = null\n            }\n            var y = function() {\n                var B = this.parent;\n                this.parent = z ? z[w] : x[w];\n                var C = A.apply(this, arguments);\n                this.parent = B;\n                return C\n            };\n            x[w] = y\n        }\n    });\n    q.prototype.implement = function() {\n        var w = this.prototype;\n        c.each(Array.prototype.slice.call(arguments || []), function(x) {\n            q.inherit(w, x)\n        });\n        return this\n    };\n    $jit.Class = q;\n    $jit.json = {\n        prune: function(x, w) {\n            this.each(x, function(z, y) {\n                if (y == w && z.children) {\n                    delete z.children;\n                    z.children = []\n                }\n            })\n        },\n        getParent: function(w, A) {\n            if (w.id == A) {\n                return false\n            }\n            var z = w.children;\n            if (z && z.length > 0) {\n                for (var y = 0; y < z.length; y++) {\n                    if (z[y].id == A) {\n                        return w\n                    } else {\n                        var x = this.getParent(z[y], A);\n                        if (x) {\n                            return x\n                        }\n                    }\n                }\n            }\n            return false\n        },\n        getSubtree: function(w, A) {\n            if (w.id == A) {\n                return w\n            }\n            for (var y = 0, z = w.children; z && y < z.length; y++) {\n                var x = this.getSubtree(z[y], A);\n                if (x != null) {\n                    return x\n                }\n            }\n            return null\n        },\n        eachLevel: function(w, B, y, A) {\n            if (B <= y) {\n                A(w, B);\n                if (!w.children) {\n                    return \n                }\n                for (var x = 0, z = w.children; x < z.length; x++) {\n                    this.eachLevel(z[x], B + 1, y, A)\n                }\n            }\n        },\n        each: function(w, x) {\n            this.eachLevel(w, 0, Number.MAX_VALUE, x)\n        }\n    };\n    $jit.Trans = {\n        $extend: true,\n        linear: function(w) {\n            return w\n        }\n    };\n    var i = $jit.Trans;\n    (function() {\n        var w = function(z, y) {\n            y = c.splat(y);\n            return c.extend(z, {\n                easeIn: function(A) {\n                    return z(A, y)\n                },\n                easeOut: function(A) {\n                    return 1 - z(1 - A, y)\n                },\n                easeInOut: function(A) {\n                    return (A <= 0.5) ? z(2 * A, y) / 2 : (2 - z(2 * (1 - A), y)) / 2\n                }\n            })\n        };\n        var x = {\n            Pow: function(z, y) {\n                return Math.pow(z, y[0] || 6)\n            },\n            Expo: function(y) {\n                return Math.pow(2, 8 * (y-1))\n            },\n            Circ: function(y) {\n                return 1 - Math.sin(Math.acos(y))\n            },\n            Sine: function(y) {\n                return 1 - Math.sin((1 - y) * Math.PI / 2)\n            },\n            Back: function(z, y) {\n                y = y[0] || 1.618;\n                return Math.pow(z, 2) * ((y + 1) * z - y)\n            },\n            Bounce: function(B) {\n                var A;\n                for (var z = 0, y = 1; 1; z += y, y/=2) {\n                    if (B >= (7-4 * z) / 11) {\n                        A = y * y - Math.pow((11-6 * z-11 * B) / 4, 2);\n                        break\n                    }\n                }\n                return A\n            },\n            Elastic: function(z, y) {\n                return Math.pow(2, 10*--z) * Math.cos(20 * z * Math.PI * (y[0] || 1) / 3)\n            }\n        };\n        c.each(x, function(z, y) {\n            i[y] = w(z)\n        });\n        c.each([\"Quad\", \"Cubic\", \"Quart\", \"Quint\"], function(z, y) {\n            i[z] = w(function(A) {\n                return Math.pow(A, [y + 2])\n            })\n        })\n    })();\n    var u = new q({\n        initialize: function(w) {\n            this.setOptions(w)\n        },\n        setOptions: function(w) {\n            var x = {\n                duration: 2500,\n                fps: 40,\n                transition: i.Quart.easeInOut,\n                compute: c.empty,\n                complete: c.empty,\n                link: \"ignore\"\n            };\n            this.opt = c.merge(x, w || {});\n            return this\n        },\n        step: function() {\n            var x = c.time(), w = this.opt;\n            if (x < this.time + w.duration) {\n                var y = w.transition((x - this.time) / w.duration);\n                w.compute(y)\n            } else {\n                this.timer = clearInterval(this.timer);\n                w.compute(1);\n                w.complete()\n            }\n        },\n        start: function() {\n            if (!this.check()) {\n                return this\n            }\n            this.time = 0;\n            this.startTimer();\n            return this\n        },\n        startTimer: function() {\n            var w = this, x = this.opt.fps;\n            if (this.timer) {\n                return false\n            }\n            this.time = c.time() - this.time;\n            this.timer = setInterval((function() {\n                w.step()\n            }), Math.round(1000 / x));\n            return true\n        },\n        pause: function() {\n            this.stopTimer();\n            return this\n        },\n        resume: function() {\n            this.startTimer();\n            return this\n        },\n        stopTimer: function() {\n            if (!this.timer) {\n                return false\n            }\n            this.time = c.time() - this.time;\n            this.timer = clearInterval(this.timer);\n            return true\n        },\n        check: function() {\n            if (!this.timer) {\n                return true\n            }\n            if (this.opt.link == \"cancel\") {\n                this.stopTimer();\n                return true\n            }\n            return false\n        }\n    });\n    var n = function() {\n        var y = arguments;\n        for (var A = 0, w = y.length, x = {}; A < w; A++) {\n            var z = n[y[A]];\n            if (z.$extend) {\n                c.extend(x, z)\n            } else {\n                x[y[A]] = z\n            }\n        }\n        return x\n    };\n    n.AreaChart = {\n        $extend: true,\n        animate: true,\n        labelOffset: 3,\n        type: \"stacked\",\n        Tips: {\n            enable: false,\n            onShow: c.empty,\n            onHide: c.empty\n        },\n        Events: {\n            enable: false,\n            onClick: c.empty\n        },\n        selectOnHover: true,\n        showAggregates: true,\n        showLabels: true,\n        filterOnClick: false,\n        restoreOnRightClick: false\n    };\n    n.Margin = {\n        $extend: false,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n    };\n    n.Canvas = {\n        $extend: true,\n        injectInto: \"id\",\n        type: \"2D\",\n        width: false,\n        height: false,\n        useCanvas: false,\n        withLabels: true,\n        background: false,\n        Scene: {\n            Lighting: {\n                enable: false,\n                ambient: [1, 1, 1],\n                directional: {\n                    direction: {\n                        x: -100,\n                        y: -100,\n                        z: -100\n                    },\n                    color: [0.5, 0.3, 0.1]\n                }\n            }\n        }\n    };\n    n.Tree = {\n        $extend: true,\n        orientation: \"left\",\n        subtreeOffset: 8,\n        siblingOffset: 5,\n        indent: 10,\n        multitree: false,\n        align: \"center\"\n    };\n    n.Node = {\n        $extend: false,\n        overridable: false,\n        type: \"circle\",\n        color: \"#ccb\",\n        alpha: 1,\n        dim: 3,\n        height: 20,\n        width: 90,\n        autoHeight: false,\n        autoWidth: false,\n        lineWidth: 1,\n        transform: true,\n        align: \"center\",\n        angularWidth: 1,\n        span: 1,\n        CanvasStyles: {}\n    };\n    n.Edge = {\n        $extend: false,\n        overridable: false,\n        type: \"line\",\n        color: \"#ccb\",\n        lineWidth: 1,\n        dim: 15,\n        alpha: 1,\n        epsilon: 7,\n        CanvasStyles: {}\n    };\n    n.Fx = {\n        $extend: true,\n        fps: 40,\n        duration: 2500,\n        transition: $jit.Trans.Quart.easeInOut,\n        clearCanvas: true\n    };\n    n.Label = {\n        $extend: false,\n        overridable: false,\n        type: \"HTML\",\n        style: \" \",\n        size: 10,\n        family: \"sans-serif\",\n        textAlign: \"center\",\n        textBaseline: \"alphabetic\",\n        color: \"#fff\"\n    };\n    n.Tips = {\n        $extend: false,\n        enable: false,\n        type: \"auto\",\n        offsetX: 20,\n        offsetY: 20,\n        force: false,\n        onShow: c.empty,\n        onHide: c.empty\n    };\n    n.NodeStyles = {\n        $extend: false,\n        enable: false,\n        type: \"auto\",\n        stylesHover: false,\n        stylesClick: false\n    };\n    n.Events = {\n        $extend: false,\n        enable: false,\n        enableForEdges: false,\n        type: \"auto\",\n        onClick: c.empty,\n        onRightClick: c.empty,\n        onMouseMove: c.empty,\n        onMouseEnter: c.empty,\n        onMouseLeave: c.empty,\n        onDragStart: c.empty,\n        onDragMove: c.empty,\n        onDragCancel: c.empty,\n        onDragEnd: c.empty,\n        onTouchStart: c.empty,\n        onTouchMove: c.empty,\n        onTouchEnd: c.empty,\n        onMouseWheel: c.empty\n    };\n    n.Navigation = {\n        $extend: false,\n        enable: false,\n        type: \"auto\",\n        panning: false,\n        zooming: false\n    };\n    n.Controller = {\n        $extend: true,\n        onBeforeCompute: c.empty,\n        onAfterCompute: c.empty,\n        onCreateLabel: c.empty,\n        onPlaceLabel: c.empty,\n        onComplete: c.empty,\n        onBeforePlotLine: c.empty,\n        onAfterPlotLine: c.empty,\n        onBeforePlotNode: c.empty,\n        onAfterPlotNode: c.empty,\n        request: false\n    };\n    var t = {\n        initialize: function(y, w) {\n            this.viz = w;\n            this.canvas = w.canvas;\n            this.config = w.config[y];\n            this.nodeTypes = w.fx.nodeTypes;\n            var x = this.config.type;\n            this.dom = x == \"auto\" ? (w.config.Label.type != \"Native\") : (x != \"Native\");\n            this.labelContainer = this.dom && w.labels.getLabelContainer();\n            this.isEnabled() && this.initializePost()\n        },\n        initializePost: c.empty,\n        setAsProperty: c.lambda(false),\n        isEnabled: function() {\n            return this.config.enable\n        },\n        isLabel: function(B, A, z) {\n            B = c.event.get(B, A);\n            var w = this.labelContainer, y = B.target || B.srcElement, x = B.relatedTarget;\n            if (z) {\n                return x && x == this.viz.canvas.getCtx().canvas&&!!y && this.isDescendantOf(y, w)\n            } else {\n                return this.isDescendantOf(y, w)\n            }\n        },\n        isDescendantOf: function(x, w) {\n            while (x && x.parentNode) {\n                if (x.parentNode == w) {\n                    return x\n                }\n                x = x.parentNode\n            }\n            return false\n        }\n    };\n    var h = {\n        onMouseUp: c.empty,\n        onMouseDown: c.empty,\n        onMouseMove: c.empty,\n        onMouseOver: c.empty,\n        onMouseOut: c.empty,\n        onMouseWheel: c.empty,\n        onTouchStart: c.empty,\n        onTouchMove: c.empty,\n        onTouchEnd: c.empty,\n        onTouchCancel: c.empty\n    };\n    var s = new q({\n        initialize: function(w) {\n            this.viz = w;\n            this.canvas = w.canvas;\n            this.node = false;\n            this.edge = false;\n            this.registeredObjects = [];\n            this.attachEvents()\n        },\n        attachEvents: function() {\n            var y = this.canvas.getElement(), x = this;\n            y.oncontextmenu = c.lambda(false);\n            c.addEvents(y, {\n                mouseup: function(B, A) {\n                    var z = c.event.get(B, A);\n                    x.handleEvent(\"MouseUp\", B, A, x.makeEventObject(B, A), c.event.isRightClick(z))\n                },\n                mousedown: function(B, A) {\n                    var z = c.event.get(B, A);\n                    x.handleEvent(\"MouseDown\", B, A, x.makeEventObject(B, A), c.event.isRightClick(z))\n                },\n                mousemove: function(A, z) {\n                    x.handleEvent(\"MouseMove\", A, z, x.makeEventObject(A, z))\n                },\n                mouseover: function(A, z) {\n                    x.handleEvent(\"MouseOver\", A, z, x.makeEventObject(A, z))\n                },\n                mouseout: function(A, z) {\n                    x.handleEvent(\"MouseOut\", A, z, x.makeEventObject(A, z))\n                },\n                touchstart: function(A, z) {\n                    x.handleEvent(\"TouchStart\", A, z, x.makeEventObject(A, z))\n                },\n                touchmove: function(A, z) {\n                    x.handleEvent(\"TouchMove\", A, z, x.makeEventObject(A, z))\n                },\n                touchend: function(A, z) {\n                    x.handleEvent(\"TouchEnd\", A, z, x.makeEventObject(A, z))\n                }\n            });\n            var w = function(C, B) {\n                var A = c.event.get(C, B);\n                var z = c.event.getWheel(A);\n                x.handleEvent(\"MouseWheel\", C, B, z)\n            };\n            if (!document.getBoxObjectFor && window.mozInnerScreenX == null) {\n                c.addEvent(y, \"mousewheel\", w)\n            } else {\n                y.addEventListener(\"DOMMouseScroll\", w, false)\n            }\n        },\n        register: function(w) {\n            this.registeredObjects.push(w)\n        },\n        handleEvent: function() {\n            var x = Array.prototype.slice.call(arguments), A = x.shift();\n            for (var z = 0, y = this.registeredObjects, w = y.length; z < w; z++) {\n                y[z][\"on\" + A].apply(y[z], x)\n            }\n        },\n        makeEventObject: function(C, B) {\n            var z = this, A = this.viz.graph, y = this.viz.fx, x = y.nodeTypes, w = y.edgeTypes;\n            return {\n                pos: false,\n                node: false,\n                edge: false,\n                contains: false,\n                getNodeCalled: false,\n                getEdgeCalled: false,\n                getPos: function() {\n                    var F = z.viz.canvas, G = F.getSize(), H = F.getPos(), E = F.translateOffsetX, D = F.translateOffsetY, K = F.scaleOffsetX, I = F.scaleOffsetY, J = c.event.getPos(C, B);\n                    this.pos = {\n                        x: (J.x - H.x - G.width / 2 - E) * 1 / K,\n                        y: (J.y - H.y - G.height / 2 - D) * 1 / I\n                    };\n                    return this.pos\n                },\n                getNode: function() {\n                    if (this.getNodeCalled) {\n                        return this.node\n                    }\n                    this.getNodeCalled = true;\n                    for (var G in A.nodes) {\n                        var F = A.nodes[G], E = F && x[F.getData(\"type\")], D = E && E.contains && E.contains.call(y, F, this.getPos());\n                        if (D) {\n                            this.contains = D;\n                            return z.node = this.node = F\n                        }\n                    }\n                    return z.node = this.node = false\n                },\n                getEdge: function() {\n                    if (this.getEdgeCalled) {\n                        return this.edge\n                    }\n                    this.getEdgeCalled = true;\n                    var F = {};\n                    for (var J in A.edges) {\n                        var H = A.edges[J];\n                        F[J] = true;\n                        for (var I in H) {\n                            if (I in F) {\n                                continue\n                            }\n                            var G = H[I], E = G && w[G.getData(\"type\")], D = E && E.contains && E.contains.call(y, G, this.getPos());\n                            if (D) {\n                                this.contains = D;\n                                return z.edge = this.edge = G\n                            }\n                        }\n                    }\n                    return z.edge = this.edge = false\n                },\n                getContains: function() {\n                    if (this.getNodeCalled) {\n                        return this.contains\n                    }\n                    this.getNode();\n                    return this.contains\n                }\n            }\n        }\n    });\n    var o = {\n        initializeExtras: function() {\n            var x = new s(this), w = this;\n            c.each([\"NodeStyles\", \"Tips\", \"Navigation\", \"Events\"], function(y) {\n                var z = new o.Classes[y](y, w);\n                if (z.isEnabled()) {\n                    x.register(z)\n                }\n                if (z.setAsProperty()) {\n                    w[y.toLowerCase()] = z\n                }\n            })\n        }\n    };\n    o.Classes = {};\n    o.Classes.Events = new q({\n        Implements: [t, h],\n        initializePost: function() {\n            this.fx = this.viz.fx;\n            this.ntypes = this.viz.fx.nodeTypes;\n            this.etypes = this.viz.fx.edgeTypes;\n            this.hovered = false;\n            this.pressed = false;\n            this.touched = false;\n            this.touchMoved = false;\n            this.moved = false\n        },\n        setAsProperty: c.lambda(true),\n        onMouseUp: function(A, z, x, y) {\n            var w = c.event.get(A, z);\n            if (!this.moved) {\n                if (y) {\n                    this.config.onRightClick(this.hovered, x, w)\n                } else {\n                    this.config.onClick(this.pressed, x, w)\n                }\n            }\n            if (this.pressed) {\n                if (this.moved) {\n                    this.config.onDragEnd(this.pressed, x, w)\n                } else {\n                    this.config.onDragCancel(this.pressed, x, w)\n                }\n                this.pressed = this.moved = false\n            }\n        },\n        onMouseOut: function(B, A, z) {\n            var x = c.event.get(B, A), y;\n            if (this.dom && (y = this.isLabel(B, A, true))) {\n                this.config.onMouseLeave(this.viz.graph.getNode(y.id), z, x);\n                this.hovered = false;\n                return \n            }\n            var w = x.relatedTarget, C = this.canvas.getElement();\n            while (w && w.parentNode) {\n                if (C == w.parentNode) {\n                    return \n                }\n                w = w.parentNode\n            }\n            if (this.hovered) {\n                this.config.onMouseLeave(this.hovered, z, x);\n                this.hovered = false\n            }\n        },\n        onMouseOver: function(A, z, y) {\n            var w = c.event.get(A, z), x;\n            if (this.dom && (x = this.isLabel(A, z, true))) {\n                this.hovered = this.viz.graph.getNode(x.id);\n                this.config.onMouseEnter(this.hovered, y, w)\n            }\n        },\n        onMouseMove: function(C, B, A) {\n            var x, w = c.event.get(C, B);\n            if (this.pressed) {\n                this.moved = true;\n                this.config.onDragMove(this.pressed, A, w);\n                return \n            }\n            if (this.dom) {\n                this.config.onMouseMove(this.hovered, A, w)\n            } else {\n                if (this.hovered) {\n                    var D = this.hovered;\n                    var z = D.nodeFrom ? this.etypes[D.getData(\"type\")]: this.ntypes[D.getData(\"type\")];\n                    var y = z && z.contains && z.contains.call(this.fx, D, A.getPos());\n                    if (y) {\n                        this.config.onMouseMove(D, A, w);\n                        return \n                    } else {\n                        this.config.onMouseLeave(D, A, w);\n                        this.hovered = false\n                    }\n                }\n                if (this.hovered = (A.getNode() || (this.config.enableForEdges && A.getEdge()))) {\n                    this.config.onMouseEnter(this.hovered, A, w)\n                } else {\n                    this.config.onMouseMove(false, A, w)\n                }\n            }\n        },\n        onMouseWheel: function(x, w, y) {\n            this.config.onMouseWheel(y, c.event.get(x, w))\n        },\n        onMouseDown: function(A, z, y) {\n            var w = c.event.get(A, z), x;\n            if (this.dom) {\n                if (x = this.isLabel(A, z)) {\n                    this.pressed = this.viz.graph.getNode(x.id)\n                }\n            } else {\n                this.pressed = y.getNode() || (this.config.enableForEdges && y.getEdge())\n            }\n            this.pressed && this.config.onDragStart(this.pressed, y, w)\n        },\n        onTouchStart: function(A, z, y) {\n            var w = c.event.get(A, z), x;\n            if (this.dom && (x = this.isLabel(A, z))) {\n                this.touched = this.viz.graph.getNode(x.id)\n            } else {\n                this.touched = y.getNode() || (this.config.enableForEdges && y.getEdge())\n            }\n            this.touched && this.config.onTouchStart(this.touched, y, w)\n        },\n        onTouchMove: function(z, y, x) {\n            var w = c.event.get(z, y);\n            if (this.touched) {\n                this.touchMoved = true;\n                this.config.onTouchMove(this.touched, x, w)\n            }\n        },\n        onTouchEnd: function(z, y, x) {\n            var w = c.event.get(z, y);\n            if (this.touched) {\n                if (this.touchMoved) {\n                    this.config.onTouchEnd(this.touched, x, w)\n                } else {\n                    this.config.onTouchCancel(this.touched, x, w)\n                }\n                this.touched = this.touchMoved = false\n            }\n        }\n    });\n    o.Classes.Tips = new q({\n        Implements: [t, h],\n        initializePost: function() {\n            if (document.body) {\n                var w = c(\"_tooltip\") || document.createElement(\"div\");\n                w.id = \"_tooltip\";\n                w.className = \"tip\";\n                c.extend(w.style, {\n                    position: \"absolute\",\n                    display: \"none\",\n                    zIndex: 13000\n                });\n                document.body.appendChild(w);\n                this.tip = w;\n                this.node = false\n            }\n        },\n        setAsProperty: c.lambda(true),\n        onMouseOut: function(z, y) {\n            var x = c.event.get(z, y);\n            if (this.dom && this.isLabel(z, y, true)) {\n                this.hide(true);\n                return \n            }\n            var w = z.relatedTarget, A = this.canvas.getElement();\n            while (w && w.parentNode) {\n                if (A == w.parentNode) {\n                    return \n                }\n                w = w.parentNode\n            }\n            this.hide(false)\n        },\n        onMouseOver: function(y, x) {\n            var w;\n            if (this.dom && (w = this.isLabel(y, x, false))) {\n                this.node = this.viz.graph.getNode(w.id);\n                this.config.onShow(this.tip, this.node, w)\n            }\n        },\n        onMouseMove: function(z, y, w) {\n            if (this.dom && this.isLabel(z, y)) {\n                this.setTooltipPosition(c.event.getPos(z, y))\n            }\n            if (!this.dom) {\n                var x = w.getNode();\n                if (!x) {\n                    this.hide(true);\n                    return \n                }\n                if (this.config.force ||!this.node || this.node.id != x.id) {\n                    this.node = x;\n                    this.config.onShow(this.tip, x, w.getContains())\n                }\n                this.setTooltipPosition(c.event.getPos(z, y))\n            }\n        },\n        setTooltipPosition: function(F) {\n            var B = this.tip, A = B.style, z = this.config;\n            A.display = \"\";\n            var D = {\n                height: document.body.clientHeight,\n                width: document.body.clientWidth\n            };\n            var C = {\n                width: B.offsetWidth,\n                height: B.offsetHeight\n            };\n            var w = z.offsetX, E = z.offsetY;\n            A.top = ((F.y + E + C.height > D.height) ? (F.y - C.height - E) : F.y + E) + \"px\";\n            A.left = ((F.x + C.width + w > D.width) ? (F.x - C.width - w) : F.x + w) + \"px\"\n        },\n        hide: function(w) {\n            this.tip.style.display = \"none\";\n            w && this.config.onHide()\n        }\n    });\n    o.Classes.NodeStyles = new q({\n        Implements: [t, h],\n        initializePost: function() {\n            this.fx = this.viz.fx;\n            this.types = this.viz.fx.nodeTypes;\n            this.nStyles = this.config;\n            this.nodeStylesOnHover = this.nStyles.stylesHover;\n            this.nodeStylesOnClick = this.nStyles.stylesClick;\n            this.hoveredNode = false;\n            this.fx.nodeFxAnimation = new u();\n            this.down = false;\n            this.move = false\n        },\n        onMouseOut: function(y, x) {\n            this.down = this.move = false;\n            if (!this.hoveredNode) {\n                return \n            }\n            if (this.dom && this.isLabel(y, x, true)) {\n                this.toggleStylesOnHover(this.hoveredNode, false)\n            }\n            var w = y.relatedTarget, z = this.canvas.getElement();\n            while (w && w.parentNode) {\n                if (z == w.parentNode) {\n                    return \n                }\n                w = w.parentNode\n            }\n            this.toggleStylesOnHover(this.hoveredNode, false);\n            this.hoveredNode = false\n        },\n        onMouseOver: function(z, y) {\n            var w;\n            if (this.dom && (w = this.isLabel(z, y, true))) {\n                var x = this.viz.graph.getNode(w.id);\n                if (x.selected) {\n                    return \n                }\n                this.hoveredNode = x;\n                this.toggleStylesOnHover(this.hoveredNode, true)\n            }\n        },\n        onMouseDown: function(A, z, x, y) {\n            if (y) {\n                return \n            }\n            var w;\n            if (this.dom && (w = this.isLabel(A, z))) {\n                this.down = this.viz.graph.getNode(w.id)\n            } else {\n                if (!this.dom) {\n                    this.down = x.getNode()\n                }\n            }\n            this.move = false\n        },\n        onMouseUp: function(z, y, w, x) {\n            if (x) {\n                return \n            }\n            if (!this.move) {\n                this.onClick(w.getNode())\n            }\n            this.down = this.move = false\n        },\n        getRestoredStyles: function(x, w) {\n            var z = {}, y = this[\"nodeStylesOn\" + w];\n            for (var A in y) {\n                z[A] = x.styles[\"$\" + A]\n            }\n            return z\n        },\n        toggleStylesOnHover: function(w, x) {\n            if (this.nodeStylesOnHover) {\n                this.toggleStylesOn(\"Hover\", w, x)\n            }\n        },\n        toggleStylesOnClick: function(w, x) {\n            if (this.nodeStylesOnClick) {\n                this.toggleStylesOn(\"Click\", w, x)\n            }\n        },\n        toggleStylesOn: function(A, w, C) {\n            var D = this.viz;\n            var B = this.nStyles;\n            if (C) {\n                var z = this;\n                if (!w.styles) {\n                    w.styles = c.merge(w.data, {})\n                }\n                for (var E in this[\"nodeStylesOn\" + A]) {\n                    var x = \"$\" + E;\n                    if (!(x in w.styles)) {\n                        w.styles[x] = w.getData(E)\n                    }\n                }\n                D.fx.nodeFx(c.extend({\n                    elements: {\n                        id: w.id,\n                        properties: z[\"nodeStylesOn\" + A]\n                    },\n                    transition: i.Quart.easeOut,\n                    duration: 300,\n                    fps: 40\n                }, this.config))\n            } else {\n                var y = this.getRestoredStyles(w, A);\n                D.fx.nodeFx(c.extend({\n                    elements: {\n                        id: w.id,\n                        properties: y\n                    },\n                    transition: i.Quart.easeOut,\n                    duration: 300,\n                    fps: 40\n                }, this.config))\n            }\n        },\n        onClick: function(w) {\n            if (!w) {\n                return \n            }\n            var x = this.nodeStylesOnClick;\n            if (!x) {\n                return \n            }\n            if (w.selected) {\n                this.toggleStylesOnClick(w, false);\n                delete w.selected\n            } else {\n                this.viz.graph.eachNode(function(z) {\n                    if (z.selected) {\n                        for (var y in x) {\n                            z.setData(y, z.styles[\"$\" + y], \"end\")\n                        }\n                        delete z.selected\n                    }\n                });\n                this.toggleStylesOnClick(w, true);\n                w.selected = true;\n                delete w.hovered;\n                this.hoveredNode = false\n            }\n        },\n        onMouseMove: function(C, B, z) {\n            if (this.down) {\n                this.move = true\n            }\n            if (this.dom && this.isLabel(C, B)) {\n                return \n            }\n            var A = this.nodeStylesOnHover;\n            if (!A) {\n                return \n            }\n            if (!this.dom) {\n                if (this.hoveredNode) {\n                    var x = this.types[this.hoveredNode.getData(\"type\")];\n                    var w = x && x.contains && x.contains.call(this.fx, this.hoveredNode, z.getPos());\n                    if (w) {\n                        return \n                    }\n                }\n                var y = z.getNode();\n                if (!this.hoveredNode&&!y) {\n                    return \n                }\n                if (y.hovered) {\n                    return \n                }\n                if (y&&!y.selected) {\n                    this.fx.nodeFxAnimation.stopTimer();\n                    this.viz.graph.eachNode(function(E) {\n                        if (E.hovered&&!E.selected) {\n                            for (var D in A) {\n                                E.setData(D, E.styles[\"$\" + D], \"end\")\n                            }\n                            delete E.hovered\n                        }\n                    });\n                    y.hovered = true;\n                    this.hoveredNode = y;\n                    this.toggleStylesOnHover(y, true)\n                } else {\n                    if (this.hoveredNode&&!this.hoveredNode.selected) {\n                        this.fx.nodeFxAnimation.stopTimer();\n                        this.toggleStylesOnHover(this.hoveredNode, false);\n                        delete this.hoveredNode.hovered;\n                        this.hoveredNode = false\n                    }\n                }\n            }\n        }\n    });\n    o.Classes.Navigation = new q({\n        Implements: [t, h],\n        initializePost: function() {\n            this.pos = false;\n            this.pressed = false\n        },\n        onMouseWheel: function(z, y, w) {\n            if (!this.config.zooming) {\n                return \n            }\n            c.event.stop(c.event.get(z, y));\n            var A = this.config.zooming / 1000, x = 1 + w * A;\n            this.canvas.scale(x, x)\n        },\n        onMouseDown: function(B, A, z) {\n            if (!this.config.panning) {\n                return \n            }\n            if (this.config.panning == \"avoid nodes\" && (this.dom ? this.isLabel(B, A) : z.getNode())) {\n                return \n            }\n            this.pressed = true;\n            this.pos = z.getPos();\n            var y = this.canvas, x = y.translateOffsetX, w = y.translateOffsetY, D = y.scaleOffsetX, C = y.scaleOffsetY;\n            this.pos.x*=D;\n            this.pos.x += x;\n            this.pos.y*=C;\n            this.pos.y += w\n        },\n        onMouseMove: function(D, C, F) {\n            if (!this.config.panning) {\n                return \n            }\n            if (!this.pressed) {\n                return \n            }\n            if (this.config.panning == \"avoid nodes\" && (this.dom ? this.isLabel(D, C) : F.getNode())) {\n                return \n            }\n            var B = this.pos, E = F.getPos(), z = this.canvas, A = z.translateOffsetX, w = z.translateOffsetY, J = z.scaleOffsetX, H = z.scaleOffsetY;\n            E.x*=J;\n            E.y*=H;\n            E.x += A;\n            E.y += w;\n            var I = E.x - B.x, G = E.y - B.y;\n            this.pos = E;\n            this.canvas.translate(I * 1 / J, G * 1 / H)\n        },\n        onMouseUp: function(z, y, x, w) {\n            if (!this.config.panning) {\n                return \n            }\n            this.pressed = false\n        }\n    });\n    var l;\n    (function() {\n        var w = typeof HTMLCanvasElement, y = (w == \"object\" || w == \"function\");\n        function x(z, A) {\n            var B = document.createElement(z);\n            for (var C in A) {\n                if (typeof A[C] == \"object\") {\n                    c.extend(B[C], A[C])\n                } else {\n                    B[C] = A[C]\n                }\n            }\n            if (z == \"canvas\"&&!y && G_vmlCanvasManager) {\n                B = G_vmlCanvasManager.initElement(document.body.appendChild(B))\n            }\n            return B\n        }\n        $jit.Canvas = l = new q({\n            canvases: [],\n            pos: false,\n            element: false,\n            labelContainer: false,\n            translateOffsetX: 0,\n            translateOffsetY: 0,\n            scaleOffsetX: 1,\n            scaleOffsetY: 1,\n            initialize: function(L, E) {\n                this.viz = L;\n                this.opt = this.config = E;\n                var B = c.type(E.injectInto) == \"string\" ? E.injectInto: E.injectInto.id, K = E.type, C = B + \"-label\", z = c(B), D = E.width || z.offsetWidth, M = E.height || z.offsetHeight;\n                this.id = B;\n                var F = {\n                    injectInto: B,\n                    width: D,\n                    height: M\n                };\n                this.element = x(\"div\", {\n                    id: B + \"-canvaswidget\",\n                    style: {\n                        position: \"relative\",\n                        width: D + \"px\",\n                        height: M + \"px\"\n                    }\n                });\n                this.labelContainer = this.createLabelContainer(E.Label.type, C, F);\n                this.canvases.push(new l.Base[K]({\n                    config: c.extend({\n                        idSuffix: \"-canvas\"\n                    }, F),\n                    plot: function(N) {\n                        L.fx.plot()\n                    },\n                    resize: function() {\n                        L.refresh()\n                    }\n                }));\n                var G = E.background;\n                if (G) {\n                    var J = new l.Background[G.type](L, c.extend(G, F));\n                    this.canvases.push(new l.Base[K](J))\n                }\n                var I = this.canvases.length;\n                while (I--) {\n                    this.element.appendChild(this.canvases[I].canvas);\n                    if (I > 0) {\n                        this.canvases[I].plot()\n                    }\n                }\n                this.element.appendChild(this.labelContainer);\n                z.appendChild(this.element);\n                var A = null, H = this;\n                c.addEvent(window, \"scroll\", function() {\n                    clearTimeout(A);\n                    A = setTimeout(function() {\n                        H.getPos(true)\n                    }, 500)\n                })\n            },\n            getCtx: function(z) {\n                return this.canvases[z || 0].getCtx()\n            },\n            getConfig: function() {\n                return this.opt\n            },\n            getElement: function() {\n                return this.element\n            },\n            getSize: function(z) {\n                return this.canvases[z || 0].getSize()\n            },\n            resize: function(D, z) {\n                this.getPos(true);\n                this.translateOffsetX = this.translateOffsetY = 0;\n                this.scaleOffsetX = this.scaleOffsetY = 1;\n                for (var B = 0, A = this.canvases.length; B < A; B++) {\n                    this.canvases[B].resize(D, z)\n                }\n                var C = this.element.style;\n                C.width = D + \"px\";\n                C.height = z + \"px\";\n                if (this.labelContainer) {\n                    this.labelContainer.style.width = D + \"px\"\n                }\n            },\n            translate: function(z, D, C) {\n                this.translateOffsetX += z * this.scaleOffsetX;\n                this.translateOffsetY += D * this.scaleOffsetY;\n                for (var B = 0, A = this.canvases.length; B < A; B++) {\n                    this.canvases[B].translate(z, D, C)\n                }\n            },\n            scale: function(E, B, C) {\n                var F = this.scaleOffsetX * E, D = this.scaleOffsetY * B;\n                var H = this.translateOffsetX * (E-1) / F, G = this.translateOffsetY * (B-1) / D;\n                this.scaleOffsetX = F;\n                this.scaleOffsetY = D;\n                for (var A = 0, z = this.canvases.length; A < z; A++) {\n                    this.canvases[A].scale(E, B, true)\n                }\n                this.translate(H, G, false)\n            },\n            getPos: function(z) {\n                if (z ||!this.pos) {\n                    return this.pos = c.getPos(this.getElement())\n                }\n                return this.pos\n            },\n            clear: function(z) {\n                this.canvases[z || 0].clear()\n            },\n            path: function(A, B) {\n                var z = this.canvases[0].getCtx();\n                z.beginPath();\n                B(z);\n                z[A]();\n                z.closePath()\n            },\n            createLabelContainer: function(B, F, E) {\n                var D = \"http://www.w3.org/2000/svg\";\n                if (B == \"HTML\" || B == \"Native\") {\n                    return x(\"div\", {\n                        id: F,\n                        style: {\n                            overflow: \"visible\",\n                            position: \"absolute\",\n                            top: 0,\n                            left: 0,\n                            width: E.width + \"px\",\n                            height: 0\n                        }\n                    })\n                } else {\n                    if (B == \"SVG\") {\n                        var C = document.createElementNS(D, \"svg:svg\");\n                        C.setAttribute(\"width\", E.width);\n                        C.setAttribute(\"height\", E.height);\n                        var A = C.style;\n                        A.position = \"absolute\";\n                        A.left = A.top = \"0px\";\n                        var z = document.createElementNS(D, \"svg:g\");\n                        z.setAttribute(\"width\", E.width);\n                        z.setAttribute(\"height\", E.height);\n                        z.setAttribute(\"x\", 0);\n                        z.setAttribute(\"y\", 0);\n                        z.setAttribute(\"id\", F);\n                        C.appendChild(z);\n                        return C\n                    }\n                }\n            }\n        });\n        l.Base = {};\n        l.Base[\"2D\"] = new q({\n            translateOffsetX: 0,\n            translateOffsetY: 0,\n            scaleOffsetX: 1,\n            scaleOffsetY: 1,\n            initialize: function(z) {\n                this.viz = z;\n                this.opt = z.config;\n                this.size = false;\n                this.createCanvas();\n                this.translateToCenter()\n            },\n            createCanvas: function() {\n                var A = this.opt, B = A.width, z = A.height;\n                this.canvas = x(\"canvas\", {\n                    id: A.injectInto + A.idSuffix,\n                    width: B,\n                    height: z,\n                    style: {\n                        position: \"absolute\",\n                        top: 0,\n                        left: 0,\n                        width: B + \"px\",\n                        height: z + \"px\"\n                    }\n                })\n            },\n            getCtx: function() {\n                if (!this.ctx) {\n                    return this.ctx = this.canvas.getContext(\"2d\")\n                }\n                return this.ctx\n            },\n            getSize: function() {\n                if (this.size) {\n                    return this.size\n                }\n                var z = this.canvas;\n                return this.size = {\n                    width: z.width,\n                    height: z.height\n                }\n            },\n            translateToCenter: function(C) {\n                var A = this.getSize(), B = C ? (A.width - C.width - this.translateOffsetX * 2): A.width;\n                height = C ? (A.height - C.height - this.translateOffsetY * 2) : A.height;\n                var z = this.getCtx();\n                C && z.scale(1 / this.scaleOffsetX, 1 / this.scaleOffsetY);\n                z.translate(B / 2, height / 2)\n            },\n            resize: function(C, z) {\n                var B = this.getSize(), A = this.canvas, D = A.style;\n                this.size = false;\n                A.width = C;\n                A.height = z;\n                D.width = C + \"px\";\n                D.height = z + \"px\";\n                if (!y) {\n                    this.translateToCenter(B)\n                } else {\n                    this.translateToCenter()\n                }\n                this.translateOffsetX = this.translateOffsetY = 0;\n                this.scaleOffsetX = this.scaleOffsetY = 1;\n                this.clear();\n                this.viz.resize(C, z, this)\n            },\n            translate: function(z, D, A) {\n                var C = this.scaleOffsetX, B = this.scaleOffsetY;\n                this.translateOffsetX += z * C;\n                this.translateOffsetY += D * B;\n                this.getCtx().translate(z, D);\n                !A && this.plot()\n            },\n            scale: function(z, B, A) {\n                this.scaleOffsetX*=z;\n                this.scaleOffsetY*=B;\n                this.getCtx().scale(z, B);\n                !A && this.plot()\n            },\n            clear: function() {\n                var B = this.getSize(), A = this.translateOffsetX, z = this.translateOffsetY, D = this.scaleOffsetX, C = this.scaleOffsetY;\n                this.getCtx().clearRect(( - B.width / 2 - A) * 1 / D, ( - B.height / 2 - z) * 1 / C, B.width * 1 / D, B.height * 1 / C)\n            },\n            plot: function() {\n                this.clear();\n                this.viz.plot(this)\n            }\n        });\n        l.Background = {};\n        l.Background.Circles = new q({\n            initialize: function(z, A) {\n                this.viz = z;\n                this.config = c.merge({\n                    idSuffix: \"-bkcanvas\",\n                    levelDistance: 100,\n                    numberOfCircles: 6,\n                    CanvasStyles: {},\n                    offset: 0\n                }, A)\n            },\n            resize: function(A, z, B) {\n                this.plot(B)\n            },\n            plot: function(z) {\n                var A = z.canvas, G = z.getCtx(), D = this.config, F = D.CanvasStyles;\n                for (var H in F) {\n                    G[H] = F[H]\n                }\n                var B = D.numberOfCircles, E = D.levelDistance;\n                for (var C = 1; C <= B; C++) {\n                    G.beginPath();\n                    G.arc(0, 0, E * C, 0, 2 * Math.PI, false);\n                    G.stroke();\n                    G.closePath()\n                }\n            }\n        })\n    })();\n    var b = function(x, w) {\n        this.theta = x || 0;\n        this.rho = w || 0\n    };\n    $jit.Polar = b;\n    b.prototype = {\n        getc: function(w) {\n            return this.toComplex(w)\n        },\n        getp: function() {\n            return this\n        },\n        set: function(w) {\n            w = w.getp();\n            this.theta = w.theta;\n            this.rho = w.rho\n        },\n        setc: function(w, z) {\n            this.rho = Math.sqrt(w * w + z * z);\n            this.theta = Math.atan2(z, w);\n            if (this.theta < 0) {\n                this.theta += Math.PI * 2\n            }\n        },\n        setp: function(x, w) {\n            this.theta = x;\n            this.rho = w\n        },\n        clone: function() {\n            return new b(this.theta, this.rho)\n        },\n        toComplex: function(A) {\n            var w = Math.cos(this.theta) * this.rho;\n            var z = Math.sin(this.theta) * this.rho;\n            if (A) {\n                return {\n                    x: w,\n                    y: z\n                }\n            }\n            return new p(w, z)\n        },\n        add: function(w) {\n            return new b(this.theta + w.theta, this.rho + w.rho)\n        },\n        scale: function(w) {\n            return new b(this.theta, this.rho * w)\n        },\n        equals: function(w) {\n            return this.theta == w.theta && this.rho == w.rho\n        },\n        $add: function(w) {\n            this.theta = this.theta + w.theta;\n            this.rho += w.rho;\n            return this\n        },\n        $madd: function(w) {\n            this.theta = (this.theta + w.theta)%(Math.PI * 2);\n            this.rho += w.rho;\n            return this\n        },\n        $scale: function(w) {\n            this.rho*=w;\n            return this\n        },\n        isZero: function() {\n            var x = 0.0001, w = Math.abs;\n            return w(this.theta) < x && w(this.rho) < x\n        },\n        interpolate: function(y, F) {\n            var z = Math.PI, C = z * 2;\n            var x = function(H) {\n                var G = (H < 0) ? (H%C) + C: H%C;\n                return G\n            };\n            var B = this.theta, E = y.theta;\n            var A, D = Math.abs(B - E);\n            if (D == z) {\n                if (B > E) {\n                    A = x((E + ((B - C) - E) * F))\n                } else {\n                    A = x((E - C + (B - (E)) * F))\n                }\n            } else {\n                if (D >= z) {\n                    if (B > E) {\n                        A = x((E + ((B - C) - E) * F))\n                    } else {\n                        A = x((E - C + (B - (E - C)) * F))\n                    }\n                } else {\n                    A = x((E + (B - E) * F))\n                }\n            }\n            var w = (this.rho - y.rho) * F + y.rho;\n            return {\n                theta: A,\n                rho: w\n            }\n        }\n    };\n    var k = function(x, w) {\n        return new b(x, w)\n    };\n    b.KER = k(0, 0);\n    var p = function(w, z) {\n        this.x = w || 0;\n        this.y = z || 0\n    };\n    $jit.Complex = p;\n    p.prototype = {\n        getc: function() {\n            return this\n        },\n        getp: function(w) {\n            return this.toPolar(w)\n        },\n        set: function(w) {\n            w = w.getc(true);\n            this.x = w.x;\n            this.y = w.y\n        },\n        setc: function(w, z) {\n            this.x = w;\n            this.y = z\n        },\n        setp: function(x, w) {\n            this.x = Math.cos(x) * w;\n            this.y = Math.sin(x) * w\n        },\n        clone: function() {\n            return new p(this.x, this.y)\n        },\n        toPolar: function(y) {\n            var w = this.norm();\n            var x = Math.atan2(this.y, this.x);\n            if (x < 0) {\n                x += Math.PI * 2\n            }\n            if (y) {\n                return {\n                    theta: x,\n                    rho: w\n                }\n            }\n            return new b(x, w)\n        },\n        norm: function() {\n            return Math.sqrt(this.squaredNorm())\n        },\n        squaredNorm: function() {\n            return this.x * this.x + this.y * this.y\n        },\n        add: function(w) {\n            return new p(this.x + w.x, this.y + w.y)\n        },\n        prod: function(w) {\n            return new p(this.x * w.x - this.y * w.y, this.y * w.x + this.x * w.y)\n        },\n        conjugate: function() {\n            return new p(this.x, - this.y)\n        },\n        scale: function(w) {\n            return new p(this.x * w, this.y * w)\n        },\n        equals: function(w) {\n            return this.x == w.x && this.y == w.y\n        },\n        $add: function(w) {\n            this.x += w.x;\n            this.y += w.y;\n            return this\n        },\n        $prod: function(A) {\n            var w = this.x, z = this.y;\n            this.x = w * A.x - z * A.y;\n            this.y = z * A.x + w * A.y;\n            return this\n        },\n        $conjugate: function() {\n            this.y =- this.y;\n            return this\n        },\n        $scale: function(w) {\n            this.x*=w;\n            this.y*=w;\n            return this\n        },\n        $div: function(B) {\n            var w = this.x, A = this.y;\n            var z = B.squaredNorm();\n            this.x = w * B.x + A * B.y;\n            this.y = A * B.x - w * B.y;\n            return this.$scale(1 / z)\n        },\n        isZero: function() {\n            var x = 0.0001, w = Math.abs;\n            return w(this.x) < x && w(this.y) < x\n        }\n    };\n    var r = function(x, w) {\n        return new p(x, w)\n    };\n    p.KER = r(0, 0);\n    $jit.Graph = new q({\n        initialize: function(y, x, w, C) {\n            var A = {\n                klass: p,\n                Node: {}\n            };\n            this.Node = x;\n            this.Edge = w;\n            this.Label = C;\n            this.opt = c.merge(A, y || {});\n            this.nodes = {};\n            this.edges = {};\n            var z = this;\n            this.nodeList = {};\n            for (var B in j) {\n                z.nodeList[B] = (function(D) {\n                    return function() {\n                        var E = Array.prototype.slice.call(arguments);\n                        z.eachNode(function(F) {\n                            F[D].apply(F, E)\n                        })\n                    }\n                })(B)\n            }\n        },\n        getNode: function(w) {\n            if (this.hasNode(w)) {\n                return this.nodes[w]\n            }\n            return false\n        },\n        get: function(w) {\n            return this.getNode(w)\n        },\n        getByName: function(w) {\n            for (var y in this.nodes) {\n                var x = this.nodes[y];\n                if (x.name == w) {\n                    return x\n                }\n            }\n            return false\n        },\n        getAdjacence: function(x, w) {\n            if (x in this.edges) {\n                return this.edges[x][w]\n            }\n            return false\n        },\n        addNode: function(x) {\n            if (!this.nodes[x.id]) {\n                var w = this.edges[x.id] = {};\n                this.nodes[x.id] = new e.Node(c.extend({\n                    id: x.id,\n                    name: x.name,\n                    data: c.merge(x.data || {}, {}),\n                    adjacencies: w\n                }, this.opt.Node), this.opt.klass, this.Node, this.Edge, this.Label)\n            }\n            return this.nodes[x.id]\n        },\n        addAdjacence: function(z, y, x) {\n            if (!this.hasNode(z.id)) {\n                this.addNode(z)\n            }\n            if (!this.hasNode(y.id)) {\n                this.addNode(y)\n            }\n            z = this.nodes[z.id];\n            y = this.nodes[y.id];\n            if (!z.adjacentTo(y)) {\n                var A = this.edges[z.id] = this.edges[z.id] || {};\n                var w = this.edges[y.id] = this.edges[y.id] || {};\n                A[y.id] = w[z.id] = new e.Adjacence(z, y, x, this.Edge, this.Label);\n                return A[y.id]\n            }\n            return this.edges[z.id][y.id]\n        },\n        removeNode: function(y) {\n            if (this.hasNode(y)) {\n                delete this.nodes[y];\n                var x = this.edges[y];\n                for (var w in x) {\n                    delete this.edges[w][y]\n                }\n                delete this.edges[y]\n            }\n        },\n        removeAdjacence: function(x, w) {\n            delete this.edges[x][w];\n            delete this.edges[w][x]\n        },\n        hasNode: function(w) {\n            return w in this.nodes\n        },\n        empty: function() {\n            this.nodes = {};\n            this.edges = {}\n        }\n    });\n    var e = $jit.Graph;\n    var j;\n    (function() {\n        var w = function(D, F, A, C, E) {\n            var B;\n            A = A || \"current\";\n            D = \"$\" + (D ? D + \"-\" : \"\");\n            if (A == \"current\") {\n                B = this.data\n            } else {\n                if (A == \"start\") {\n                    B = this.startData\n                } else {\n                    if (A == \"end\") {\n                        B = this.endData\n                    }\n                }\n            }\n            var z = D + F;\n            if (C) {\n                return B[z]\n            }\n            if (!this.Config.overridable) {\n                return E[F] || 0\n            }\n            return (z in B) ? B[z] : ((z in this.data) ? this.data[z] : (E[F] || 0))\n        };\n        var y = function(C, D, B, z) {\n            z = z || \"current\";\n            C = \"$\" + (C ? C + \"-\" : \"\");\n            var A;\n            if (z == \"current\") {\n                A = this.data\n            } else {\n                if (z == \"start\") {\n                    A = this.startData\n                } else {\n                    if (z == \"end\") {\n                        A = this.endData\n                    }\n                }\n            }\n            A[C + D] = B\n        };\n        var x = function(B, z) {\n            B = \"$\" + (B ? B + \"-\" : \"\");\n            var A = this;\n            c.each(z, function(D) {\n                var C = B + D;\n                delete A.data[C];\n                delete A.endData[C];\n                delete A.startData[C]\n            })\n        };\n        j = {\n            getData: function(B, z, A) {\n                return w.call(this, \"\", B, z, A, this.Config)\n            },\n            setData: function(B, A, z) {\n                y.call(this, \"\", B, A, z)\n            },\n            setDataset: function(C, D) {\n                C = c.splat(C);\n                for (var z in D) {\n                    for (var B = 0, E = c.splat(D[z]), A = C.length; B < A; B++) {\n                        this.setData(z, E[B], C[B])\n                    }\n                }\n            },\n            removeData: function() {\n                x.call(this, \"\", Array.prototype.slice.call(arguments))\n            },\n            getCanvasStyle: function(B, z, A) {\n                return w.call(this, \"canvas\", B, z, A, this.Config.CanvasStyles)\n            },\n            setCanvasStyle: function(B, A, z) {\n                y.call(this, \"canvas\", B, A, z)\n            },\n            setCanvasStyles: function(C, D) {\n                C = c.splat(C);\n                for (var z in D) {\n                    for (var B = 0, E = c.splat(D[z]), A = C.length; B < A; B++) {\n                        this.setCanvasStyle(z, E[B], C[B])\n                    }\n                }\n            },\n            removeCanvasStyle: function() {\n                x.call(this, \"canvas\", Array.prototype.slice.call(arguments))\n            },\n            getLabelData: function(B, z, A) {\n                return w.call(this, \"label\", B, z, A, this.Label)\n            },\n            setLabelData: function(B, A, z) {\n                y.call(this, \"label\", B, A, z)\n            },\n            setLabelDataset: function(C, D) {\n                C = c.splat(C);\n                for (var z in D) {\n                    for (var B = 0, E = c.splat(D[z]), A = C.length; B < A; B++) {\n                        this.setLabelData(z, E[B], C[B])\n                    }\n                }\n            },\n            removeLabelData: function() {\n                x.call(this, \"label\", Array.prototype.slice.call(arguments))\n            }\n        }\n    })();\n    e.Node = new q({\n        initialize: function(z, w, y, x, B) {\n            var A = {\n                id: \"\",\n                name: \"\",\n                data: {},\n                startData: {},\n                endData: {},\n                adjacencies: {},\n                selected: false,\n                drawn: false,\n                exist: false,\n                angleSpan: {\n                    begin: 0,\n                    end: 0\n                },\n                pos: new w,\n                startPos: new w,\n                endPos: new w\n            };\n            c.extend(this, c.extend(A, z));\n            this.Config = this.Node = y;\n            this.Edge = x;\n            this.Label = B\n        },\n        adjacentTo: function(w) {\n            return w.id in this.adjacencies\n        },\n        getAdjacency: function(w) {\n            return this.adjacencies[w]\n        },\n        getPos: function(w) {\n            w = w || \"current\";\n            if (w == \"current\") {\n                return this.pos\n            } else {\n                if (w == \"end\") {\n                    return this.endPos\n                } else {\n                    if (w == \"start\") {\n                        return this.startPos\n                    }\n                }\n            }\n        },\n        setPos: function(x, w) {\n            w = w || \"current\";\n            var y;\n            if (w == \"current\") {\n                y = this.pos\n            } else {\n                if (w == \"end\") {\n                    y = this.endPos\n                } else {\n                    if (w == \"start\") {\n                        y = this.startPos\n                    }\n                }\n            }\n            y.set(x)\n        }\n    });\n    e.Node.implement(j);\n    e.Adjacence = new q({\n        initialize: function(x, A, y, w, z) {\n            this.nodeFrom = x;\n            this.nodeTo = A;\n            this.data = y || {};\n            this.startData = {};\n            this.endData = {};\n            this.Config = this.Edge = w;\n            this.Label = z\n        }\n    });\n    e.Adjacence.implement(j);\n    e.Util = {\n        filter: function(x) {\n            if (!x ||!(c.type(x) == \"string\")) {\n                return function() {\n                    return true\n                }\n            }\n            var w = x.split(\" \");\n            return function(z) {\n                for (var y = 0; y < w.length; y++) {\n                    if (z[w[y]]) {\n                        return false\n                    }\n                }\n                return true\n            }\n        },\n        getNode: function(w, x) {\n            return w.nodes[x]\n        },\n        eachNode: function(A, z, w) {\n            var y = this.filter(w);\n            for (var x in A.nodes) {\n                if (y(A.nodes[x])) {\n                    z(A.nodes[x])\n                }\n            }\n        },\n        each: function(y, x, w) {\n            this.eachNode(y, x, w)\n        },\n        eachAdjacency: function(B, C, x) {\n            var y = B.adjacencies, A = this.filter(x);\n            for (var D in y) {\n                var w = y[D];\n                if (A(w)) {\n                    if (w.nodeFrom != B) {\n                        var z = w.nodeFrom;\n                        w.nodeFrom = w.nodeTo;\n                        w.nodeTo = z\n                    }\n                    C(w, D)\n                }\n            }\n        },\n        computeLevels: function(C, D, z, y) {\n            z = z || 0;\n            var A = this.filter(y);\n            this.eachNode(C, function(E) {\n                E._flag = false;\n                E._depth =- 1\n            }, y);\n            var x = C.getNode(D);\n            x._depth = z;\n            var w = [x];\n            while (w.length != 0) {\n                var B = w.pop();\n                B._flag = true;\n                this.eachAdjacency(B, function(E) {\n                    var F = E.nodeTo;\n                    if (F._flag == false && A(F)) {\n                        if (F._depth < 0) {\n                            F._depth = B._depth + 1 + z\n                        }\n                        w.unshift(F)\n                    }\n                }, y)\n            }\n        },\n        eachBFS: function(B, C, A, x) {\n            var y = this.filter(x);\n            this.clean(B);\n            var w = [B.getNode(C)];\n            while (w.length != 0) {\n                var z = w.pop();\n                z._flag = true;\n                A(z, z._depth);\n                this.eachAdjacency(z, function(D) {\n                    var E = D.nodeTo;\n                    if (E._flag == false && y(E)) {\n                        E._flag = true;\n                        w.unshift(E)\n                    }\n                }, x)\n            }\n        },\n        eachLevel: function(A, E, x, B, z) {\n            var D = A._depth, w = this.filter(z), C = this;\n            x = x === false ? Number.MAX_VALUE - D : x;\n            (function y(H, F, G) {\n                var I = H._depth;\n                if (I >= F && I <= G && w(H)) {\n                    B(H, I)\n                }\n                if (I < G) {\n                    C.eachAdjacency(H, function(J) {\n                        var K = J.nodeTo;\n                        if (K._depth > I) {\n                            y(K, F, G)\n                        }\n                    })\n                }\n            })(A, E + D, x + D)\n        },\n        eachSubgraph: function(x, y, w) {\n            this.eachLevel(x, 0, false, y, w)\n        },\n        eachSubnode: function(x, y, w) {\n            this.eachLevel(x, 1, 1, y, w)\n        },\n        anySubnode: function(z, y, x) {\n            var w = false;\n            y = y || c.lambda(true);\n            var A = c.type(y) == \"string\" ? function(B) {\n                return B[y]\n            }\n            : y;\n            this.eachSubnode(z, function(B) {\n                if (A(B)) {\n                    w = true\n                }\n            }, x);\n            return w\n        },\n        getSubnodes: function(B, C, w) {\n            var y = [], A = this;\n            C = C || 0;\n            var z, x;\n            if (c.type(C) == \"array\") {\n                z = C[0];\n                x = C[1]\n            } else {\n                z = C;\n                x = Number.MAX_VALUE - B._depth\n            }\n            this.eachLevel(B, z, x, function(D) {\n                y.push(D)\n            }, w);\n            return y\n        },\n        getParents: function(x) {\n            var w = [];\n            this.eachAdjacency(x, function(y) {\n                var z = y.nodeTo;\n                if (z._depth < x._depth) {\n                    w.push(z)\n                }\n            });\n            return w\n        },\n        isDescendantOf: function(z, A) {\n            if (z.id == A) {\n                return true\n            }\n            var y = this.getParents(z), w = false;\n            for (var x = 0; !w && x < y.length; x++) {\n                w = w || this.isDescendantOf(y[x], A)\n            }\n            return w\n        },\n        clean: function(w) {\n            this.eachNode(w, function(x) {\n                x._flag = false\n            })\n        },\n        getClosestNodeToOrigin: function(x, y, w) {\n            return this.getClosestNodeToPos(x, b.KER, y, w)\n        },\n        getClosestNodeToPos: function(y, B, A, w) {\n            var x = null;\n            A = A || \"current\";\n            B = B && B.getc(true) || p.KER;\n            var z = function(D, C) {\n                var F = D.x - C.x, E = D.y - C.y;\n                return F * F + E * E\n            };\n            this.eachNode(y, function(C) {\n                x = (x == null || z(C.getPos(A).getc(true), B) < z(x.getPos(A).getc(true), B)) ? C : x\n            }, w);\n            return x\n        }\n    };\n    c.each([\"get\", \"getNode\", \"each\", \"eachNode\", \"computeLevels\", \"eachBFS\", \"clean\", \"getClosestNodeToPos\", \"getClosestNodeToOrigin\"], function(w) {\n        e.prototype[w] = function() {\n            return e.Util[w].apply(e.Util, [this].concat(Array.prototype.slice.call(arguments)))\n        }\n    });\n    c.each([\"eachAdjacency\", \"eachLevel\", \"eachSubgraph\", \"eachSubnode\", \"anySubnode\", \"getSubnodes\", \"getParents\", \"isDescendantOf\"], function(w) {\n        e.Node.prototype[w] = function() {\n            return e.Util[w].apply(e.Util, [this].concat(Array.prototype.slice.call(arguments)))\n        }\n    });\n    e.Op = {\n        options: {\n            type: \"nothing\",\n            duration: 2000,\n            hideLabels: true,\n            fps: 30\n        },\n        initialize: function(w) {\n            this.viz = w\n        },\n        removeNode: function(B, z) {\n            var w = this.viz;\n            var x = c.merge(this.options, w.controller, z);\n            var D = c.splat(B);\n            var y, A, C;\n            switch (x.type) {\n            case\"nothing\":\n                for (y = 0; y < D.length; y++) {\n                    w.graph.removeNode(D[y])\n                }\n                break;\n            case\"replot\":\n                this.removeNode(D, {\n                    type: \"nothing\"\n                });\n                w.labels.clearLabels();\n                w.refresh(true);\n                break;\n            case\"fade:seq\":\n            case\"fade\":\n                A = this;\n                for (y = 0; y < D.length; y++) {\n                    C = w.graph.getNode(D[y]);\n                    C.setData(\"alpha\", 0, \"end\")\n                }\n                w.fx.animate(c.merge(x, {\n                    modes: [\"node-property:alpha\"],\n                    onComplete: function() {\n                        A.removeNode(D, {\n                            type: \"nothing\"\n                        });\n                        w.labels.clearLabels();\n                        w.reposition();\n                        w.fx.animate(c.merge(x, {\n                            modes: [\"linear\"]\n                        }))\n                    }\n                }));\n                break;\n            case\"fade:con\":\n                A = this;\n                for (y = 0; y < D.length; y++) {\n                    C = w.graph.getNode(D[y]);\n                    C.setData(\"alpha\", 0, \"end\");\n                    C.ignore = true\n                }\n                w.reposition();\n                w.fx.animate(c.merge(x, {\n                    modes: [\"node-property:alpha\", \"linear\"],\n                    onComplete: function() {\n                        A.removeNode(D, {\n                            type: \"nothing\"\n                        });\n                        x.onComplete && x.onComplete()\n                    }\n                }));\n                break;\n            case\"iter\":\n                A = this;\n                w.fx.sequence({\n                    condition: function() {\n                        return D.length != 0\n                    },\n                    step: function() {\n                        A.removeNode(D.shift(), {\n                            type: \"nothing\"\n                        });\n                        w.labels.clearLabels()\n                    },\n                    onComplete: function() {\n                        x.onComplete && x.onComplete()\n                    },\n                    duration: Math.ceil(x.duration / D.length)\n                });\n                break;\n            default:\n                this.doError()\n            }\n        },\n        removeEdge: function(D, B) {\n            var w = this.viz;\n            var z = c.merge(this.options, w.controller, B);\n            var y = (c.type(D[0]) == \"string\") ? [D]: D;\n            var A, C, x;\n            switch (z.type) {\n            case\"nothing\":\n                for (A = 0; A < y.length; A++) {\n                    w.graph.removeAdjacence(y[A][0], y[A][1])\n                }\n                break;\n            case\"replot\":\n                this.removeEdge(y, {\n                    type: \"nothing\"\n                });\n                w.refresh(true);\n                break;\n            case\"fade:seq\":\n            case\"fade\":\n                C = this;\n                for (A = 0; A < y.length; A++) {\n                    x = w.graph.getAdjacence(y[A][0], y[A][1]);\n                    if (x) {\n                        x.setData(\"alpha\", 0, \"end\")\n                    }\n                }\n                w.fx.animate(c.merge(z, {\n                    modes: [\"edge-property:alpha\"],\n                    onComplete: function() {\n                        C.removeEdge(y, {\n                            type: \"nothing\"\n                        });\n                        w.reposition();\n                        w.fx.animate(c.merge(z, {\n                            modes: [\"linear\"]\n                        }))\n                    }\n                }));\n                break;\n            case\"fade:con\":\n                C = this;\n                for (A = 0; A < y.length; A++) {\n                    x = w.graph.getAdjacence(y[A][0], y[A][1]);\n                    if (x) {\n                        x.setData(\"alpha\", 0, \"end\");\n                        x.ignore = true\n                    }\n                }\n                w.reposition();\n                w.fx.animate(c.merge(z, {\n                    modes: [\"edge-property:alpha\", \"linear\"],\n                    onComplete: function() {\n                        C.removeEdge(y, {\n                            type: \"nothing\"\n                        });\n                        z.onComplete && z.onComplete()\n                    }\n                }));\n                break;\n            case\"iter\":\n                C = this;\n                w.fx.sequence({\n                    condition: function() {\n                        return y.length != 0\n                    },\n                    step: function() {\n                        C.removeEdge(y.shift(), {\n                            type: \"nothing\"\n                        });\n                        w.labels.clearLabels()\n                    },\n                    onComplete: function() {\n                        z.onComplete()\n                    },\n                    duration: Math.ceil(z.duration / y.length)\n                });\n                break;\n            default:\n                this.doError()\n            }\n        },\n        sum: function(A, z) {\n            var w = this.viz;\n            var y = c.merge(this.options, w.controller, z), x = w.root;\n            var C;\n            w.root = z.id || w.root;\n            switch (y.type) {\n            case\"nothing\":\n                C = w.construct(A);\n                C.eachNode(function(E) {\n                    E.eachAdjacency(function(F) {\n                        w.graph.addAdjacence(F.nodeFrom, F.nodeTo, F.data)\n                    })\n                });\n                break;\n            case\"replot\":\n                w.refresh(true);\n                this.sum(A, {\n                    type: \"nothing\"\n                });\n                w.refresh(true);\n                break;\n            case\"fade:seq\":\n            case\"fade\":\n            case\"fade:con\":\n                that = this;\n                C = w.construct(A);\n                var D = this.preprocessSum(C);\n                var B=!D ? [\"node-property:alpha\"] : [\"node-property:alpha\", \"edge-property:alpha\"];\n                w.reposition();\n                if (y.type != \"fade:con\") {\n                    w.fx.animate(c.merge(y, {\n                        modes: [\"linear\"],\n                        onComplete: function() {\n                            w.fx.animate(c.merge(y, {\n                                modes: B,\n                                onComplete: function() {\n                                    y.onComplete()\n                                }\n                            }))\n                        }\n                    }))\n                } else {\n                    w.graph.eachNode(function(E) {\n                        if (E.id != x && E.pos.isZero()) {\n                            E.pos.set(E.endPos);\n                            E.startPos.set(E.endPos)\n                        }\n                    });\n                    w.fx.animate(c.merge(y, {\n                        modes: [\"linear\"].concat(B)\n                    }))\n                }\n                break;\n            default:\n                this.doError()\n            }\n        },\n        morph: function(E, x, z) {\n            z = z || {};\n            var B = this.viz;\n            var F = c.merge(this.options, B.controller, x), A = B.root;\n            var C;\n            B.root = x.id || B.root;\n            switch (F.type) {\n            case\"nothing\":\n                C = B.construct(E);\n                C.eachNode(function(I) {\n                    var H = B.graph.hasNode(I.id);\n                    I.eachAdjacency(function(M) {\n                        var L=!!B.graph.getAdjacence(M.nodeFrom.id, M.nodeTo.id);\n                        B.graph.addAdjacence(M.nodeFrom, M.nodeTo, M.data);\n                        if (L) {\n                            var K = B.graph.getAdjacence(M.nodeFrom.id, M.nodeTo.id);\n                            for (var N in (M.data || {})) {\n                                K.data[N] = M.data[N]\n                            }\n                        }\n                    });\n                    if (H) {\n                        var G = B.graph.getNode(I.id);\n                        for (var J in (I.data || {})) {\n                            G.data[J] = I.data[J]\n                        }\n                    }\n                });\n                B.graph.eachNode(function(G) {\n                    G.eachAdjacency(function(H) {\n                        if (!C.getAdjacence(H.nodeFrom.id, H.nodeTo.id)) {\n                            B.graph.removeAdjacence(H.nodeFrom.id, H.nodeTo.id)\n                        }\n                    });\n                    if (!C.hasNode(G.id)) {\n                        B.graph.removeNode(G.id)\n                    }\n                });\n                break;\n            case\"replot\":\n                B.labels.clearLabels(true);\n                this.morph(E, {\n                    type: \"nothing\"\n                });\n                B.refresh(true);\n                B.refresh(true);\n                break;\n            case\"fade:seq\":\n            case\"fade\":\n            case\"fade:con\":\n                that = this;\n                C = B.construct(E);\n                var D = (\"node-property\" in z) && c.map(c.splat(z[\"node-property\"]), function(G) {\n                    return \"$\" + G\n                });\n                B.graph.eachNode(function(H) {\n                    var I = C.getNode(H.id);\n                    if (!I) {\n                        H.setData(\"alpha\", 1);\n                        H.setData(\"alpha\", 1, \"start\");\n                        H.setData(\"alpha\", 0, \"end\");\n                        H.ignore = true\n                    } else {\n                        var G = I.data;\n                        for (var J in G) {\n                            if (D && (c.indexOf(D, J)>-1)) {\n                                H.endData[J] = G[J]\n                            } else {\n                                H.data[J] = G[J]\n                            }\n                        }\n                    }\n                });\n                B.graph.eachNode(function(G) {\n                    if (G.ignore) {\n                        return \n                    }\n                    G.eachAdjacency(function(H) {\n                        if (H.nodeFrom.ignore || H.nodeTo.ignore) {\n                            return \n                        }\n                        var I = C.getNode(H.nodeFrom.id);\n                        var J = C.getNode(H.nodeTo.id);\n                        if (!I.adjacentTo(J)) {\n                            var H = B.graph.getAdjacence(I.id, J.id);\n                            w = true;\n                            H.setData(\"alpha\", 1);\n                            H.setData(\"alpha\", 1, \"start\");\n                            H.setData(\"alpha\", 0, \"end\")\n                        }\n                    })\n                });\n                var w = this.preprocessSum(C);\n                var y=!w ? [\"node-property:alpha\"] : [\"node-property:alpha\", \"edge-property:alpha\"];\n                y[0] = y[0] + ((\"node-property\" in z) ? (\":\" + c.splat(z[\"node-property\"]).join(\":\")) : \"\");\n                y[1] = (y[1] || \"edge-property:alpha\") + ((\"edge-property\" in z) ? (\":\" + c.splat(z[\"edge-property\"]).join(\":\")) : \"\");\n                if (\"label-property\" in z) {\n                    y.push(\"label-property:\" + c.splat(z[\"label-property\"]).join(\":\"))\n                }\n                if (B.reposition) {\n                    B.reposition()\n                } else {\n                    B.compute(\"end\")\n                }\n                B.graph.eachNode(function(G) {\n                    if (G.id != A && G.pos.getp().equals(b.KER)) {\n                        G.pos.set(G.endPos);\n                        G.startPos.set(G.endPos)\n                    }\n                });\n                B.fx.animate(c.merge(F, {\n                    modes: [z.position || \"polar\"].concat(y),\n                    onComplete: function() {\n                        B.graph.eachNode(function(G) {\n                            if (G.ignore) {\n                                B.graph.removeNode(G.id)\n                            }\n                        });\n                        B.graph.eachNode(function(G) {\n                            G.eachAdjacency(function(H) {\n                                if (H.ignore) {\n                                    B.graph.removeAdjacence(H.nodeFrom.id, H.nodeTo.id)\n                                }\n                            })\n                        });\n                        F.onComplete()\n                    }\n                }));\n                break;\n            default:\n            }\n        },\n        contract: function(y, x) {\n            var w = this.viz;\n            if (y.collapsed ||!y.anySubnode(c.lambda(true))) {\n                return \n            }\n            x = c.merge(this.options, w.config, x || {}, {\n                modes: [\"node-property:alpha:span\", \"linear\"]\n            });\n            y.collapsed = true;\n            (function z(A) {\n                A.eachSubnode(function(B) {\n                    B.ignore = true;\n                    B.setData(\"alpha\", 0, x.type == \"animate\" ? \"end\" : \"current\");\n                    z(B)\n                })\n            })(y);\n            if (x.type == \"animate\") {\n                w.compute(\"end\");\n                if (w.rotated) {\n                    w.rotate(w.rotated, \"none\", {\n                        property: \"end\"\n                    })\n                }(function z(A) {\n                    A.eachSubnode(function(B) {\n                        B.setPos(y.getPos(\"end\"), \"end\");\n                        z(B)\n                    })\n                })(y);\n                w.fx.animate(x)\n            } else {\n                if (x.type == \"replot\") {\n                    w.refresh()\n                }\n            }\n        },\n        expand: function(y, x) {\n            if (!(\"collapsed\" in y)) {\n                return \n            }\n            var w = this.viz;\n            x = c.merge(this.options, w.config, x || {}, {\n                modes: [\"node-property:alpha:span\", \"linear\"]\n            });\n            delete y.collapsed;\n            (function z(A) {\n                A.eachSubnode(function(B) {\n                    delete B.ignore;\n                    B.setData(\"alpha\", 1, x.type == \"animate\" ? \"end\" : \"current\");\n                    z(B)\n                })\n            })(y);\n            if (x.type == \"animate\") {\n                w.compute(\"end\");\n                if (w.rotated) {\n                    w.rotate(w.rotated, \"none\", {\n                        property: \"end\"\n                    })\n                }\n                w.fx.animate(x)\n            } else {\n                if (x.type == \"replot\") {\n                    w.refresh()\n                }\n            }\n        },\n        preprocessSum: function(x) {\n            var w = this.viz;\n            x.eachNode(function(z) {\n                if (!w.graph.hasNode(z.id)) {\n                    w.graph.addNode(z);\n                    var A = w.graph.getNode(z.id);\n                    A.setData(\"alpha\", 0);\n                    A.setData(\"alpha\", 0, \"start\");\n                    A.setData(\"alpha\", 1, \"end\")\n                }\n            });\n            var y = false;\n            x.eachNode(function(z) {\n                z.eachAdjacency(function(A) {\n                    var B = w.graph.getNode(A.nodeFrom.id);\n                    var C = w.graph.getNode(A.nodeTo.id);\n                    if (!B.adjacentTo(C)) {\n                        var A = w.graph.addAdjacence(B, C, A.data);\n                        if (B.startAlpha == B.endAlpha && C.startAlpha == C.endAlpha) {\n                            y = true;\n                            A.setData(\"alpha\", 0);\n                            A.setData(\"alpha\", 0, \"start\");\n                            A.setData(\"alpha\", 1, \"end\")\n                        }\n                    }\n                })\n            });\n            return y\n        }\n    };\n    var a = {\n        none: {\n            render: c.empty,\n            contains: c.lambda(false)\n        },\n        circle: {\n            render: function(z, A, w, y) {\n                var x = y.getCtx();\n                x.beginPath();\n                x.arc(A.x, A.y, w, 0, Math.PI * 2, true);\n                x.closePath();\n                x[z]()\n            },\n            contains: function(B, A, w) {\n                var y = B.x - A.x, x = B.y - A.y, z = y * y + x * x;\n                return z <= w * w\n            }\n        },\n        ellipse: {\n            render: function(C, E, w, F, x) {\n                var G = x.getCtx(), z = 1, y = 1, D = 1, B = 1, A = 0;\n                if (w > F) {\n                    A = w / 2;\n                    y = F / w;\n                    B = w / F\n                } else {\n                    A = F / 2;\n                    z = w / F;\n                    D = F / w\n                }\n                G.save();\n                G.scale(z, y);\n                G.beginPath();\n                G.arc(E.x * D, E.y * B, A, 0, Math.PI * 2, true);\n                G.closePath();\n                G[C]();\n                G.restore()\n            },\n            contains: function(w, D, x, F) {\n                var C = 0, B = 1, A = 1, z = 0, y = 0, E = 0;\n                if (x > F) {\n                    C = x / 2;\n                    A = F / x\n                } else {\n                    C = F / 2;\n                    B = x / F\n                }\n                z = (w.x - D.x) * (1 / B);\n                y = (w.y - D.y) * (1 / A);\n                E = z * z + y * y;\n                return E <= C * C\n            }\n        },\n        square: {\n            render: function(x, z, y, w) {\n                w.getCtx()[x + \"Rect\"](z.x - y, z.y - y, 2 * y, 2 * y)\n            },\n            contains: function(y, x, w) {\n                return Math.abs(x.x - y.x) <= w && Math.abs(x.y - y.y) <= w\n            }\n        },\n        rectangle: {\n            render: function(z, A, y, w, x) {\n                x.getCtx()[z + \"Rect\"](A.x - y / 2, A.y - w / 2, y, w)\n            },\n            contains: function(z, y, x, w) {\n                return Math.abs(y.x - z.x) <= x / 2 && Math.abs(y.y - z.y) <= w / 2\n            }\n        },\n        triangle: {\n            render: function(C, D, z, w) {\n                var G = w.getCtx(), y = D.x, x = D.y - z, F = y - z, E = D.y + z, B = y + z, A = E;\n                G.beginPath();\n                G.moveTo(y, x);\n                G.lineTo(F, E);\n                G.lineTo(B, A);\n                G.closePath();\n                G[C]()\n            },\n            contains: function(y, x, w) {\n                return a.circle.contains(y, x, w)\n            }\n        },\n        star: {\n            render: function(A, C, B, x) {\n                var w = x.getCtx(), z = Math.PI / 5;\n                w.save();\n                w.translate(C.x, C.y);\n                w.beginPath();\n                w.moveTo(B, 0);\n                for (var y = 0; y < 9; y++) {\n                    w.rotate(z);\n                    if (y%2 == 0) {\n                        w.lineTo((B / 0.525731) * 0.200811, 0)\n                    } else {\n                        w.lineTo(B, 0)\n                    }\n                }\n                w.closePath();\n                w[A]();\n                w.restore()\n            },\n            contains: function(y, x, w) {\n                return a.circle.contains(y, x, w)\n            }\n        }\n    };\n    var m = {\n        line: {\n            render: function(z, y, x) {\n                var w = x.getCtx();\n                w.beginPath();\n                w.moveTo(z.x, z.y);\n                w.lineTo(y.x, y.y);\n                w.stroke()\n            },\n            contains: function(G, y, B, E) {\n                var z = Math.min, C = Math.max, x = z(G.x, y.x), F = C(G.x, y.x), w = z(G.y, y.y), D = C(G.y, y.y);\n                if (B.x >= x && B.x <= F && B.y >= w && B.y <= D) {\n                    if (Math.abs(y.x - G.x) <= E) {\n                        return true\n                    }\n                    var A = (y.y - G.y) / (y.x - G.x) * (B.x - G.x) + G.y;\n                    return Math.abs(A - B.y) <= E\n                }\n                return false\n            }\n        },\n        arrow: {\n            render: function(F, G, z, x, w) {\n                var H = w.getCtx();\n                if (x) {\n                    var y = F;\n                    F = G;\n                    G = y\n                }\n                var C = new p(G.x - F.x, G.y - F.y);\n                C.$scale(z / C.norm());\n                var A = new p(G.x - C.x, G.y - C.y), B = new p( - C.y / 2, C.x / 2), E = A.add(B), D = A.$add(B.$scale(-1));\n                H.beginPath();\n                H.moveTo(F.x, F.y);\n                H.lineTo(G.x, G.y);\n                H.stroke();\n                H.beginPath();\n                H.moveTo(E.x, E.y);\n                H.lineTo(D.x, D.y);\n                H.lineTo(G.x, G.y);\n                H.closePath();\n                H.fill()\n            },\n            contains: function(x, w, z, y) {\n                return m.line.contains(x, w, z, y)\n            }\n        },\n        hyperline: {\n            render: function(D, E, w, y) {\n                var F = y.getCtx();\n                var z = A(D, E);\n                if (z.a > 1000 || z.b > 1000 || z.ratio < 0) {\n                    F.beginPath();\n                    F.moveTo(D.x * w, D.y * w);\n                    F.lineTo(E.x * w, E.y * w);\n                    F.stroke()\n                } else {\n                    var C = Math.atan2(E.y - z.y, E.x - z.x);\n                    var B = Math.atan2(D.y - z.y, D.x - z.x);\n                    var x = x(C, B);\n                    F.beginPath();\n                    F.arc(z.x * w, z.y * w, z.ratio * w, C, B, x);\n                    F.stroke()\n                }\n                function A(S, R) {\n                    var K = (S.x * R.y - S.y * R.x), G = K;\n                    var J = S.squaredNorm(), I = R.squaredNorm();\n                    if (K == 0) {\n                        return {\n                            x: 0,\n                            y: 0,\n                            ratio: -1\n                        }\n                    }\n                    var Q = (S.y * I - R.y * J + S.y - R.y) / K;\n                    var O = (R.x * J - S.x * I + R.x - S.x) / G;\n                    var P =- Q / 2;\n                    var N =- O / 2;\n                    var M = (Q * Q + O * O) / 4-1;\n                    if (M < 0) {\n                        return {\n                            x: 0,\n                            y: 0,\n                            ratio: -1\n                        }\n                    }\n                    var L = Math.sqrt(M);\n                    var H = {\n                        x: P,\n                        y: N,\n                        ratio: L > 1000?-1: L,\n                        a: Q,\n                        b: O\n                    };\n                    return H\n                }\n                function x(G, H) {\n                    return (G < H) ? ((G + Math.PI > H) ? false : true) : ((H + Math.PI > G) ? true : false)\n                }\n            },\n            contains: c.lambda(false)\n        }\n    };\n    e.Plot = {\n        initialize: function(x, w) {\n            this.viz = x;\n            this.config = x.config;\n            this.node = x.config.Node;\n            this.edge = x.config.Edge;\n            this.animation = new u;\n            this.nodeTypes = new w.Plot.NodeTypes;\n            this.edgeTypes = new w.Plot.EdgeTypes;\n            this.labels = x.labels\n        },\n        nodeHelper: a,\n        edgeHelper: m,\n        Interpolator: {\n            map: {\n                border: \"color\",\n                color: \"color\",\n                width: \"number\",\n                height: \"number\",\n                dim: \"number\",\n                alpha: \"number\",\n                lineWidth: \"number\",\n                angularWidth: \"number\",\n                span: \"number\",\n                valueArray: \"array-number\",\n                dimArray: \"array-number\"\n            },\n            canvas: {\n                globalAlpha: \"number\",\n                fillStyle: \"color\",\n                strokeStyle: \"color\",\n                lineWidth: \"number\",\n                shadowBlur: \"number\",\n                shadowColor: \"color\",\n                shadowOffsetX: \"number\",\n                shadowOffsetY: \"number\",\n                miterLimit: \"number\"\n            },\n            label: {\n                size: \"number\",\n                color: \"color\"\n            },\n            compute: function(y, x, w) {\n                return y + (x - y) * w\n            },\n            moebius: function(D, C, F, z) {\n                var B = z.scale( - F);\n                if (B.norm() < 1) {\n                    var w = B.x, E = B.y;\n                    var A = D.startPos.getc().moebiusTransformation(B);\n                    D.pos.setc(A.x, A.y);\n                    B.x = w;\n                    B.y = E\n                }\n            },\n            linear: function(x, w, A) {\n                var z = x.startPos.getc(true);\n                var y = x.endPos.getc(true);\n                x.pos.setc(this.compute(z.x, y.x, A), this.compute(z.y, y.y, A))\n            },\n            polar: function(y, x, B) {\n                var A = y.startPos.getp(true);\n                var z = y.endPos.getp();\n                var w = z.interpolate(A, B);\n                y.pos.setp(w.theta, w.rho)\n            },\n            number: function(x, C, B, w, A) {\n                var z = x[w](C, \"start\");\n                var y = x[w](C, \"end\");\n                x[A](C, this.compute(z, y, B))\n            },\n            color: function(y, w, E, B, z) {\n                var C = c.hexToRgb(y[B](w, \"start\"));\n                var D = c.hexToRgb(y[B](w, \"end\"));\n                var A = this.compute;\n                var x = c.rgbToHex([parseInt(A(C[0], D[0], E)), parseInt(A(C[1], D[1], E)), parseInt(A(C[2], D[2], E))]);\n                y[z](w, x)\n            },\n            \"array-number\": function(z, y, J, G, B) {\n                var H = z[G](y, \"start\"), I = z[G](y, \"end\"), K = [];\n                for (var E = 0, A = H.length; E < A; E++) {\n                    var x = H[E], w = I[E];\n                    if (x.length) {\n                        for (var D = 0, F = x.length, C = []; D < F; D++) {\n                            C.push(this.compute(x[D], w[D], J))\n                        }\n                        K.push(C)\n                    } else {\n                        K.push(this.compute(x, w, J))\n                    }\n                }\n                z[B](y, K)\n            },\n            node: function(x, C, E, w, D, y) {\n                w = this[w];\n                if (C) {\n                    var B = C.length;\n                    for (var z = 0; z < B; z++) {\n                        var A = C[z];\n                        this[w[A]](x, A, E, D, y)\n                    }\n                } else {\n                    for (var A in w) {\n                        this[w[A]](x, A, E, D, y)\n                    }\n                }\n            },\n            edge: function(y, x, D, z, w, C) {\n                var B = y.adjacencies;\n                for (var A in B) {\n                    this[\"node\"](B[A], x, D, z, w, C)\n                }\n            },\n            \"node-property\": function(x, w, y) {\n                this[\"node\"](x, w, y, \"map\", \"getData\", \"setData\")\n            },\n            \"edge-property\": function(x, w, y) {\n                this[\"edge\"](x, w, y, \"map\", \"getData\", \"setData\")\n            },\n            \"label-property\": function(x, w, y) {\n                this[\"node\"](x, w, y, \"label\", \"getLabelData\", \"setLabelData\")\n            },\n            \"node-style\": function(x, w, y) {\n                this[\"node\"](x, w, y, \"canvas\", \"getCanvasStyle\", \"setCanvasStyle\")\n            },\n            \"edge-style\": function(x, w, y) {\n                this[\"edge\"](x, w, y, \"canvas\", \"getCanvasStyle\", \"setCanvasStyle\")\n            }\n        },\n        sequence: function(x) {\n            var y = this;\n            x = c.merge({\n                condition: c.lambda(false),\n                step: c.empty,\n                onComplete: c.empty,\n                duration: 200\n            }, x || {});\n            var w = setInterval(function() {\n                if (x.condition()) {\n                    x.step()\n                } else {\n                    clearInterval(w);\n                    x.onComplete()\n                }\n                y.viz.refresh(true)\n            }, x.duration)\n        },\n        prepare: function(C) {\n            var B = this.viz.graph, z = {\n                \"node-property\": {\n                    getter: \"getData\",\n                    setter: \"setData\"\n                },\n                \"edge-property\": {\n                    getter: \"getData\",\n                    setter: \"setData\"\n                },\n                \"node-style\": {\n                    getter: \"getCanvasStyle\",\n                    setter: \"setCanvasStyle\"\n                },\n                \"edge-style\": {\n                    getter: \"getCanvasStyle\",\n                    setter: \"setCanvasStyle\"\n                }\n            };\n            var x = {};\n            if (c.type(C) == \"array\") {\n                for (var A = 0, w = C.length; A < w; A++) {\n                    var y = C[A].split(\":\");\n                    x[y.shift()] = y\n                }\n            } else {\n                for (var D in C) {\n                    if (D == \"position\") {\n                        x[C.position] = []\n                    } else {\n                        x[D] = c.splat(C[D])\n                    }\n                }\n            }\n            B.eachNode(function(E) {\n                E.startPos.set(E.pos);\n                c.each([\"node-property\", \"node-style\"], function(H) {\n                    if (H in x) {\n                        var I = x[H];\n                        for (var G = 0, F = I.length; G < F; G++) {\n                            E[z[H].setter](I[G], E[z[H].getter](I[G]), \"start\")\n                        }\n                    }\n                });\n                c.each([\"edge-property\", \"edge-style\"], function(F) {\n                    if (F in x) {\n                        var G = x[F];\n                        E.eachAdjacency(function(I) {\n                            for (var J = 0, H = G.length; J < H; J++) {\n                                I[z[F].setter](G[J], I[z[F].getter](G[J]), \"start\")\n                            }\n                        })\n                    }\n                })\n            });\n            return x\n        },\n        animate: function(z, y) {\n            z = c.merge(this.viz.config, z || {});\n            var A = this, x = this.viz, C = x.graph, D = this.Interpolator, B = z.type === \"nodefx\" ? this.nodeFxAnimation: this.animation;\n            var w = this.prepare(z.modes);\n            if (z.hideLabels) {\n                this.labels.hideLabels(true)\n            }\n            B.setOptions(c.extend(z, {\n                $animating: false,\n                compute: function(E) {\n                    C.eachNode(function(F) {\n                        for (var G in w) {\n                            D[G](F, w[G], E, y)\n                        }\n                    });\n                    A.plot(z, this.$animating, E);\n                    this.$animating = true\n                },\n                complete: function() {\n                    if (z.hideLabels) {\n                        A.labels.hideLabels(false)\n                    }\n                    A.plot(z);\n                    z.onComplete()\n                }\n            })).start()\n        },\n        nodeFx: function(y) {\n            var D = this.viz, E = D.graph, B = this.nodeFxAnimation, F = c.merge(this.viz.config, {\n                elements: {\n                    id: false,\n                    properties: {}\n                },\n                reposition: false\n            });\n            y = c.merge(F, y || {}, {\n                onBeforeCompute: c.empty,\n                onAfterCompute: c.empty\n            });\n            B.stopTimer();\n            var C = y.elements.properties;\n            if (!y.elements.id) {\n                E.eachNode(function(H) {\n                    for (var G in C) {\n                        H.setData(G, C[G], \"end\")\n                    }\n                })\n            } else {\n                var w = c.splat(y.elements.id);\n                c.each(w, function(I) {\n                    var H = E.getNode(I);\n                    if (H) {\n                        for (var G in C) {\n                            H.setData(G, C[G], \"end\")\n                        }\n                    }\n                })\n            }\n            var A = [];\n            for (var x in C) {\n                A.push(x)\n            }\n            var z = [\"node-property:\" + A.join(\":\")];\n            if (y.reposition) {\n                z.push(\"linear\");\n                D.compute(\"end\")\n            }\n            this.animate(c.merge(y, {\n                modes: z,\n                type: \"nodefx\"\n            }))\n        },\n        plot: function(x, G) {\n            var E = this.viz, B = E.graph, y = E.canvas, w = E.root, C = this, F = y.getCtx(), A = Math.min, x = x || this.viz.controller;\n            x.clearCanvas && y.clear();\n            var D = B.getNode(w);\n            if (!D) {\n                return \n            }\n            var z=!!D.visited;\n            B.eachNode(function(I) {\n                var H = I.getData(\"alpha\");\n                I.eachAdjacency(function(J) {\n                    var K = J.nodeTo;\n                    if (!!K.visited === z && I.drawn && K.drawn) {\n                        !G && x.onBeforePlotLine(J);\n                        C.plotLine(J, y, G);\n                        !G && x.onAfterPlotLine(J)\n                    }\n                });\n                if (I.drawn) {\n                    !G && x.onBeforePlotNode(I);\n                    C.plotNode(I, y, G);\n                    !G && x.onAfterPlotNode(I)\n                }\n                if (!C.labelsHidden && x.withLabels) {\n                    if (I.drawn && H >= 0.95) {\n                        C.labels.plotLabel(y, I, x)\n                    } else {\n                        C.labels.hideLabel(I, false)\n                    }\n                }\n                I.visited=!z\n            })\n        },\n        plotTree: function(A, x, E) {\n            var B = this, C = this.viz, y = C.canvas, z = this.config, D = y.getCtx();\n            var w = A.getData(\"alpha\");\n            A.eachSubnode(function(G) {\n                if (x.plotSubtree(A, G) && G.exist && G.drawn) {\n                    var F = A.getAdjacency(G.id);\n                    !E && x.onBeforePlotLine(F);\n                    B.plotLine(F, y, E);\n                    !E && x.onAfterPlotLine(F);\n                    B.plotTree(G, x, E)\n                }\n            });\n            if (A.drawn) {\n                !E && x.onBeforePlotNode(A);\n                this.plotNode(A, y, E);\n                !E && x.onAfterPlotNode(A);\n                if (!x.hideLabels && x.withLabels && w >= 0.95) {\n                    this.labels.plotLabel(y, A, x)\n                } else {\n                    this.labels.hideLabel(A, false)\n                }\n            } else {\n                this.labels.hideLabel(A, true)\n            }\n        },\n        plotNode: function(y, x, F) {\n            var C = y.getData(\"type\"), B = this.node.CanvasStyles;\n            if (C != \"none\") {\n                var w = y.getData(\"lineWidth\"), A = y.getData(\"color\"), z = y.getData(\"alpha\"), D = x.getCtx();\n                D.save();\n                D.lineWidth = w;\n                D.fillStyle = D.strokeStyle = A;\n                D.globalAlpha = z;\n                for (var E in B) {\n                    D[E] = y.getCanvasStyle(E)\n                }\n                this.nodeTypes[C].render.call(this, y, x, F);\n                D.restore()\n            }\n        },\n        plotLine: function(C, x, G) {\n            var B = C.getData(\"type\"), z = this.edge.CanvasStyles;\n            if (B != \"none\") {\n                var w = C.getData(\"lineWidth\"), y = C.getData(\"color\"), E = x.getCtx(), A = C.nodeFrom, D = C.nodeTo;\n                E.save();\n                E.lineWidth = w;\n                E.fillStyle = E.strokeStyle = y;\n                E.globalAlpha = Math.min(A.getData(\"alpha\"), D.getData(\"alpha\"), C.getData(\"alpha\"));\n                for (var F in z) {\n                    E[F] = C.getCanvasStyle(F)\n                }\n                this.edgeTypes[B].render.call(this, C, x, G);\n                E.restore()\n            }\n        }\n    };\n    e.Plot3D = c.merge(e.Plot, {\n        Interpolator: {\n            linear: function(x, w, A) {\n                var z = x.startPos.getc(true);\n                var y = x.endPos.getc(true);\n                x.pos.setc(this.compute(z.x, y.x, A), this.compute(z.y, y.y, A), this.compute(z.z, y.z, A))\n            }\n        },\n        plotNode: function(x, w) {\n            if (x.getData(\"type\") == \"none\") {\n                return \n            }\n            this.plotElement(x, w, {\n                getAlpha: function() {\n                    return x.getData(\"alpha\")\n                }\n            })\n        },\n        plotLine: function(w, x) {\n            if (w.getData(\"type\") == \"none\") {\n                return \n            }\n            this.plotElement(w, x, {\n                getAlpha: function() {\n                    return Math.min(w.nodeFrom.getData(\"alpha\"), w.nodeTo.getData(\"alpha\"), w.getData(\"alpha\"))\n                }\n            })\n        },\n        plotElement: function(Y, E, z) {\n            var V = E.getCtx(), F = new Matrix4, x = E.config.Scene.Lighting, Z = E.canvases[0], K = Z.program, X = Z.camera;\n            if (!Y.geometry) {\n                Y.geometry = new O3D[Y.getData(\"type\")]\n            }\n            Y.geometry.update(Y);\n            if (!Y.webGLVertexBuffer) {\n                var J = [], B = [], P = [], N = 0, S = Y.geometry;\n                for (var W = 0, U = S.vertices, H = S.faces, G = H.length; W < G; W++) {\n                    var M = H[W], D = U[M.a], C = U[M.b], A = U[M.c], y = M.d ? U[M.d]: false, R = M.normal;\n                    J.push(D.x, D.y, D.z);\n                    J.push(C.x, C.y, C.z);\n                    J.push(A.x, A.y, A.z);\n                    if (y) {\n                        J.push(y.x, y.y, y.z)\n                    }\n                    P.push(R.x, R.y, R.z);\n                    P.push(R.x, R.y, R.z);\n                    P.push(R.x, R.y, R.z);\n                    if (y) {\n                        P.push(R.x, R.y, R.z)\n                    }\n                    B.push(N, N + 1, N + 2);\n                    if (y) {\n                        B.push(N, N + 2, N + 3);\n                        N += 4\n                    } else {\n                        N += 3\n                    }\n                }\n                Y.webGLVertexBuffer = V.createBuffer();\n                V.bindBuffer(V.ARRAY_BUFFER, Y.webGLVertexBuffer);\n                V.bufferData(V.ARRAY_BUFFER, new Float32Array(J), V.STATIC_DRAW);\n                Y.webGLFaceBuffer = V.createBuffer();\n                V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, Y.webGLFaceBuffer);\n                V.bufferData(V.ELEMENT_ARRAY_BUFFER, new Uint16Array(B), V.STATIC_DRAW);\n                Y.webGLFaceCount = B.length;\n                Y.webGLNormalBuffer = V.createBuffer();\n                V.bindBuffer(V.ARRAY_BUFFER, Y.webGLNormalBuffer);\n                V.bufferData(V.ARRAY_BUFFER, new Float32Array(P), V.STATIC_DRAW)\n            }\n            F.multiply(X.matrix, Y.geometry.matrix);\n            V.uniformMatrix4fv(K.viewMatrix, false, F.flatten());\n            V.uniformMatrix4fv(K.projectionMatrix, false, X.projectionMatrix.flatten());\n            var L = Matrix4.makeInvert(F);\n            L.$transpose();\n            V.uniformMatrix4fv(K.normalMatrix, false, L.flatten());\n            var T = c.hexToRgb(Y.getData(\"color\"));\n            T.push(z.getAlpha());\n            V.uniform4f(K.color, T[0] / 255, T[1] / 255, T[2] / 255, T[3]);\n            V.uniform1i(K.enableLighting, x.enable);\n            if (x.enable) {\n                if (x.ambient) {\n                    var O = x.ambient;\n                    V.uniform3f(K.ambientColor, O[0], O[1], O[2])\n                }\n                if (x.directional) {\n                    var Q = x.directional, T = Q.color, I = Q.direction, w = new Vector3(I.x, I.y, I.z).normalize().$scale(-1);\n                    V.uniform3f(K.lightingDirection, w.x, w.y, w.z);\n                    V.uniform3f(K.directionalColor, T[0], T[1], T[2])\n                }\n            }\n            V.bindBuffer(V.ARRAY_BUFFER, Y.webGLVertexBuffer);\n            V.vertexAttribPointer(K.position, 3, V.FLOAT, false, 0, 0);\n            V.bindBuffer(V.ARRAY_BUFFER, Y.webGLNormalBuffer);\n            V.vertexAttribPointer(K.normal, 3, V.FLOAT, false, 0, 0);\n            V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, Y.webGLFaceBuffer);\n            V.drawElements(V.TRIANGLES, Y.webGLFaceCount, V.UNSIGNED_SHORT, 0)\n        }\n    });\n    e.Label = {};\n    e.Label.Native = new q({\n        initialize: function(w) {\n            this.viz = w\n        },\n        plotLabel: function(y, z, x) {\n            var w = y.getCtx();\n            var A = z.pos.getc(true);\n            w.font = z.getLabelData(\"style\") + \" \" + z.getLabelData(\"size\") + \"px \" + z.getLabelData(\"family\");\n            w.textAlign = z.getLabelData(\"textAlign\");\n            w.fillStyle = w.strokeStyle = z.getLabelData(\"color\");\n            w.textBaseline = z.getLabelData(\"textBaseline\");\n            this.renderLabel(y, z, x)\n        },\n        renderLabel: function(y, z, x) {\n            var w = y.getCtx();\n            var A = z.pos.getc(true);\n            w.fillText(z.name, A.x, A.y + z.getData(\"height\") / 2)\n        },\n        hideLabel: c.empty,\n        hideLabels: c.empty\n    });\n    e.Label.DOM = new q({\n        labelsHidden: false,\n        labelContainer: false,\n        labels: {},\n        getLabelContainer: function() {\n            return this.labelContainer ? this.labelContainer : this.labelContainer = document.getElementById(this.viz.config.labelContainer)\n        },\n        getLabel: function(w) {\n            return (w in this.labels && this.labels[w] != null) ? this.labels[w] : this.labels[w] = document.getElementById(w)\n        },\n        hideLabels: function(x) {\n            var w = this.getLabelContainer();\n            if (x) {\n                w.style.display = \"none\"\n            } else {\n                w.style.display = \"\"\n            }\n            this.labelsHidden = x\n        },\n        clearLabels: function(w) {\n            for (var x in this.labels) {\n                if (w ||!this.viz.graph.hasNode(x)) {\n                    this.disposeLabel(x);\n                    delete this.labels[x]\n                }\n            }\n        },\n        disposeLabel: function(x) {\n            var w = this.getLabel(x);\n            if (w && w.parentNode) {\n                w.parentNode.removeChild(w)\n            }\n        },\n        hideLabel: function(A, w) {\n            A = c.splat(A);\n            var x = w ? \"\": \"none\", y, z = this;\n            c.each(A, function(C) {\n                var B = z.getLabel(C.id);\n                if (B) {\n                    B.style.display = x\n                }\n            })\n        },\n        fitsInCanvas: function(y, w) {\n            var x = w.getSize();\n            if (y.x >= x.width || y.x < 0 || y.y >= x.height || y.y < 0) {\n                return false\n            }\n            return true\n        }\n    });\n    e.Label.HTML = new q({\n        Implements: e.Label.DOM,\n        plotLabel: function(z, A, y) {\n            var B = A.id, w = this.getLabel(B);\n            if (!w&&!(w = document.getElementById(B))) {\n                w = document.createElement(\"div\");\n                var x = this.getLabelContainer();\n                w.id = B;\n                w.className = \"node\";\n                w.style.position = \"absolute\";\n                y.onCreateLabel(w, A);\n                x.appendChild(w);\n                this.labels[A.id] = w\n            }\n            this.placeLabel(w, A, y)\n        }\n    });\n    e.Label.SVG = new q({\n        Implements: e.Label.DOM,\n        plotLabel: function(z, B, y) {\n            var D = B.id, w = this.getLabel(D);\n            if (!w&&!(w = document.getElementById(D))) {\n                var A = \"http://www.w3.org/2000/svg\";\n                w = document.createElementNS(A, \"svg:text\");\n                var C = document.createElementNS(A, \"svg:tspan\");\n                w.appendChild(C);\n                var x = this.getLabelContainer();\n                w.setAttribute(\"id\", D);\n                w.setAttribute(\"class\", \"node\");\n                x.appendChild(w);\n                y.onCreateLabel(w, B);\n                this.labels[B.id] = w\n            }\n            this.placeLabel(w, B, y)\n        }\n    });\n    e.Geom = new q({\n        initialize: function(w) {\n            this.viz = w;\n            this.config = w.config;\n            this.node = w.config.Node;\n            this.edge = w.config.Edge\n        },\n        translate: function(x, w) {\n            w = c.splat(w);\n            this.viz.graph.eachNode(function(y) {\n                c.each(w, function(z) {\n                    y.getPos(z).$add(x)\n                })\n            })\n        },\n        setRightLevelToShow: function(z, w, B) {\n            var A = this.getRightLevelToShow(z, w), y = this.viz.labels, x = c.merge({\n                execShow: true,\n                execHide: true,\n                onHide: c.empty,\n                onShow: c.empty\n            }, B || {});\n            z.eachLevel(0, this.config.levelsToShow, function(D) {\n                var C = D._depth - z._depth;\n                if (C > A) {\n                    x.onHide(D);\n                    if (x.execHide) {\n                        D.drawn = false;\n                        D.exist = false;\n                        y.hideLabel(D, false)\n                    }\n                } else {\n                    x.onShow(D);\n                    if (x.execShow) {\n                        D.exist = true\n                    }\n                }\n            });\n            z.drawn = true\n        },\n        getRightLevelToShow: function(z, x) {\n            var w = this.config;\n            var A = w.levelsToShow;\n            var y = w.constrained;\n            if (!y) {\n                return A\n            }\n            while (!this.treeFitsInCanvas(z, x, A) && A > 1) {\n                A--\n            }\n            return A\n        }\n    });\n    var d = {\n        construct: function(x) {\n            var y = (c.type(x) == \"array\");\n            var w = new e(this.graphOptions, this.config.Node, this.config.Edge, this.config.Label);\n            if (!y) {\n                (function(z, B) {\n                    z.addNode(B);\n                    if (B.children) {\n                        for (var A = 0, C = B.children; A < C.length; A++) {\n                            z.addAdjacence(B, C[A]);\n                            arguments.callee(z, C[A])\n                        }\n                    }\n                })(w, x)\n            } else {\n                (function(H, I) {\n                    var A = function(M) {\n                        for (var L = 0, J = I.length; L < J; L++) {\n                            if (I[L].id == M) {\n                                return I[L]\n                            }\n                        }\n                        var K = {\n                            id: M,\n                            name: M\n                        };\n                        return H.addNode(K)\n                    };\n                    for (var E = 0, B = I.length; E < B; E++) {\n                        H.addNode(I[E]);\n                        var F = I[E].adjacencies;\n                        if (F) {\n                            for (var C = 0, G = F.length; C < G; C++) {\n                                var z = F[C], D = {};\n                                if (typeof F[C] != \"string\") {\n                                    D = c.merge(z.data, {});\n                                    z = z.nodeTo\n                                }\n                                H.addAdjacence(I[E], A(z), D)\n                            }\n                        }\n                    }\n                })(w, x)\n            }\n            return w\n        },\n        loadJSON: function(x, w) {\n            this.json = x;\n            if (this.labels && this.labels.clearLabels) {\n                this.labels.clearLabels(true)\n            }\n            this.graph = this.construct(x);\n            if (c.type(x) != \"array\") {\n                this.root = x.id\n            } else {\n                this.root = x[w ? w: 0].id\n            }\n        },\n        toJSON: function(A) {\n            A = A || \"tree\";\n            if (A == \"tree\") {\n                var y = {};\n                var x = this.graph.getNode(this.root);\n                var y = (function w(D) {\n                    var B = {};\n                    B.id = D.id;\n                    B.name = D.name;\n                    B.data = D.data;\n                    var C = [];\n                    D.eachSubnode(function(E) {\n                        C.push(w(E))\n                    });\n                    B.children = C;\n                    return B\n                })(x);\n                return y\n            } else {\n                var y = [];\n                var z=!!this.graph.getNode(this.root).visited;\n                this.graph.eachNode(function(C) {\n                    var B = {};\n                    B.id = C.id;\n                    B.name = C.name;\n                    B.data = C.data;\n                    var D = [];\n                    C.eachAdjacency(function(E) {\n                        var G = E.nodeTo;\n                        if (!!G.visited === z) {\n                            var F = {};\n                            F.nodeTo = G.id;\n                            F.data = E.data;\n                            D.push(F)\n                        }\n                    });\n                    B.adjacencies = D;\n                    y.push(B);\n                    C.visited=!z\n                });\n                return y\n            }\n        }\n    };\n    var g = $jit.Layouts = {};\n    var f = {\n        label: null,\n        compute: function(z, A, x) {\n            this.initializeLabel(x);\n            var w = this.label, y = w.style;\n            z.eachNode(function(D) {\n                var H = D.getData(\"autoWidth\"), I = D.getData(\"autoHeight\");\n                if (H || I) {\n                    delete D.data.$width;\n                    delete D.data.$height;\n                    delete D.data.$dim;\n                    var B = D.getData(\"width\"), J = D.getData(\"height\");\n                    y.width = H ? \"auto\" : B + \"px\";\n                    y.height = I ? \"auto\" : J + \"px\";\n                    w.innerHTML = D.name;\n                    var F = w.offsetWidth, C = w.offsetHeight;\n                    var G = D.getData(\"type\");\n                    if (c.indexOf([\"circle\", \"square\", \"triangle\", \"star\"], G)===-1) {\n                        D.setData(\"width\", F);\n                        D.setData(\"height\", C)\n                    } else {\n                        var E = F > C ? F: C;\n                        D.setData(\"width\", E);\n                        D.setData(\"height\", E);\n                        D.setData(\"dim\", E)\n                    }\n                }\n            })\n        },\n        initializeLabel: function(w) {\n            if (!this.label) {\n                this.label = document.createElement(\"div\");\n                document.body.appendChild(this.label)\n            }\n            this.setLabelStyles(w)\n        },\n        setLabelStyles: function(w) {\n            c.extend(this.label.style, {\n                visibility: \"hidden\",\n                position: \"absolute\",\n                width: \"auto\",\n                height: \"auto\"\n            });\n            this.label.className = \"jit-autoadjust-label\"\n        }\n    };\n    g.Tree = (function() {\n        var F = Array.prototype.slice;\n        function D(P, K, H, N, I) {\n            var M = K.Node;\n            var J = K.multitree;\n            if (M.overridable) {\n                var O =- 1, L =- 1;\n                P.eachNode(function(S) {\n                    if (S._depth == H && (!J || (\"$orn\" in S.data) && S.data.$orn == N)) {\n                        var Q = S.getData(\"width\", I);\n                        var R = S.getData(\"height\", I);\n                        O = (O < Q) ? Q : O;\n                        L = (L < R) ? R : L\n                    }\n                });\n                return {\n                    width: O < 0 ? M.width: O,\n                    height: L < 0 ? M.height: L\n                }\n            } else {\n                return M\n            }\n        }\n        function G(I, L, K, H) {\n            var J = (H == \"left\" || H == \"right\") ? \"y\": \"x\";\n            I.getPos(L)[J] += K\n        }\n        function B(I, J) {\n            var H = [];\n            c.each(I, function(K) {\n                K = F.call(K);\n                K[0] += J;\n                K[1] += J;\n                H.push(K)\n            });\n            return H\n        }\n        function E(K, H) {\n            if (K.length == 0) {\n                return H\n            }\n            if (H.length == 0) {\n                return K\n            }\n            var J = K.shift(), I = H.shift();\n            return [[J[0], I[1]]].concat(E(K, H))\n        }\n        function z(H, I) {\n            I = I || [];\n            if (H.length == 0) {\n                return I\n            }\n            var J = H.pop();\n            return z(H, E(J, I))\n        }\n        function C(K, I, L, H, J) {\n            if (K.length <= J || I.length <= J) {\n                return 0\n            }\n            var N = K[J][1], M = I[J][0];\n            return Math.max(C(K, I, L, H, ++J) + L, N - M + H)\n        }\n        function A(K, I, H) {\n            function J(N, P, M) {\n                if (P.length <= M) {\n                    return []\n                }\n                var O = P[M], L = C(N, O, I, H, 0);\n                return [L].concat(J(E(N, B(O, L)), P, ++M))\n            }\n            return J([], K, 0)\n        }\n        function x(L, K, J) {\n            function H(O, Q, N) {\n                if (Q.length <= N) {\n                    return []\n                }\n                var P = Q[N], M =- C(P, O, K, J, 0);\n                return [M].concat(H(E(B(P, M), O), Q, ++N))\n            }\n            L = F.call(L);\n            var I = H([], L.reverse(), 0);\n            return I.reverse()\n        }\n        function w(N, L, I, O) {\n            var J = A(N, L, I), M = x(N, L, I);\n            if (O == \"left\") {\n                M = J\n            } else {\n                if (O == \"right\") {\n                    J = M\n                }\n            }\n            for (var K = 0, H = []; K < J.length; K++) {\n                H[K] = (J[K] + M[K]) / 2\n            }\n            return H\n        }\n        function y(H, R, I, Y, W) {\n            var K = Y.multitree;\n            var Q = [\"x\", \"y\"], N = [\"width\", \"height\"];\n            var J =+ (W == \"left\" || W == \"right\");\n            var O = Q[J], X = Q[1 - J];\n            var T = Y.Node;\n            var M = N[J], V = N[1 - J];\n            var L = Y.siblingOffset;\n            var U = Y.subtreeOffset;\n            var S = Y.align;\n            function P(ab, af, aj) {\n                var aa = ab.getData(M, I);\n                var ai = af || (ab.getData(V, I));\n                var am = [], ak = [], ag = false;\n                var Z = ai + Y.levelDistance;\n                ab.eachSubnode(function(ao) {\n                    if (ao.exist && (!K || (\"$orn\" in ao.data) && ao.data.$orn == W)) {\n                        if (!ag) {\n                            ag = D(H, Y, ao._depth, W, I)\n                        }\n                        var an = P(ao, ag[V], aj + Z);\n                        am.push(an.tree);\n                        ak.push(an.extent)\n                    }\n                });\n                var ae = w(ak, U, L, S);\n                for (var ad = 0, ac = [], ah = []; ad < am.length; ad++) {\n                    G(am[ad], I, ae[ad], W);\n                    ah.push(B(ak[ad], ae[ad]))\n                }\n                var al = [[ - aa / 2, aa / 2]].concat(z(ah));\n                ab.getPos(I)[O] = 0;\n                if (W == \"top\" || W == \"left\") {\n                    ab.getPos(I)[X] = aj\n                } else {\n                    ab.getPos(I)[X] =- aj\n                }\n                return {\n                    tree: ab,\n                    extent: al\n                }\n            }\n            P(R, false, 0)\n        }\n        return new q({\n            compute: function(J, I) {\n                var K = J || \"start\";\n                var H = this.graph.getNode(this.root);\n                c.extend(H, {\n                    drawn: true,\n                    exist: true,\n                    selected: true\n                });\n                f.compute(this.graph, K, this.config);\n                if (!!I ||!(\"_depth\" in H)) {\n                    this.graph.computeLevels(this.root, 0, \"ignore\")\n                }\n                this.computePositions(H, K)\n            },\n            computePositions: function(L, H) {\n                var J = this.config;\n                var I = J.multitree;\n                var O = J.align;\n                var K = O !== \"center\" && J.indent;\n                var P = J.orientation;\n                var N = I ? [\"top\", \"right\", \"bottom\", \"left\"]: [P];\n                var M = this;\n                c.each(N, function(Q) {\n                    y(M.graph, L, H, M.config, Q, H);\n                    var R = [\"x\", \"y\"][ + (Q == \"left\" || Q == \"right\")];\n                    (function S(T) {\n                        T.eachSubnode(function(U) {\n                            if (U.exist && (!I || (\"$orn\" in U.data) && U.data.$orn == Q)) {\n                                U.getPos(H)[R] += T.getPos(H)[R];\n                                if (K) {\n                                    U.getPos(H)[R] += O == \"left\" ? K : - K\n                                }\n                                S(U)\n                            }\n                        })\n                    })(L)\n                })\n            }\n        })\n    })();\n    $jit.ST = (function() {\n        var x = [];\n        function y(D) {\n            D = D || this.clickedNode;\n            if (!this.config.constrained) {\n                return []\n            }\n            var A = this.geom;\n            var H = this.graph;\n            var B = this.canvas;\n            var z = D._depth, E = [];\n            H.eachNode(function(I) {\n                if (I.exist&&!I.selected) {\n                    if (I.isDescendantOf(D.id)) {\n                        if (I._depth <= z) {\n                            E.push(I)\n                        }\n                    } else {\n                        E.push(I)\n                    }\n                }\n            });\n            var F = A.getRightLevelToShow(D, B);\n            D.eachLevel(F, F, function(I) {\n                if (I.exist&&!I.selected) {\n                    E.push(I)\n                }\n            });\n            for (var G = 0; G < x.length; G++) {\n                var C = this.graph.getNode(x[G]);\n                if (!C.isDescendantOf(D.id)) {\n                    E.push(C)\n                }\n            }\n            return E\n        }\n        function w(B) {\n            var A = [], z = this.config;\n            B = B || this.clickedNode;\n            this.clickedNode.eachLevel(0, z.levelsToShow, function(C) {\n                if (z.multitree&&!(\"$orn\" in C.data) && C.anySubnode(function(D) {\n                    return D.exist&&!D.drawn\n                })) {\n                    A.push(C)\n                } else {\n                    if (C.drawn&&!C.anySubnode(\"drawn\")) {\n                        A.push(C)\n                    }\n                }\n            });\n            return A\n        }\n        return new q({\n            Implements: [d, o, g.Tree],\n            initialize: function(z) {\n                var B = $jit.ST;\n                var A = {\n                    levelsToShow: 2,\n                    levelDistance: 30,\n                    constrained: true,\n                    Node: {\n                        type: \"rectangle\"\n                    },\n                    duration: 700,\n                    offsetX: 0,\n                    offsetY: 0\n                };\n                this.controller = this.config = c.merge(n(\"Canvas\", \"Fx\", \"Tree\", \"Node\", \"Edge\", \"Controller\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Label\"), A, z);\n                var C = this.config;\n                if (C.useCanvas) {\n                    this.canvas = C.useCanvas;\n                    this.config.labelContainer = this.canvas.id + \"-label\"\n                } else {\n                    if (C.background) {\n                        C.background = c.merge({\n                            type: \"Circles\"\n                        }, C.background)\n                    }\n                    this.canvas = new l(this, C);\n                    this.config.labelContainer = (typeof C.injectInto == \"string\" ? C.injectInto : C.injectInto.id) + \"-label\"\n                }\n                this.graphOptions = {\n                    klass: p\n                };\n                this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge);\n                this.labels = new B.Label[C.Label.type](this);\n                this.fx = new B.Plot(this, B);\n                this.op = new B.Op(this);\n                this.group = new B.Group(this);\n                this.geom = new B.Geom(this);\n                this.clickedNode = null;\n                this.initializeExtras()\n            },\n            plot: function() {\n                this.fx.plot(this.controller)\n            },\n            switchPosition: function(E, D, C) {\n                var z = this.geom, A = this.fx, B = this;\n                if (!A.busy) {\n                    A.busy = true;\n                    this.contract({\n                        onComplete: function() {\n                            z.switchOrientation(E);\n                            B.compute(\"end\", false);\n                            A.busy = false;\n                            if (D == \"animate\") {\n                                B.onClick(B.clickedNode.id, C)\n                            } else {\n                                if (D == \"replot\") {\n                                    B.select(B.clickedNode.id, C)\n                                }\n                            }\n                        }\n                    }, E)\n                }\n            },\n            switchAlignment: function(B, A, z) {\n                this.config.align = B;\n                if (A == \"animate\") {\n                    this.select(this.clickedNode.id, z)\n                } else {\n                    if (A == \"replot\") {\n                        this.onClick(this.clickedNode.id, z)\n                    }\n                }\n            },\n            addNodeInPath: function(z) {\n                x.push(z);\n                this.select((this.clickedNode && this.clickedNode.id) || this.root)\n            },\n            clearNodesInPath: function(z) {\n                x.length = 0;\n                this.select((this.clickedNode && this.clickedNode.id) || this.root)\n            },\n            refresh: function() {\n                this.reposition();\n                this.select((this.clickedNode && this.clickedNode.id) || this.root)\n            },\n            reposition: function() {\n                this.graph.computeLevels(this.root, 0, \"ignore\");\n                this.geom.setRightLevelToShow(this.clickedNode, this.canvas);\n                this.graph.eachNode(function(z) {\n                    if (z.exist) {\n                        z.drawn = true\n                    }\n                });\n                this.compute(\"end\")\n            },\n            requestNodes: function(B, C) {\n                var A = c.merge(this.controller, C), z = this.config.levelsToShow;\n                if (A.request) {\n                    var E = [], D = B._depth;\n                    B.eachLevel(0, z, function(F) {\n                        if (F.drawn&&!F.anySubnode()) {\n                            E.push(F);\n                            F._level = z - (F._depth - D)\n                        }\n                    });\n                    this.group.requestNodes(E, A)\n                } else {\n                    A.onComplete()\n                }\n            },\n            contract: function(D, E) {\n                var C = this.config.orientation;\n                var z = this.geom, B = this.group;\n                if (E) {\n                    z.switchOrientation(E)\n                }\n                var A = y.call(this);\n                if (E) {\n                    z.switchOrientation(C)\n                }\n                B.contract(A, c.merge(this.controller, D))\n            },\n            move: function(A, B) {\n                this.compute(\"end\", false);\n                var z = B.Move, C = {\n                    x: z.offsetX,\n                    y: z.offsetY\n                };\n                if (z.enable) {\n                    this.geom.translate(A.endPos.add(C).$scale(-1), \"end\")\n                }\n                this.fx.animate(c.merge(this.controller, {\n                    modes: [\"linear\"]\n                }, B))\n            },\n            expand: function(A, B) {\n                var z = w.call(this, A);\n                this.group.expand(z, c.merge(this.controller, B))\n            },\n            selectPath: function(C) {\n                var B = this;\n                this.graph.eachNode(function(E) {\n                    E.selected = false\n                });\n                function D(F) {\n                    if (F == null || F.selected) {\n                        return \n                    }\n                    F.selected = true;\n                    c.each(B.group.getSiblings([F])[F.id], function(G) {\n                        G.exist = true;\n                        G.drawn = true\n                    });\n                    var E = F.getParents();\n                    E = (E.length > 0) ? E[0] : null;\n                    D(E)\n                }\n                for (var z = 0, A = [C.id].concat(x); z < A.length; z++) {\n                    D(this.graph.getNode(A[z]))\n                }\n            },\n            setRoot: function(G, F, E) {\n                if (this.busy) {\n                    return \n                }\n                this.busy = true;\n                var D = this, B = this.canvas;\n                var z = this.graph.getNode(this.root);\n                var A = this.graph.getNode(G);\n                function C() {\n                    if (this.config.multitree && A.data.$orn) {\n                        var I = A.data.$orn;\n                        var J = {\n                            left: \"right\",\n                            right: \"left\",\n                            top: \"bottom\",\n                            bottom: \"top\"\n                        }\n                        [I];\n                        z.data.$orn = J;\n                        (function H(K) {\n                            K.eachSubnode(function(L) {\n                                if (L.id != G) {\n                                    L.data.$orn = J;\n                                    H(L)\n                                }\n                            })\n                        })(z);\n                        delete A.data.$orn\n                    }\n                    this.root = G;\n                    this.clickedNode = A;\n                    this.graph.computeLevels(this.root, 0, \"ignore\");\n                    this.geom.setRightLevelToShow(A, B, {\n                        execHide: false,\n                        onShow: function(K) {\n                            if (!K.drawn) {\n                                K.drawn = true;\n                                K.setData(\"alpha\", 1, \"end\");\n                                K.setData(\"alpha\", 0);\n                                K.pos.setc(A.pos.x, A.pos.y)\n                            }\n                        }\n                    });\n                    this.compute(\"end\");\n                    this.busy = true;\n                    this.fx.animate({\n                        modes: [\"linear\", \"node-property:alpha\"],\n                        onComplete: function() {\n                            D.busy = false;\n                            D.onClick(G, {\n                                onComplete: function() {\n                                    E && E.onComplete()\n                                }\n                            })\n                        }\n                    })\n                }\n                delete z.data.$orns;\n                if (F == \"animate\") {\n                    C.call(this);\n                    D.selectPath(A)\n                } else {\n                    if (F == \"replot\") {\n                        C.call(this);\n                        this.select(this.root)\n                    }\n                }\n            },\n            addSubtree: function(z, B, A) {\n                if (B == \"replot\") {\n                    this.op.sum(z, c.extend({\n                        type: \"replot\"\n                    }, A || {}))\n                } else {\n                    if (B == \"animate\") {\n                        this.op.sum(z, c.extend({\n                            type: \"fade:seq\"\n                        }, A || {}))\n                    }\n                }\n            },\n            removeSubtree: function(E, A, D, C) {\n                var B = this.graph.getNode(E), z = [];\n                B.eachLevel(+!A, false, function(F) {\n                    z.push(F.id)\n                });\n                if (D == \"replot\") {\n                    this.op.removeNode(z, c.extend({\n                        type: \"replot\"\n                    }, C || {}))\n                } else {\n                    if (D == \"animate\") {\n                        this.op.removeNode(z, c.extend({\n                            type: \"fade:seq\"\n                        }, C || {}))\n                    }\n                }\n            },\n            select: function(z, C) {\n                var H = this.group, F = this.geom;\n                var D = this.graph.getNode(z), B = this.canvas;\n                var G = this.graph.getNode(this.root);\n                var A = c.merge(this.controller, C);\n                var E = this;\n                A.onBeforeCompute(D);\n                this.selectPath(D);\n                this.clickedNode = D;\n                this.requestNodes(D, {\n                    onComplete: function() {\n                        H.hide(H.prepare(y.call(E)), A);\n                        F.setRightLevelToShow(D, B);\n                        E.compute(\"current\");\n                        E.graph.eachNode(function(K) {\n                            var J = K.pos.getc(true);\n                            K.startPos.setc(J.x, J.y);\n                            K.endPos.setc(J.x, J.y);\n                            K.visited = false\n                        });\n                        var I = {\n                            x: A.offsetX,\n                            y: A.offsetY\n                        };\n                        E.geom.translate(D.endPos.add(I).$scale(-1), [\"start\", \"current\", \"end\"]);\n                        H.show(w.call(E));\n                        E.plot();\n                        A.onAfterCompute(E.clickedNode);\n                        A.onComplete()\n                    }\n                })\n            },\n            onClick: function(A, H) {\n                var C = this.canvas, G = this, z = this.geom, D = this.config;\n                var F = {\n                    Move: {\n                        enable: true,\n                        offsetX: D.offsetX || 0,\n                        offsetY: D.offsetY || 0\n                    },\n                    setRightLevelToShowConfig: false,\n                    onBeforeRequest: c.empty,\n                    onBeforeContract: c.empty,\n                    onBeforeMove: c.empty,\n                    onBeforeExpand: c.empty\n                };\n                var B = c.merge(this.controller, F, H);\n                if (!this.busy) {\n                    this.busy = true;\n                    var E = this.graph.getNode(A);\n                    this.selectPath(E, this.clickedNode);\n                    this.clickedNode = E;\n                    B.onBeforeCompute(E);\n                    B.onBeforeRequest(E);\n                    this.requestNodes(E, {\n                        onComplete: function() {\n                            B.onBeforeContract(E);\n                            G.contract({\n                                onComplete: function() {\n                                    z.setRightLevelToShow(E, C, B.setRightLevelToShowConfig);\n                                    B.onBeforeMove(E);\n                                    G.move(E, {\n                                        Move: B.Move,\n                                        onComplete: function() {\n                                            B.onBeforeExpand(E);\n                                            G.expand(E, {\n                                                onComplete: function() {\n                                                    G.busy = false;\n                                                    B.onAfterCompute(A);\n                                                    B.onComplete()\n                                                }\n                                            })\n                                        }\n                                    })\n                                }\n                            })\n                        }\n                    })\n                }\n            }\n        })\n    })();\n    $jit.ST.$extend = true;\n    $jit.ST.Op = new q({\n        Implements: e.Op\n    });\n    $jit.ST.Group = new q({\n        initialize: function(w) {\n            this.viz = w;\n            this.canvas = w.canvas;\n            this.config = w.config;\n            this.animation = new u;\n            this.nodes = null\n        },\n        requestNodes: function(B, A) {\n            var z = 0, x = B.length, D = {};\n            var y = function() {\n                A.onComplete()\n            };\n            var w = this.viz;\n            if (x == 0) {\n                y()\n            }\n            for (var C = 0; C < x; C++) {\n                D[B[C].id] = B[C];\n                A.request(B[C].id, B[C]._level, {\n                    onComplete: function(F, E) {\n                        if (E && E.children) {\n                            E.id = F;\n                            w.op.sum(E, {\n                                type: \"nothing\"\n                            })\n                        }\n                        if (++z == x) {\n                            w.graph.computeLevels(w.root, 0);\n                            y()\n                        }\n                    }\n                })\n            }\n        },\n        contract: function(y, x) {\n            var w = this.viz;\n            var z = this;\n            y = this.prepare(y);\n            this.animation.setOptions(c.merge(x, {\n                $animating: false,\n                compute: function(A) {\n                    if (A == 1) {\n                        A = 0.99\n                    }\n                    z.plotStep(1 - A, x, this.$animating);\n                    this.$animating = \"contract\"\n                },\n                complete: function() {\n                    z.hide(y, x)\n                }\n            })).start()\n        },\n        hide: function(y, x) {\n            var w = this.viz;\n            for (var z = 0; z < y.length; z++) {\n                if (true ||!x ||!x.request) {\n                    y[z].eachLevel(1, false, function(B) {\n                        if (B.exist) {\n                            c.extend(B, {\n                                drawn: false,\n                                exist: false\n                            })\n                        }\n                    })\n                } else {\n                    var A = [];\n                    y[z].eachLevel(1, false, function(B) {\n                        A.push(B.id)\n                    });\n                    w.op.removeNode(A, {\n                        type: \"nothing\"\n                    });\n                    w.labels.clearLabels()\n                }\n            }\n            x.onComplete()\n        },\n        expand: function(x, w) {\n            var y = this;\n            this.show(x);\n            this.animation.setOptions(c.merge(w, {\n                $animating: false,\n                compute: function(z) {\n                    y.plotStep(z, w, this.$animating);\n                    this.$animating = \"expand\"\n                },\n                complete: function() {\n                    y.plotStep(undefined, w, false);\n                    w.onComplete()\n                }\n            })).start()\n        },\n        show: function(w) {\n            var x = this.config;\n            this.prepare(w);\n            c.each(w, function(z) {\n                if (x.multitree&&!(\"$orn\" in z.data)) {\n                    delete z.data.$orns;\n                    var y = \" \";\n                    z.eachSubnode(function(A) {\n                        if ((\"$orn\" in A.data) && y.indexOf(A.data.$orn) < 0 && A.exist&&!A.drawn) {\n                            y += A.data.$orn + \" \"\n                        }\n                    });\n                    z.data.$orns = y\n                }\n                z.eachLevel(0, x.levelsToShow, function(A) {\n                    if (A.exist) {\n                        A.drawn = true\n                    }\n                })\n            })\n        },\n        prepare: function(w) {\n            this.nodes = this.getNodesWithChildren(w);\n            return this.nodes\n        },\n        getNodesWithChildren: function(y) {\n            var x = [], A = this.config, w = this.viz.root;\n            y.sort(function(E, D) {\n                return (E._depth <= D._depth) - (E._depth >= D._depth)\n            });\n            for (var B = 0; B < y.length; B++) {\n                if (y[B].anySubnode(\"exist\")) {\n                    for (var z = B + 1, C = false; !C && z < y.length; z++) {\n                        if (!A.multitree || \"$orn\" in y[z].data) {\n                            C = C || y[B].isDescendantOf(y[z].id)\n                        }\n                    }\n                    if (!C) {\n                        x.push(y[B])\n                    }\n                }\n            }\n            return x\n        },\n        plotStep: function(G, C, I) {\n            var F = this.viz, z = this.config, y = F.canvas, H = y.getCtx(), w = this.nodes;\n            var B, A;\n            var x = {};\n            for (B = 0; B < w.length; B++) {\n                A = w[B];\n                x[A.id] = [];\n                var E = z.multitree&&!(\"$orn\" in A.data);\n                var D = E && A.data.$orns;\n                A.eachSubgraph(function(J) {\n                    if (E && D && D.indexOf(J.data.$orn) > 0 && J.drawn) {\n                        J.drawn = false;\n                        x[A.id].push(J)\n                    } else {\n                        if ((!E ||!D) && J.drawn) {\n                            J.drawn = false;\n                            x[A.id].push(J)\n                        }\n                    }\n                });\n                A.drawn = true\n            }\n            if (w.length > 0) {\n                F.fx.plot()\n            }\n            for (B in x) {\n                c.each(x[B], function(J) {\n                    J.drawn = true\n                })\n            }\n            for (B = 0; B < w.length; B++) {\n                A = w[B];\n                H.save();\n                F.fx.plotSubtree(A, C, G, I);\n                H.restore()\n            }\n        },\n        getSiblings: function(w) {\n            var x = {};\n            c.each(w, function(A) {\n                var z = A.getParents();\n                if (z.length == 0) {\n                    x[A.id] = [A]\n                } else {\n                    var y = [];\n                    z[0].eachSubnode(function(B) {\n                        y.push(B)\n                    });\n                    x[A.id] = y\n                }\n            });\n            return x\n        }\n    });\n    $jit.ST.Geom = new q({\n        Implements: e.Geom,\n        switchOrientation: function(w) {\n            this.config.orientation = w\n        },\n        dispatch: function() {\n            var x = Array.prototype.slice.call(arguments);\n            var y = x.shift(), w = x.length;\n            var z = function(A) {\n                return typeof A == \"function\" ? A() : A\n            };\n            if (w == 2) {\n                return (y == \"top\" || y == \"bottom\") ? z(x[0]) : z(x[1])\n            } else {\n                if (w == 4) {\n                    switch (y) {\n                    case\"top\":\n                        return z(x[0]);\n                    case\"right\":\n                        return z(x[1]);\n                    case\"bottom\":\n                        return z(x[2]);\n                    case\"left\":\n                        return z(x[3])\n                    }\n                }\n            }\n            return undefined\n        },\n        getSize: function(E, D) {\n            var C = E.data, z = this.config;\n            var y = z.siblingOffset;\n            var B = (z.multitree && (\"$orn\" in C) && C.$orn) || z.orientation;\n            var x = E.getData(\"width\") + y;\n            var A = E.getData(\"height\") + y;\n            if (!D) {\n                return this.dispatch(B, A, x)\n            } else {\n                return this.dispatch(B, x, A)\n            }\n        },\n        getTreeBaseSize: function(A, B, x) {\n            var y = this.getSize(A, true), w = 0, z = this;\n            if (x(B, A)) {\n                return y\n            }\n            if (B === 0) {\n                return 0\n            }\n            A.eachSubnode(function(C) {\n                w += z.getTreeBaseSize(C, B-1, x)\n            });\n            return (y > w ? y : w) + this.config.subtreeOffset\n        },\n        getEdge: function(C, B, A) {\n            var y = function(E, w) {\n                return function() {\n                    return C.pos.add(new p(E, w))\n                }\n            };\n            var D = this.node;\n            var x = C.getData(\"width\");\n            var z = C.getData(\"height\");\n            if (B == \"begin\") {\n                if (D.align == \"center\") {\n                    return this.dispatch(A, y(0, z / 2), y( - x / 2, 0), y(0, - z / 2), y(x / 2, 0))\n                } else {\n                    if (D.align == \"left\") {\n                        return this.dispatch(A, y(0, z), y(0, 0), y(0, 0), y(x, 0))\n                    } else {\n                        if (D.align == \"right\") {\n                            return this.dispatch(A, y(0, 0), y( - x, 0), y(0, - z), y(0, 0))\n                        } else {\n                            throw \"align: not implemented\"\n                        }\n                    }\n                }\n            } else {\n                if (B == \"end\") {\n                    if (D.align == \"center\") {\n                        return this.dispatch(A, y(0, - z / 2), y(x / 2, 0), y(0, z / 2), y( - x / 2, 0))\n                    } else {\n                        if (D.align == \"left\") {\n                            return this.dispatch(A, y(0, 0), y(x, 0), y(0, z), y(0, 0))\n                        } else {\n                            if (D.align == \"right\") {\n                                return this.dispatch(A, y(0, - z), y(0, 0), y(0, 0), y( - x, 0))\n                            } else {\n                                throw \"align: not implemented\"\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        getScaledTreePosition: function(B, D) {\n            var C = this.node;\n            var x = B.getData(\"width\");\n            var A = B.getData(\"height\");\n            var z = (this.config.multitree && (\"$orn\" in B.data) && B.data.$orn) || this.config.orientation;\n            var y = function(E, w) {\n                return function() {\n                    return B.pos.add(new p(E, w)).$scale(1 - D)\n                }\n            };\n            if (C.align == \"left\") {\n                return this.dispatch(z, y(0, A), y(0, 0), y(0, 0), y(x, 0))\n            } else {\n                if (C.align == \"center\") {\n                    return this.dispatch(z, y(0, A / 2), y( - x / 2, 0), y(0, - A / 2), y(x / 2, 0))\n                } else {\n                    if (C.align == \"right\") {\n                        return this.dispatch(z, y(0, 0), y( - x, 0), y(0, - A), y(0, 0))\n                    } else {\n                        throw \"align: not implemented\"\n                    }\n                }\n            }\n        },\n        treeFitsInCanvas: function(B, w, C) {\n            var y = w.getSize();\n            var z = (this.config.multitree && (\"$orn\" in B.data) && B.data.$orn) || this.config.orientation;\n            var x = this.dispatch(z, y.width, y.height);\n            var A = this.getTreeBaseSize(B, C, function(E, D) {\n                return E === 0 ||!D.anySubnode()\n            });\n            return (A < x)\n        }\n    });\n    $jit.ST.Plot = new q({\n        Implements: e.Plot,\n        plotSubtree: function(z, w, A, E) {\n            var C = this.viz, x = C.canvas, y = C.config;\n            A = Math.min(Math.max(0.001, A), 1);\n            if (A >= 0) {\n                z.drawn = false;\n                var D = x.getCtx();\n                var B = C.geom.getScaledTreePosition(z, A);\n                D.translate(B.x, B.y);\n                D.scale(A, A)\n            }\n            this.plotTree(z, c.merge(w, {\n                withLabels: true,\n                hideLabels: !!A,\n                plotSubtree: function(I, G) {\n                    var F = y.multitree&&!(\"$orn\" in z.data);\n                    var H = F && z.getData(\"orns\");\n                    return !F || H.indexOf(z.getData(\"orn\"))>-1\n                }\n            }), E);\n            if (A >= 0) {\n                z.drawn = true\n            }\n        },\n        getAlignedPos: function(B, z, w) {\n            var y = this.node;\n            var A, x;\n            if (y.align == \"center\") {\n                A = {\n                    x: B.x - z / 2,\n                    y: B.y - w / 2\n                }\n            } else {\n                if (y.align == \"left\") {\n                    x = this.config.orientation;\n                    if (x == \"bottom\" || x == \"top\") {\n                        A = {\n                            x: B.x - z / 2,\n                            y: B.y\n                        }\n                    } else {\n                        A = {\n                            x: B.x,\n                            y: B.y - w / 2\n                        }\n                    }\n                } else {\n                    if (y.align == \"right\") {\n                        x = this.config.orientation;\n                        if (x == \"bottom\" || x == \"top\") {\n                            A = {\n                                x: B.x - z / 2,\n                                y: B.y - w\n                            }\n                        } else {\n                            A = {\n                                x: B.x - z,\n                                y: B.y - w / 2\n                            }\n                        }\n                    } else {\n                        throw \"align: not implemented\"\n                    }\n                }\n            }\n            return A\n        },\n        getOrientation: function(w) {\n            var y = this.config;\n            var x = y.orientation;\n            if (y.multitree) {\n                var z = w.nodeFrom;\n                var A = w.nodeTo;\n                x = ((\"$orn\" in z.data) && z.data.$orn) || ((\"$orn\" in A.data) && A.data.$orn)\n            }\n            return x\n        }\n    });\n    $jit.ST.Label = {};\n    $jit.ST.Label.Native = new q({\n        Implements: e.Label.Native,\n        renderLabel: function(z, B, y) {\n            var x = z.getCtx(), D = B.pos.getc(true), A = B.getData(\"width\"), w = B.getData(\"height\"), C = this.viz.fx.getAlignedPos(D, A, w);\n            x.fillText(B.name, C.x + A / 2, C.y + w / 2)\n        }\n    });\n    $jit.ST.Label.DOM = new q({\n        Implements: e.Label.DOM,\n        placeLabel: function(P, J, F) {\n            var B = J.pos.getc(true), O = this.viz.config, K = O.Node, x = this.viz.canvas, C = J.getData(\"width\"), M = J.getData(\"height\"), y = x.getSize(), G, N;\n            var A = x.translateOffsetX, z = x.translateOffsetY, E = x.scaleOffsetX, D = x.scaleOffsetY, I = B.x * E + A, H = B.y * D + z;\n            if (K.align == \"center\") {\n                G = {\n                    x: Math.round(I - C / 2 + y.width / 2),\n                    y: Math.round(H - M / 2 + y.height / 2)\n                }\n            } else {\n                if (K.align == \"left\") {\n                    N = O.orientation;\n                    if (N == \"bottom\" || N == \"top\") {\n                        G = {\n                            x: Math.round(I - C / 2 + y.width / 2),\n                            y: Math.round(H + y.height / 2)\n                        }\n                    } else {\n                        G = {\n                            x: Math.round(I + y.width / 2),\n                            y: Math.round(H - M / 2 + y.height / 2)\n                        }\n                    }\n                } else {\n                    if (K.align == \"right\") {\n                        N = O.orientation;\n                        if (N == \"bottom\" || N == \"top\") {\n                            G = {\n                                x: Math.round(I - C / 2 + y.width / 2),\n                                y: Math.round(H - M + y.height / 2)\n                            }\n                        } else {\n                            G = {\n                                x: Math.round(I - C + y.width / 2),\n                                y: Math.round(H - M / 2 + y.height / 2)\n                            }\n                        }\n                    } else {\n                        throw \"align: not implemented\"\n                    }\n                }\n            }\n            var L = P.style;\n            L.left = G.x + \"px\";\n            L.top = G.y + \"px\";\n            L.display = this.fitsInCanvas(G, x) ? \"\" : \"none\";\n            F.onPlaceLabel(P, J)\n        }\n    });\n    $jit.ST.Label.SVG = new q({\n        Implements: [$jit.ST.Label.DOM, e.Label.SVG],\n        initialize: function(w) {\n            this.viz = w\n        }\n    });\n    $jit.ST.Label.HTML = new q({\n        Implements: [$jit.ST.Label.DOM, e.Label.HTML],\n        initialize: function(w) {\n            this.viz = w\n        }\n    });\n    $jit.ST.Plot.NodeTypes = new q({\n        none: {\n            render: c.empty,\n            contains: c.lambda(false)\n        },\n        circle: {\n            render: function(x, w) {\n                var z = x.getData(\"dim\"), A = this.getAlignedPos(x.pos.getc(true), z, z), y = z / 2;\n                this.nodeHelper.circle.render(\"fill\", {\n                    x: A.x + y,\n                    y: A.y + y\n                }, y, w)\n            },\n            contains: function(w, A) {\n                var y = w.getData(\"dim\"), z = this.getAlignedPos(w.pos.getc(true), y, y), x = y / 2;\n                this.nodeHelper.circle.contains({\n                    x: z.x + x,\n                    y: z.y + x\n                }, A, x)\n            }\n        },\n        square: {\n            render: function(x, w) {\n                var z = x.getData(\"dim\"), y = z / 2, A = this.getAlignedPos(x.pos.getc(true), z, z);\n                this.nodeHelper.square.render(\"fill\", {\n                    x: A.x + y,\n                    y: A.y + y\n                }, y, w)\n            },\n            contains: function(w, A) {\n                var y = w.getData(\"dim\"), z = this.getAlignedPos(w.pos.getc(true), y, y), x = y / 2;\n                this.nodeHelper.square.contains({\n                    x: z.x + x,\n                    y: z.y + x\n                }, A, x)\n            }\n        },\n        ellipse: {\n            render: function(z, x) {\n                var y = z.getData(\"width\"), w = z.getData(\"height\"), A = this.getAlignedPos(z.pos.getc(true), y, w);\n                this.nodeHelper.ellipse.render(\"fill\", {\n                    x: A.x + y / 2,\n                    y: A.y + w / 2\n                }, y, w, x)\n            },\n            contains: function(y, A) {\n                var x = y.getData(\"width\"), w = y.getData(\"height\"), z = this.getAlignedPos(y.pos.getc(true), x, w);\n                this.nodeHelper.ellipse.contains({\n                    x: z.x + x / 2,\n                    y: z.y + w / 2\n                }, A, x, w)\n            }\n        },\n        rectangle: {\n            render: function(z, x) {\n                var y = z.getData(\"width\"), w = z.getData(\"height\"), A = this.getAlignedPos(z.pos.getc(true), y, w);\n                this.nodeHelper.rectangle.render(\"fill\", {\n                    x: A.x + y / 2,\n                    y: A.y + w / 2\n                }, y, w, x)\n            },\n            contains: function(y, A) {\n                var x = y.getData(\"width\"), w = y.getData(\"height\"), z = this.getAlignedPos(y.pos.getc(true), x, w);\n                this.nodeHelper.rectangle.contains({\n                    x: z.x + x / 2,\n                    y: z.y + w / 2\n                }, A, x, w)\n            }\n        }\n    });\n    $jit.ST.Plot.EdgeTypes = new q({\n        none: c.empty,\n        line: {\n            render: function(x, z) {\n                var y = this.getOrientation(x), A = x.nodeFrom, B = x.nodeTo, w = A._depth < B._depth, D = this.viz.geom.getEdge(w ? A : B, \"begin\", y), C = this.viz.geom.getEdge(w ? B : A, \"end\", y);\n                this.edgeHelper.line.render(D, C, z)\n            },\n            contains: function(x, D) {\n                var y = this.getOrientation(x), z = x.nodeFrom, A = x.nodeTo, w = z._depth < A._depth, C = this.viz.geom.getEdge(w ? z : A, \"begin\", y), B = this.viz.geom.getEdge(w ? A : z, \"end\", y);\n                return this.edgeHelper.line.contains(C, B, D, this.edge.epsilon)\n            }\n        },\n        arrow: {\n            render: function(C, x) {\n                var B = this.getOrientation(C), y = C.nodeFrom, w = C.nodeTo, A = C.getData(\"dim\"), E = this.viz.geom.getEdge(y, \"begin\", B), F = this.viz.geom.getEdge(w, \"end\", B), D = C.data.$direction, z = (D && D.length > 1 && D[0] != y.id);\n                this.edgeHelper.arrow.render(E, F, A, z, x)\n            },\n            contains: function(x, D) {\n                var y = this.getOrientation(x), z = x.nodeFrom, A = x.nodeTo, w = z._depth < A._depth, C = this.viz.geom.getEdge(w ? z : A, \"begin\", y), B = this.viz.geom.getEdge(w ? A : z, \"end\", y);\n                return this.edgeHelper.arrow.contains(C, B, D, this.edge.epsilon)\n            }\n        },\n        \"quadratic:begin\": {\n            render: function(C, w) {\n                var B = this.getOrientation(C);\n                var A = C.nodeFrom, D = C.nodeTo, F = A._depth < D._depth, x = this.viz.geom.getEdge(F ? A : D, \"begin\", B), y = this.viz.geom.getEdge(F ? D : A, \"end\", B), z = C.getData(\"dim\"), E = w.getCtx();\n                E.beginPath();\n                E.moveTo(x.x, x.y);\n                switch (B) {\n                case\"left\":\n                    E.quadraticCurveTo(x.x + z, x.y, y.x, y.y);\n                    break;\n                case\"right\":\n                    E.quadraticCurveTo(x.x - z, x.y, y.x, y.y);\n                    break;\n                case\"top\":\n                    E.quadraticCurveTo(x.x, x.y + z, y.x, y.y);\n                    break;\n                case\"bottom\":\n                    E.quadraticCurveTo(x.x, x.y - z, y.x, y.y);\n                    break\n                }\n                E.stroke()\n            }\n        },\n        \"quadratic:end\": {\n            render: function(C, w) {\n                var B = this.getOrientation(C);\n                var A = C.nodeFrom, D = C.nodeTo, F = A._depth < D._depth, x = this.viz.geom.getEdge(F ? A : D, \"begin\", B), y = this.viz.geom.getEdge(F ? D : A, \"end\", B), z = C.getData(\"dim\"), E = w.getCtx();\n                E.beginPath();\n                E.moveTo(x.x, x.y);\n                switch (B) {\n                case\"left\":\n                    E.quadraticCurveTo(y.x - z, y.y, y.x, y.y);\n                    break;\n                case\"right\":\n                    E.quadraticCurveTo(y.x + z, y.y, y.x, y.y);\n                    break;\n                case\"top\":\n                    E.quadraticCurveTo(y.x, y.y - z, y.x, y.y);\n                    break;\n                case\"bottom\":\n                    E.quadraticCurveTo(y.x, y.y + z, y.x, y.y);\n                    break\n                }\n                E.stroke()\n            }\n        },\n        bezier: {\n            render: function(C, w) {\n                var B = this.getOrientation(C), A = C.nodeFrom, D = C.nodeTo, F = A._depth < D._depth, x = this.viz.geom.getEdge(F ? A : D, \"begin\", B), y = this.viz.geom.getEdge(F ? D : A, \"end\", B), z = C.getData(\"dim\"), E = w.getCtx();\n                E.beginPath();\n                E.moveTo(x.x, x.y);\n                switch (B) {\n                case\"left\":\n                    E.bezierCurveTo(x.x + z, x.y, y.x - z, y.y, y.x, y.y);\n                    break;\n                case\"right\":\n                    E.bezierCurveTo(x.x - z, x.y, y.x + z, y.y, y.x, y.y);\n                    break;\n                case\"top\":\n                    E.bezierCurveTo(x.x, x.y + z, y.x, y.y - z, y.x, y.y);\n                    break;\n                case\"bottom\":\n                    E.bezierCurveTo(x.x, x.y - z, y.x, y.y + z, y.x, y.y);\n                    break\n                }\n                E.stroke()\n            }\n        }\n    });\n    $jit.ST.Plot.NodeTypes.implement({\n        \"areachart-stacked\": {\n            render: function(W, D) {\n                var U = W.pos.getc(true), w = W.getData(\"width\"), A = W.getData(\"height\"), G = this.getAlignedPos(U, w, A), ab = G.x, aa = G.y, L = W.getData(\"stringArray\"), F = W.getData(\"dimArray\"), B = W.getData(\"valueArray\"), ad = c.reduce(B, function(aj, ak) {\n                    return aj + ak[0]\n                }, 0), ac = c.reduce(B, function(aj, ak) {\n                    return aj + ak[1]\n                }, 0), I = W.getData(\"colorArray\"), C = I.length, Y = W.getData(\"config\"), J = W.getData(\"gradient\"), ai = Y.showLabels, N = Y.showAggregates, ae = Y.Label, T = W.getData(\"prev\");\n                var M = D.getCtx(), H = W.getData(\"border\");\n                if (I && F && L) {\n                    for (var ah = 0, af = F.length, K = 0, E = 0, X = 0; ah < af; ah++) {\n                        M.fillStyle = M.strokeStyle = I[ah%C];\n                        M.save();\n                        if (J && (F[ah][0] > 0 || F[ah][1] > 0)) {\n                            var R = K + F[ah][0], P = E + F[ah][1], ag = Math.atan((P - R) / w), Z = 55;\n                            var V = M.createLinearGradient(ab + w / 2, aa - (R + P) / 2, ab + w / 2 + Z * Math.sin(ag), aa - (R + P) / 2 + Z * Math.cos(ag));\n                            var Q = c.rgbToHex(c.map(c.hexToRgb(I[ah%C].slice(1)), function(x) {\n                                return (x * 0.85)>>0\n                            }));\n                            V.addColorStop(0, I[ah%C]);\n                            V.addColorStop(1, Q);\n                            M.fillStyle = V\n                        }\n                        M.beginPath();\n                        M.moveTo(ab, aa - K);\n                        M.lineTo(ab + w, aa - E);\n                        M.lineTo(ab + w, aa - E - F[ah][1]);\n                        M.lineTo(ab, aa - K - F[ah][0]);\n                        M.lineTo(ab, aa - K);\n                        M.fill();\n                        M.restore();\n                        if (H) {\n                            var S = H.name == L[ah];\n                            var z = S ? 0.7: 0.8;\n                            var Q = c.rgbToHex(c.map(c.hexToRgb(I[ah%C].slice(1)), function(x) {\n                                return (x * z)>>0\n                            }));\n                            M.strokeStyle = Q;\n                            M.lineWidth = S ? 4 : 1;\n                            M.save();\n                            M.beginPath();\n                            if (H.index === 0) {\n                                M.moveTo(ab, aa - K);\n                                M.lineTo(ab, aa - K - F[ah][0])\n                            } else {\n                                M.moveTo(ab + w, aa - E);\n                                M.lineTo(ab + w, aa - E - F[ah][1])\n                            }\n                            M.stroke();\n                            M.restore()\n                        }\n                        K += (F[ah][0] || 0);\n                        E += (F[ah][1] || 0);\n                        if (F[ah][0] > 0) {\n                            X += (B[ah][0] || 0)\n                        }\n                    }\n                    if (T && ae.type == \"Native\") {\n                        M.save();\n                        M.beginPath();\n                        M.fillStyle = M.strokeStyle = ae.color;\n                        M.font = ae.style + \" \" + ae.size + \"px \" + ae.family;\n                        M.textAlign = \"center\";\n                        M.textBaseline = \"middle\";\n                        var O = N(W.name, ad, ac, W, X);\n                        if (O !== false) {\n                            M.fillText(O !== true ? O : X, ab, aa - K - Y.labelOffset - ae.size / 2, w)\n                        }\n                        if (ai(W.name, ad, ac, W)) {\n                            M.fillText(W.name, ab, aa + ae.size / 2 + Y.labelOffset)\n                        }\n                        M.restore()\n                    }\n                }\n            },\n            contains: function(C, E) {\n                var J = C.pos.getc(true), z = C.getData(\"width\"), N = C.getData(\"height\"), M = this.getAlignedPos(J, z, N), L = M.x, K = M.y, O = C.getData(\"dimArray\"), w = E.x - L;\n                if (E.x < L || E.x > L + z || E.y > K || E.y < K - N) {\n                    return false\n                }\n                for (var F = 0, D = O.length, I = K, A = K; F < D; F++) {\n                    var B = O[F];\n                    I -= B[0];\n                    A -= B[1];\n                    var G = I + (A - I) * w / z;\n                    if (E.y >= G) {\n                        var H =+ (w > z / 2);\n                        return {\n                            name: C.getData(\"stringArray\")[F],\n                            color: C.getData(\"colorArray\")[F],\n                            value: C.getData(\"valueArray\")[F][H],\n                            index: H\n                        }\n                    }\n                }\n                return false\n            }\n        }\n    });\n    $jit.AreaChart = new q({\n        st: null,\n        colors: [\"#416D9C\", \"#70A35E\", \"#EBB056\", \"#C74243\", \"#83548B\", \"#909291\", \"#557EAA\"],\n        selected: {},\n        busy: false,\n        initialize: function(y) {\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Margin\", \"Label\", \"AreaChart\"), {\n                Label: {\n                    type: \"Native\"\n                }\n            }, y);\n            var z = this.config.showLabels, x = c.type(z), A = this.config.showAggregates, w = c.type(A);\n            this.config.showLabels = x == \"function\" ? z : c.lambda(z);\n            this.config.showAggregates = w == \"function\" ? A : c.lambda(A);\n            this.initializeViz()\n        },\n        initializeViz: function() {\n            var x = this.config, B = this, w = x.type.split(\":\")[0], A = {};\n            var z = new $jit.ST({\n                injectInto: x.injectInto,\n                width: x.width,\n                height: x.height,\n                orientation: \"bottom\",\n                levelDistance: 0,\n                siblingOffset: 0,\n                subtreeOffset: 0,\n                withLabels: x.Label.type != \"Native\",\n                useCanvas: x.useCanvas,\n                Label: {\n                    type: x.Label.type\n                },\n                Node: {\n                    overridable: true,\n                    type: \"areachart-\" + w,\n                    align: \"left\",\n                    width: 1,\n                    height: 1\n                },\n                Edge: {\n                    type: \"none\"\n                },\n                Tips: {\n                    enable: x.Tips.enable,\n                    type: \"Native\",\n                    force: true,\n                    onShow: function(G, F, D) {\n                        var E = D;\n                        x.Tips.onShow(G, E, F)\n                    }\n                },\n                Events: {\n                    enable: true,\n                    type: \"Native\",\n                    onClick: function(F, G, D) {\n                        if (!x.filterOnClick&&!x.Events.enable) {\n                            return \n                        }\n                        var E = G.getContains();\n                        if (E) {\n                            x.filterOnClick && B.filter(E.name)\n                        }\n                        x.Events.enable && x.Events.onClick(E, G, D)\n                    },\n                    onRightClick: function(E, F, D) {\n                        if (!x.restoreOnRightClick) {\n                            return \n                        }\n                        B.restore()\n                    },\n                    onMouseMove: function(F, G, D) {\n                        if (!x.selectOnHover) {\n                            return \n                        }\n                        if (F) {\n                            var E = G.getContains();\n                            B.select(F.id, E.name, E.index)\n                        } else {\n                            B.select(false, false, false)\n                        }\n                    }\n                },\n                onCreateLabel: function(J, G) {\n                    var P = x.Label, O = G.getData(\"valueArray\"), H = c.reduce(O, function(Q, R) {\n                        return Q + R[0]\n                    }, 0), M = c.reduce(O, function(Q, R) {\n                        return Q + R[1]\n                    }, 0);\n                    if (G.getData(\"prev\")) {\n                        var L = {\n                            wrapper: document.createElement(\"div\"),\n                            aggregate: document.createElement(\"div\"),\n                            label: document.createElement(\"div\")\n                        };\n                        var D = L.wrapper, N = L.label, E = L.aggregate, F = D.style, K = N.style, I = E.style;\n                        A[G.id] = L;\n                        D.appendChild(N);\n                        D.appendChild(E);\n                        if (!x.showLabels(G.name, H, M, G)) {\n                            N.style.display = \"none\"\n                        }\n                        if (!x.showAggregates(G.name, H, M, G)) {\n                            E.style.display = \"none\"\n                        }\n                        F.position = \"relative\";\n                        F.overflow = \"visible\";\n                        F.fontSize = P.size + \"px\";\n                        F.fontFamily = P.family;\n                        F.color = P.color;\n                        F.textAlign = \"center\";\n                        I.position = K.position = \"absolute\";\n                        J.style.width = G.getData(\"width\") + \"px\";\n                        J.style.height = G.getData(\"height\") + \"px\";\n                        N.innerHTML = G.name;\n                        J.appendChild(D)\n                    }\n                },\n                onPlaceLabel: function(V, P) {\n                    if (!P.getData(\"prev\")) {\n                        return \n                    }\n                    var T = A[P.id], E = T.wrapper.style, D = T.label.style, O = T.aggregate.style, M = P.getData(\"width\"), K = P.getData(\"height\"), J = P.getData(\"dimArray\"), G = P.getData(\"valueArray\"), L = c.reduce(G, function(W, X) {\n                        return W + X[0]\n                    }, 0), H = c.reduce(G, function(W, X) {\n                        return W + X[1]\n                    }, 0), I = parseInt(E.fontSize, 10), N = V.style;\n                    if (J && G) {\n                        if (x.showLabels(P.name, L, H, P)) {\n                            D.display = \"\"\n                        } else {\n                            D.display = \"none\"\n                        }\n                        var F = x.showAggregates(P.name, L, H, P);\n                        if (F !== false) {\n                            O.display = \"\"\n                        } else {\n                            O.display = \"none\"\n                        }\n                        E.width = O.width = D.width = V.style.width = M + \"px\";\n                        O.left = D.left =- M / 2 + \"px\";\n                        for (var S = 0, Q = G.length, R = 0, U = 0; S < Q; S++) {\n                            if (J[S][0] > 0) {\n                                R += G[S][0];\n                                U += J[S][0]\n                            }\n                        }\n                        O.top = ( - I - x.labelOffset) + \"px\";\n                        D.top = (x.labelOffset + U) + \"px\";\n                        V.style.top = parseInt(V.style.top, 10) - U + \"px\";\n                        V.style.height = E.height = U + \"px\";\n                        T.aggregate.innerHTML = F !== true ? F : R\n                    }\n                }\n            });\n            var y = z.canvas.getSize(), C = x.Margin;\n            z.config.offsetY =- y.height / 2 + C.bottom + (x.showLabels && (x.labelOffset + x.Label.size));\n            z.config.offsetX = (C.right - C.left) / 2;\n            this.delegate = z;\n            this.canvas = this.delegate.canvas\n        },\n        loadJSON: function(N) {\n            var J = c.time(), B = [], M = this.delegate, Q = c.splat(N.label), I = c.splat(N.color || this.colors), O = this.config, x=!!O.type.split(\":\")[1], z = O.animate;\n            for (var K = 0, y = N.values, H = y.length; K < H-1; K++) {\n                var P = y[K], E = y[K-1], F = y[K + 1];\n                var L = c.splat(y[K].values), w = c.splat(y[K + 1].values);\n                var A = c.zip(L, w);\n                var D = 0, C = 0;\n                B.push({\n                    id: J + P.label,\n                    name: P.label,\n                    data: {\n                        value: A,\n                        \"$valueArray\": A,\n                        \"$colorArray\": I,\n                        \"$stringArray\": Q,\n                        \"$next\": F.label,\n                        \"$prev\": E ? E.label: false,\n                        \"$config\": O,\n                        \"$gradient\": x\n                    },\n                    children: []\n                })\n            }\n            var G = {\n                id: J + \"$root\",\n                name: \"\",\n                data: {\n                    \"$type\": \"none\",\n                    \"$width\": 1,\n                    \"$height\": 1\n                },\n                children: B\n            };\n            M.loadJSON(G);\n            this.normalizeDims();\n            M.compute();\n            M.select(M.root);\n            if (z) {\n                M.fx.animate({\n                    modes: [\"node-property:height:dimArray\"],\n                    duration: 1500\n                })\n            }\n        },\n        updateJSON: function(G, x) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            var D = this.delegate, F = D.graph, A = G.label && c.splat(G.label), E = G.values, w = this.config.animate, C = this, B = {};\n            for (var z = 0, y = E.length; z < y; z++) {\n                B[E[z].label] = E[z]\n            }\n            F.eachNode(function(L) {\n                var H = B[L.name], I = L.getData(\"stringArray\"), K = L.getData(\"valueArray\"), J = L.getData(\"next\");\n                if (H) {\n                    H.values = c.splat(H.values);\n                    c.each(K, function(M, N) {\n                        M[0] = H.values[N];\n                        if (A) {\n                            I[N] = A[N]\n                        }\n                    });\n                    L.setData(\"valueArray\", K)\n                }\n                if (J) {\n                    H = B[J];\n                    if (H) {\n                        c.each(K, function(M, N) {\n                            M[1] = H.values[N]\n                        })\n                    }\n                }\n            });\n            this.normalizeDims();\n            D.compute();\n            D.select(D.root);\n            if (w) {\n                D.fx.animate({\n                    modes: [\"node-property:height:dimArray\"],\n                    duration: 1500,\n                    onComplete: function() {\n                        C.busy = false;\n                        x && x.onComplete()\n                    }\n                })\n            }\n        },\n        filter: function(z, A) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            if (this.config.Tips.enable) {\n                this.delegate.tips.hide()\n            }\n            this.select(false, false, false);\n            var x = c.splat(z);\n            var w = this.delegate.graph.getNode(this.delegate.root);\n            var y = this;\n            this.normalizeDims();\n            w.eachAdjacency(function(B) {\n                var E = B.nodeTo, D = E.getData(\"dimArray\", \"end\"), C = E.getData(\"stringArray\");\n                E.setData(\"dimArray\", c.map(D, function(G, F) {\n                    return (c.indexOf(x, C[F])>-1) ? G : [0, 0]\n                }), \"end\")\n            });\n            this.delegate.fx.animate({\n                modes: [\"node-property:dimArray\"],\n                duration: 1500,\n                onComplete: function() {\n                    y.busy = false;\n                    A && A.onComplete()\n                }\n            })\n        },\n        restore: function(x) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            if (this.config.Tips.enable) {\n                this.delegate.tips.hide()\n            }\n            this.select(false, false, false);\n            this.normalizeDims();\n            var w = this;\n            this.delegate.fx.animate({\n                modes: [\"node-property:height:dimArray\"],\n                duration: 1500,\n                onComplete: function() {\n                    w.busy = false;\n                    x && x.onComplete()\n                }\n            })\n        },\n        select: function(B, x, w) {\n            if (!this.config.selectOnHover) {\n                return \n            }\n            var y = this.selected;\n            if (y.id != B || y.name != x || y.index != w) {\n                y.id = B;\n                y.name = x;\n                y.index = w;\n                this.delegate.graph.eachNode(function(C) {\n                    C.setData(\"border\", false)\n                });\n                if (B) {\n                    var A = this.delegate.graph.getNode(B);\n                    A.setData(\"border\", y);\n                    var z = w === 0 ? \"prev\": \"next\";\n                    z = A.getData(z);\n                    if (z) {\n                        A = this.delegate.graph.getByName(z);\n                        if (A) {\n                            A.setData(\"border\", {\n                                name: x,\n                                index: 1 - w\n                            })\n                        }\n                    }\n                }\n                this.delegate.plot()\n            }\n        },\n        getLegend: function() {\n            var y = {};\n            var z;\n            this.delegate.graph.getNode(this.delegate.root).eachAdjacency(function(A) {\n                z = A.nodeTo\n            });\n            var x = z.getData(\"colorArray\"), w = x.length;\n            c.each(z.getData(\"stringArray\"), function(B, A) {\n                y[B] = x[A%w]\n            });\n            return y\n        },\n        getMaxValue: function() {\n            var w = 0;\n            this.delegate.graph.eachNode(function(B) {\n                var y = B.getData(\"valueArray\"), x = 0, A = 0;\n                c.each(y, function(C) {\n                    x+=+C[0];\n                    A+=+C[1]\n                });\n                var z = A > x ? A: x;\n                w = w > z ? w : z\n            });\n            return w\n        },\n        normalizeDims: function() {\n            var C = this.delegate.graph.getNode(this.delegate.root), z = 0;\n            C.eachAdjacency(function() {\n                z++\n            });\n            var B = this.getMaxValue() || 1, F = this.delegate.canvas.getSize(), y = this.config, A = y.Margin, D = y.labelOffset + y.Label.size, w = (F.width - (A.left + A.right)) / z, x = y.animate, E = F.height - (A.top + A.bottom) - (y.showAggregates && D) - (y.showLabels && D);\n            this.delegate.graph.eachNode(function(L) {\n                var I = 0, K = 0, G = [];\n                c.each(L.getData(\"valueArray\"), function(M) {\n                    I+=+M[0];\n                    K+=+M[1];\n                    G.push([0, 0])\n                });\n                var J = K > I ? K: I;\n                L.setData(\"width\", w);\n                if (x) {\n                    L.setData(\"height\", J * E / B, \"end\");\n                    L.setData(\"dimArray\", c.map(L.getData(\"valueArray\"), function(M) {\n                        return [M[0] * E / B, M[1] * E / B]\n                    }), \"end\");\n                    var H = L.getData(\"dimArray\");\n                    if (!H) {\n                        L.setData(\"dimArray\", G)\n                    }\n                } else {\n                    L.setData(\"height\", J * E / B);\n                    L.setData(\"dimArray\", c.map(L.getData(\"valueArray\"), function(M) {\n                        return [M[0] * E / B, M[1] * E / B]\n                    }))\n                }\n            })\n        }\n    });\n    n.BarChart = {\n        $extend: true,\n        animate: true,\n        type: \"stacked\",\n        labelOffset: 3,\n        barsOffset: 0,\n        hoveredColor: \"#9fd4ff\",\n        orientation: \"horizontal\",\n        showAggregates: true,\n        showLabels: true,\n        Tips: {\n            enable: false,\n            onShow: c.empty,\n            onHide: c.empty\n        },\n        Events: {\n            enable: false,\n            onClick: c.empty\n        }\n    };\n    $jit.ST.Plot.NodeTypes.implement({\n        \"barchart-stacked\": {\n            render: function(R, C) {\n                var H = R.pos.getc(true), Q = R.getData(\"width\"), O = R.getData(\"height\"), M = this.getAlignedPos(H, Q, O), L = M.x, K = M.y, N = R.getData(\"dimArray\"), F = R.getData(\"valueArray\"), E = R.getData(\"colorArray\"), B = E.length, Y = R.getData(\"stringArray\");\n                var T = C.getCtx(), w = {}, U = R.getData(\"border\"), z = R.getData(\"gradient\"), aa = R.getData(\"config\"), A = aa.orientation == \"horizontal\", D = aa.showAggregates, P = aa.showLabels, J = aa.Label;\n                if (E && N && Y) {\n                    for (var X = 0, S = N.length, W = 0, G = 0; X < S; X++) {\n                        T.fillStyle = T.strokeStyle = E[X%B];\n                        if (z) {\n                            var Z;\n                            if (A) {\n                                Z = T.createLinearGradient(L + W + N[X] / 2, K, L + W + N[X] / 2, K + O)\n                            } else {\n                                Z = T.createLinearGradient(L, K - W - N[X] / 2, L + Q, K - W - N[X] / 2)\n                            }\n                            var V = c.rgbToHex(c.map(c.hexToRgb(E[X%B].slice(1)), function(x) {\n                                return (x * 0.5)>>0\n                            }));\n                            Z.addColorStop(0, V);\n                            Z.addColorStop(0.5, E[X%B]);\n                            Z.addColorStop(1, V);\n                            T.fillStyle = Z\n                        }\n                        if (A) {\n                            T.fillRect(L + W, K, N[X], O)\n                        } else {\n                            T.fillRect(L, K - W - N[X], Q, N[X])\n                        }\n                        if (U && U.name == Y[X]) {\n                            w.acum = W;\n                            w.dimValue = N[X]\n                        }\n                        W += (N[X] || 0);\n                        G += (F[X] || 0)\n                    }\n                    if (U) {\n                        T.save();\n                        T.lineWidth = 2;\n                        T.strokeStyle = U.color;\n                        if (A) {\n                            T.strokeRect(L + w.acum + 1, K + 1, w.dimValue-2, O-2)\n                        } else {\n                            T.strokeRect(L + 1, K - w.acum - w.dimValue + 1, Q-2, w.dimValue-2)\n                        }\n                        T.restore()\n                    }\n                    if (J.type == \"Native\") {\n                        T.save();\n                        T.fillStyle = T.strokeStyle = J.color;\n                        T.font = J.style + \" \" + J.size + \"px \" + J.family;\n                        T.textBaseline = \"middle\";\n                        var I = D(R.name, G, R);\n                        if (I !== false) {\n                            I = I !== true ? I : G;\n                            if (A) {\n                                T.textAlign = \"right\";\n                                T.fillText(I, L + W - aa.labelOffset, K + O / 2)\n                            } else {\n                                T.textAlign = \"center\";\n                                T.fillText(I, L + Q / 2, K - O - J.size / 2 - aa.labelOffset)\n                            }\n                        }\n                        if (P(R.name, G, R)) {\n                            if (A) {\n                                T.textAlign = \"center\";\n                                T.translate(L - aa.labelOffset - J.size / 2, K + O / 2);\n                                T.rotate(Math.PI / 2);\n                                T.fillText(R.name, 0, 0)\n                            } else {\n                                T.textAlign = \"center\";\n                                T.fillText(R.name, L + Q / 2, K + J.size / 2 + aa.labelOffset)\n                            }\n                        }\n                        T.restore()\n                    }\n                }\n            },\n            contains: function(D, F) {\n                var I = D.pos.getc(true), A = D.getData(\"width\"), N = D.getData(\"height\"), M = this.getAlignedPos(I, A, N), L = M.x, J = M.y, O = D.getData(\"dimArray\"), B = D.getData(\"config\"), z = F.x - L, w = B.orientation == \"horizontal\";\n                if (w) {\n                    if (F.x < L || F.x > L + A || F.y > J + N || F.y < J) {\n                        return false\n                    }\n                } else {\n                    if (F.x < L || F.x > L + A || F.y > J || F.y < J - N) {\n                        return false\n                    }\n                }\n                for (var G = 0, E = O.length, K = (w ? L : J); G < E; G++) {\n                    var C = O[G];\n                    if (w) {\n                        K += C;\n                        var H = K;\n                        if (F.x <= H) {\n                            return {\n                                name: D.getData(\"stringArray\")[G],\n                                color: D.getData(\"colorArray\")[G],\n                                value: D.getData(\"valueArray\")[G],\n                                label: D.name\n                            }\n                        }\n                    } else {\n                        K -= C;\n                        var H = K;\n                        if (F.y >= H) {\n                            return {\n                                name: D.getData(\"stringArray\")[G],\n                                color: D.getData(\"colorArray\")[G],\n                                value: D.getData(\"valueArray\")[G],\n                                label: D.name\n                            }\n                        }\n                    }\n                }\n                return false\n            }\n        },\n        \"barchart-grouped\": {\n            render: function(S, C) {\n                var I = S.pos.getc(true), R = S.getData(\"width\"), P = S.getData(\"height\"), N = this.getAlignedPos(I, R, P), M = N.x, L = N.y, O = S.getData(\"dimArray\"), G = S.getData(\"valueArray\"), Y = G.length, F = S.getData(\"colorArray\"), B = F.length, aa = S.getData(\"stringArray\");\n                var U = C.getCtx(), w = {}, V = S.getData(\"border\"), z = S.getData(\"gradient\"), ac = S.getData(\"config\"), A = ac.orientation == \"horizontal\", E = ac.showAggregates, Q = ac.showLabels, K = ac.Label, D = (A ? P : R) / Y;\n                if (F && O && aa) {\n                    for (var Z = 0, T = Y, X = 0, H = 0; Z < T; Z++) {\n                        U.fillStyle = U.strokeStyle = F[Z%B];\n                        if (z) {\n                            var ab;\n                            if (A) {\n                                ab = U.createLinearGradient(M + O[Z] / 2, L + D * Z, M + O[Z] / 2, L + D * (Z + 1))\n                            } else {\n                                ab = U.createLinearGradient(M + D * Z, L - O[Z] / 2, M + D * (Z + 1), L - O[Z] / 2)\n                            }\n                            var W = c.rgbToHex(c.map(c.hexToRgb(F[Z%B].slice(1)), function(x) {\n                                return (x * 0.5)>>0\n                            }));\n                            ab.addColorStop(0, W);\n                            ab.addColorStop(0.5, F[Z%B]);\n                            ab.addColorStop(1, W);\n                            U.fillStyle = ab\n                        }\n                        if (A) {\n                            U.fillRect(M, L + D * Z, O[Z], D)\n                        } else {\n                            U.fillRect(M + D * Z, L - O[Z], D, O[Z])\n                        }\n                        if (V && V.name == aa[Z]) {\n                            w.acum = D * Z;\n                            w.dimValue = O[Z]\n                        }\n                        X += (O[Z] || 0);\n                        H += (G[Z] || 0)\n                    }\n                    if (V) {\n                        U.save();\n                        U.lineWidth = 2;\n                        U.strokeStyle = V.color;\n                        if (A) {\n                            U.strokeRect(M + 1, L + w.acum + 1, w.dimValue-2, D-2)\n                        } else {\n                            U.strokeRect(M + w.acum + 1, L - w.dimValue + 1, D-2, w.dimValue-2)\n                        }\n                        U.restore()\n                    }\n                    if (K.type == \"Native\") {\n                        U.save();\n                        U.fillStyle = U.strokeStyle = K.color;\n                        U.font = K.style + \" \" + K.size + \"px \" + K.family;\n                        U.textBaseline = \"middle\";\n                        var J = E(S.name, H, S);\n                        if (J !== false) {\n                            J = J !== true ? J : H;\n                            if (A) {\n                                U.textAlign = \"right\";\n                                U.fillText(J, M + Math.max.apply(null, O) - ac.labelOffset, L + P / 2)\n                            } else {\n                                U.textAlign = \"center\";\n                                U.fillText(J, M + R / 2, L - Math.max.apply(null, O) - K.size / 2 - ac.labelOffset)\n                            }\n                        }\n                        if (Q(S.name, H, S)) {\n                            if (A) {\n                                U.textAlign = \"center\";\n                                U.translate(M - ac.labelOffset - K.size / 2, L + P / 2);\n                                U.rotate(Math.PI / 2);\n                                U.fillText(S.name, 0, 0)\n                            } else {\n                                U.textAlign = \"center\";\n                                U.fillText(S.name, M + R / 2, L + K.size / 2 + ac.labelOffset)\n                            }\n                        }\n                        U.restore()\n                    }\n                }\n            },\n            contains: function(J, F) {\n                var B = J.pos.getc(true), I = J.getData(\"width\"), H = J.getData(\"height\"), E = this.getAlignedPos(B, I, H), D = E.x, C = E.y, G = J.getData(\"dimArray\"), M = G.length, P = J.getData(\"config\"), A = F.x - D, w = P.orientation == \"horizontal\", z = (w ? H : I) / M;\n                if (w) {\n                    if (F.x < D || F.x > D + I || F.y > C + H || F.y < C) {\n                        return false\n                    }\n                } else {\n                    if (F.x < D || F.x > D + I || F.y > C || F.y < C - H) {\n                        return false\n                    }\n                }\n                for (var L = 0, K = G.length; L < K; L++) {\n                    var O = G[L];\n                    if (w) {\n                        var N = C + z * L;\n                        if (F.x <= D + O && F.y >= N && F.y <= N + z) {\n                            return {\n                                name: J.getData(\"stringArray\")[L],\n                                color: J.getData(\"colorArray\")[L],\n                                value: J.getData(\"valueArray\")[L],\n                                label: J.name\n                            }\n                        }\n                    } else {\n                        var N = D + z * L;\n                        if (F.x >= N && F.x <= N + z && F.y >= C - O) {\n                            return {\n                                name: J.getData(\"stringArray\")[L],\n                                color: J.getData(\"colorArray\")[L],\n                                value: J.getData(\"valueArray\")[L],\n                                label: J.name\n                            }\n                        }\n                    }\n                }\n                return false\n            }\n        }\n    });\n    $jit.BarChart = new q({\n        st: null,\n        colors: [\"#416D9C\", \"#70A35E\", \"#EBB056\", \"#C74243\", \"#83548B\", \"#909291\", \"#557EAA\"],\n        selected: {},\n        busy: false,\n        initialize: function(y) {\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Margin\", \"Label\", \"BarChart\"), {\n                Label: {\n                    type: \"Native\"\n                }\n            }, y);\n            var z = this.config.showLabels, x = c.type(z), A = this.config.showAggregates, w = c.type(A);\n            this.config.showLabels = x == \"function\" ? z : c.lambda(z);\n            this.config.showAggregates = w == \"function\" ? A : c.lambda(A);\n            this.initializeViz()\n        },\n        initializeViz: function() {\n            var x = this.config, B = this;\n            var w = x.type.split(\":\")[0], D = x.orientation == \"horizontal\", A = {};\n            var z = new $jit.ST({\n                injectInto: x.injectInto,\n                width: x.width,\n                height: x.height,\n                orientation: D ? \"left\": \"bottom\",\n                levelDistance: 0,\n                siblingOffset: x.barsOffset,\n                subtreeOffset: 0,\n                withLabels: x.Label.type != \"Native\",\n                useCanvas: x.useCanvas,\n                Label: {\n                    type: x.Label.type\n                },\n                Node: {\n                    overridable: true,\n                    type: \"barchart-\" + w,\n                    align: \"left\",\n                    width: 1,\n                    height: 1\n                },\n                Edge: {\n                    type: \"none\"\n                },\n                Tips: {\n                    enable: x.Tips.enable,\n                    type: \"Native\",\n                    force: true,\n                    onShow: function(H, G, E) {\n                        var F = E;\n                        x.Tips.onShow(H, F, G)\n                    }\n                },\n                Events: {\n                    enable: true,\n                    type: \"Native\",\n                    onClick: function(G, H, E) {\n                        if (!x.Events.enable) {\n                            return \n                        }\n                        var F = H.getContains();\n                        x.Events.onClick(F, H, E)\n                    },\n                    onMouseMove: function(G, H, E) {\n                        if (!x.hoveredColor) {\n                            return \n                        }\n                        if (G) {\n                            var F = H.getContains();\n                            B.select(G.id, F.name, F.index)\n                        } else {\n                            B.select(false, false, false)\n                        }\n                    }\n                },\n                onCreateLabel: function(J, H) {\n                    var P = x.Label, N = H.getData(\"valueArray\"), M = c.reduce(N, function(Q, R) {\n                        return Q + R\n                    }, 0);\n                    var L = {\n                        wrapper: document.createElement(\"div\"),\n                        aggregate: document.createElement(\"div\"),\n                        label: document.createElement(\"div\")\n                    };\n                    var E = L.wrapper, O = L.label, F = L.aggregate, G = E.style, K = O.style, I = F.style;\n                    A[H.id] = L;\n                    E.appendChild(O);\n                    E.appendChild(F);\n                    if (!x.showLabels(H.name, M, H)) {\n                        K.display = \"none\"\n                    }\n                    if (!x.showAggregates(H.name, M, H)) {\n                        I.display = \"none\"\n                    }\n                    G.position = \"relative\";\n                    G.overflow = \"visible\";\n                    G.fontSize = P.size + \"px\";\n                    G.fontFamily = P.family;\n                    G.color = P.color;\n                    G.textAlign = \"center\";\n                    I.position = K.position = \"absolute\";\n                    J.style.width = H.getData(\"width\") + \"px\";\n                    J.style.height = H.getData(\"height\") + \"px\";\n                    I.left = K.left = \"0px\";\n                    O.innerHTML = H.name;\n                    J.appendChild(E)\n                },\n                onPlaceLabel: function(U, P) {\n                    if (!A[P.id]) {\n                        return \n                    }\n                    var T = A[P.id], G = T.wrapper.style, E = T.label.style, O = T.aggregate.style, V = x.type.split(\":\")[0] == \"grouped\", F = x.orientation == \"horizontal\", K = P.getData(\"dimArray\"), I = P.getData(\"valueArray\"), M = (V && F) ? Math.max.apply(null, K): P.getData(\"width\"), L = (V&&!F) ? Math.max.apply(null, K): P.getData(\"height\"), J = parseInt(G.fontSize, 10), N = U.style;\n                    if (K && I) {\n                        G.width = O.width = E.width = U.style.width = M + \"px\";\n                        for (var S = 0, Q = I.length, R = 0; S < Q; S++) {\n                            if (K[S] > 0) {\n                                R += I[S]\n                            }\n                        }\n                        if (x.showLabels(P.name, R, P)) {\n                            E.display = \"\"\n                        } else {\n                            E.display = \"none\"\n                        }\n                        var H = x.showAggregates(P.name, R, P);\n                        if (H !== false) {\n                            O.display = \"\"\n                        } else {\n                            O.display = \"none\"\n                        }\n                        if (x.orientation == \"horizontal\") {\n                            O.textAlign = \"right\";\n                            E.textAlign = \"left\";\n                            E.textIndex = O.textIndent = x.labelOffset + \"px\";\n                            O.top = E.top = (L - J) / 2 + \"px\";\n                            U.style.height = G.height = L + \"px\"\n                        } else {\n                            O.top = ( - J - x.labelOffset) + \"px\";\n                            E.top = (x.labelOffset + L) + \"px\";\n                            U.style.top = parseInt(U.style.top, 10) - L + \"px\";\n                            U.style.height = G.height = L + \"px\"\n                        }\n                        T.aggregate.innerHTML = H !== true ? H : R\n                    }\n                }\n            });\n            var y = z.canvas.getSize(), C = x.Margin;\n            if (D) {\n                z.config.offsetX = y.width / 2 - C.left - (x.showLabels && (x.labelOffset + x.Label.size));\n                z.config.offsetY = (C.bottom - C.top) / 2\n            } else {\n                z.config.offsetY =- y.height / 2 + C.bottom + (x.showLabels && (x.labelOffset + x.Label.size));\n                z.config.offsetX = (C.right - C.left) / 2\n            }\n            this.delegate = z;\n            this.canvas = this.delegate.canvas\n        },\n        loadJSON: function(K) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            var H = c.time(), C = [], J = this.delegate, N = c.splat(K.label), G = c.splat(K.color || this.colors), L = this.config, w=!!L.type.split(\":\")[1], z = L.animate, y = L.orientation == \"horizontal\", A = this;\n            for (var I = 0, x = K.values, E = x.length; I < E; I++) {\n                var M = x[I];\n                var B = c.splat(x[I].values);\n                var F = 0;\n                C.push({\n                    id: H + M.label,\n                    name: M.label,\n                    data: {\n                        value: B,\n                        \"$valueArray\": B,\n                        \"$colorArray\": G,\n                        \"$stringArray\": N,\n                        \"$gradient\": w,\n                        \"$config\": L\n                    },\n                    children: []\n                })\n            }\n            var D = {\n                id: H + \"$root\",\n                name: \"\",\n                data: {\n                    \"$type\": \"none\",\n                    \"$width\": 1,\n                    \"$height\": 1\n                },\n                children: C\n            };\n            J.loadJSON(D);\n            this.normalizeDims();\n            J.compute();\n            J.select(J.root);\n            if (z) {\n                if (y) {\n                    J.fx.animate({\n                        modes: [\"node-property:width:dimArray\"],\n                        duration: 1500,\n                        onComplete: function() {\n                            A.busy = false\n                        }\n                    })\n                } else {\n                    J.fx.animate({\n                        modes: [\"node-property:height:dimArray\"],\n                        duration: 1500,\n                        onComplete: function() {\n                            A.busy = false\n                        }\n                    })\n                }\n            } else {\n                this.busy = false\n            }\n        },\n        updateJSON: function(y, C) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            this.select(false, false, false);\n            var z = this.delegate;\n            var B = z.graph;\n            var x = y.values;\n            var w = this.config.animate;\n            var A = this;\n            var D = this.config.orientation == \"horizontal\";\n            c.each(x, function(E) {\n                var F = B.getByName(E.label);\n                if (F) {\n                    F.setData(\"valueArray\", c.splat(E.values));\n                    if (y.label) {\n                        F.setData(\"stringArray\", c.splat(y.label))\n                    }\n                }\n            });\n            this.normalizeDims();\n            z.compute();\n            z.select(z.root);\n            if (w) {\n                if (D) {\n                    z.fx.animate({\n                        modes: [\"node-property:width:dimArray\"],\n                        duration: 1500,\n                        onComplete: function() {\n                            A.busy = false;\n                            C && C.onComplete()\n                        }\n                    })\n                } else {\n                    z.fx.animate({\n                        modes: [\"node-property:height:dimArray\"],\n                        duration: 1500,\n                        onComplete: function() {\n                            A.busy = false;\n                            C && C.onComplete()\n                        }\n                    })\n                }\n            }\n        },\n        select: function(y, w) {\n            if (!this.config.hoveredColor) {\n                return \n            }\n            var x = this.selected;\n            if (x.id != y || x.name != w) {\n                x.id = y;\n                x.name = w;\n                x.color = this.config.hoveredColor;\n                this.delegate.graph.eachNode(function(z) {\n                    if (y == z.id) {\n                        z.setData(\"border\", x)\n                    } else {\n                        z.setData(\"border\", false)\n                    }\n                });\n                this.delegate.plot()\n            }\n        },\n        getLegend: function() {\n            var y = {};\n            var z;\n            this.delegate.graph.getNode(this.delegate.root).eachAdjacency(function(A) {\n                z = A.nodeTo\n            });\n            var x = z.getData(\"colorArray\"), w = x.length;\n            c.each(z.getData(\"stringArray\"), function(B, A) {\n                y[B] = x[A%w]\n            });\n            return y\n        },\n        getMaxValue: function() {\n            var x = 0, w = this.config.type.split(\":\")[0] == \"stacked\";\n            this.delegate.graph.eachNode(function(A) {\n                var y = A.getData(\"valueArray\"), z = 0;\n                if (!y) {\n                    return \n                }\n                if (w) {\n                    c.each(y, function(B) {\n                        z+=+B\n                    })\n                } else {\n                    z = Math.max.apply(null, y)\n                }\n                x = x > z ? x : z\n            });\n            return x\n        },\n        setBarType: function(w) {\n            this.config.type = w;\n            this.delegate.config.Node.type = \"barchart-\" + w.split(\":\")[0]\n        },\n        normalizeDims: function() {\n            var G = this.delegate.graph.getNode(this.delegate.root), B = 0;\n            G.eachAdjacency(function() {\n                B++\n            });\n            var D = this.getMaxValue() || 1, J = this.delegate.canvas.getSize(), z = this.config, C = z.Margin, H = C.left + C.right, A = C.top + C.bottom, x = z.orientation == \"horizontal\", w = (J[x ? \"height\": \"width\"] - (x ? A : H) - (B-1) * z.barsOffset) / B, y = z.animate, I = J[x ? \"width\": \"height\"] - (x ? H : A) - (!x && z.showAggregates && (z.Label.size + z.labelOffset)) - (z.showLabels && (z.Label.size + z.labelOffset)), F = x ? \"height\": \"width\", E = x ? \"width\": \"height\";\n            this.delegate.graph.eachNode(function(N) {\n                var M = 0, K = [];\n                c.each(N.getData(\"valueArray\"), function(O) {\n                    M+=+O;\n                    K.push(0)\n                });\n                N.setData(F, w);\n                if (y) {\n                    N.setData(E, M * I / D, \"end\");\n                    N.setData(\"dimArray\", c.map(N.getData(\"valueArray\"), function(O) {\n                        return O * I / D\n                    }), \"end\");\n                    var L = N.getData(\"dimArray\");\n                    if (!L) {\n                        N.setData(\"dimArray\", K)\n                    }\n                } else {\n                    N.setData(E, M * I / D);\n                    N.setData(\"dimArray\", c.map(N.getData(\"valueArray\"), function(O) {\n                        return O * I / D\n                    }))\n                }\n            })\n        }\n    });\n    n.PieChart = {\n        $extend: true,\n        animate: true,\n        offset: 25,\n        sliceOffset: 0,\n        labelOffset: 3,\n        type: \"stacked\",\n        hoveredColor: \"#9fd4ff\",\n        Events: {\n            enable: false,\n            onClick: c.empty\n        },\n        Tips: {\n            enable: false,\n            onShow: c.empty,\n            onHide: c.empty\n        },\n        showLabels: true,\n        resizeLabels: false,\n        updateHeights: false\n    };\n    g.Radial = new q({\n        compute: function(x) {\n            var y = c.splat(x || [\"current\", \"start\", \"end\"]);\n            f.compute(this.graph, y, this.config);\n            this.graph.computeLevels(this.root, 0, \"ignore\");\n            var w = this.createLevelDistanceFunc();\n            this.computeAngularWidths(y);\n            this.computePositions(y, w)\n        },\n        computePositions: function(D, A) {\n            var F = D;\n            var E = this.graph;\n            var B = E.getNode(this.root);\n            var C = this.parent;\n            var w = this.config;\n            for (var y = 0, x = F.length; y < x; y++) {\n                var z = F[y];\n                B.setPos(k(0, 0), z);\n                B.setData(\"span\", Math.PI * 2, z)\n            }\n            B.angleSpan = {\n                begin: 0,\n                end: 2 * Math.PI\n            };\n            E.eachBFS(this.root, function(K) {\n                var Q = K.angleSpan.end - K.angleSpan.begin;\n                var S = K.angleSpan.begin;\n                var R = A(K);\n                var T = 0, G = [], J = {};\n                K.eachSubnode(function(W) {\n                    T += W._treeAngularWidth;\n                    for (var X = 0, V = F.length; X < V; X++) {\n                        var Z = F[X], Y = W.getData(\"dim\", Z);\n                        J[Z] = (Z in J) ? (Y > J[Z] ? Y : J[Z]) : Y\n                    }\n                    G.push(W)\n                }, \"ignore\");\n                if (C && C.id == K.id && G.length > 0 && G[0].dist) {\n                    G.sort(function(W, V) {\n                        return (W.dist >= V.dist) - (W.dist <= V.dist)\n                    })\n                }\n                for (var M = 0, O = G.length; M < O; M++) {\n                    var I = G[M];\n                    if (!I._flag) {\n                        var U = I._treeAngularWidth / T * Q;\n                        var H = S + U / 2;\n                        for (var N = 0, L = F.length; N < L; N++) {\n                            var P = F[N];\n                            I.setPos(k(H, R), P);\n                            I.setData(\"span\", U, P);\n                            I.setData(\"dim-quotient\", I.getData(\"dim\", P) / J[P], P)\n                        }\n                        I.angleSpan = {\n                            begin: S,\n                            end: S + U\n                        };\n                        S += U\n                    }\n                }\n            }, \"ignore\")\n        },\n        setAngularWidthForNodes: function(w) {\n            this.graph.eachBFS(this.root, function(z, x) {\n                var y = z.getData(\"angularWidth\", w[0]) || 5;\n                z._angularWidth = y / x\n            }, \"ignore\")\n        },\n        setSubtreesAngularWidth: function() {\n            var w = this;\n            this.graph.eachNode(function(x) {\n                w.setSubtreeAngularWidth(x)\n            }, \"ignore\")\n        },\n        setSubtreeAngularWidth: function(z) {\n            var y = this, x = z._angularWidth, w = 0;\n            z.eachSubnode(function(A) {\n                y.setSubtreeAngularWidth(A);\n                w += A._treeAngularWidth\n            }, \"ignore\");\n            z._treeAngularWidth = Math.max(x, w)\n        },\n        computeAngularWidths: function(w) {\n            this.setAngularWidthForNodes(w);\n            this.setSubtreesAngularWidth()\n        }\n    });\n    $jit.Sunburst = new q({\n        Implements: [d, o, g.Radial],\n        initialize: function(w) {\n            var y = $jit.Sunburst;\n            var x = {\n                interpolation: \"linear\",\n                levelDistance: 100,\n                Node: {\n                    type: \"multipie\",\n                    height: 0\n                },\n                Edge: {\n                    type: \"none\"\n                },\n                Label: {\n                    textAlign: \"start\",\n                    textBaseline: \"middle\"\n                }\n            };\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Node\", \"Edge\", \"Fx\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Controller\", \"Label\"), x, w);\n            var z = this.config;\n            if (z.useCanvas) {\n                this.canvas = z.useCanvas;\n                this.config.labelContainer = this.canvas.id + \"-label\"\n            } else {\n                if (z.background) {\n                    z.background = c.merge({\n                        type: \"Circles\"\n                    }, z.background)\n                }\n                this.canvas = new l(this, z);\n                this.config.labelContainer = (typeof z.injectInto == \"string\" ? z.injectInto : z.injectInto.id) + \"-label\"\n            }\n            this.graphOptions = {\n                klass: b,\n                Node: {\n                    selected: false,\n                    exist: true,\n                    drawn: true\n                }\n            };\n            this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge);\n            this.labels = new y.Label[z.Label.type](this);\n            this.fx = new y.Plot(this, y);\n            this.op = new y.Op(this);\n            this.json = null;\n            this.root = null;\n            this.rotated = null;\n            this.busy = false;\n            this.initializeExtras()\n        },\n        createLevelDistanceFunc: function() {\n            var w = this.config.levelDistance;\n            return function(x) {\n                return (x._depth + 1) * w\n            }\n        },\n        refresh: function() {\n            this.compute();\n            this.plot()\n        },\n        reposition: function() {\n            this.compute(\"end\")\n        },\n        rotate: function(y, z, x) {\n            var w = y.getPos(x.property || \"current\").getp(true).theta;\n            this.rotated = y;\n            this.rotateAngle( - w, z, x)\n        },\n        rotateAngle: function(y, B, x) {\n            var z = this;\n            var w = c.merge(this.config, x || {}, {\n                modes: [\"polar\"]\n            });\n            var A = x.property || (B === \"animate\" ? \"end\" : \"current\");\n            if (B === \"animate\") {\n                this.fx.animation.pause()\n            }\n            this.graph.eachNode(function(D) {\n                var C = D.getPos(A);\n                C.theta += y;\n                if (C.theta < 0) {\n                    C.theta += Math.PI * 2\n                }\n            });\n            if (B == \"animate\") {\n                this.fx.animate(w)\n            } else {\n                if (B == \"replot\") {\n                    this.fx.plot();\n                    this.busy = false\n                }\n            }\n        },\n        plot: function() {\n            this.fx.plot()\n        }\n    });\n    $jit.Sunburst.$extend = true;\n    (function(w) {\n        w.Op = new q({\n            Implements: e.Op\n        });\n        w.Plot = new q({\n            Implements: e.Plot\n        });\n        w.Label = {};\n        w.Label.Native = new q({\n            Implements: e.Label.Native,\n            initialize: function(x) {\n                this.viz = x;\n                this.label = x.config.Label;\n                this.config = x.config\n            },\n            renderLabel: function(C, E, G) {\n                var N = E.getData(\"span\");\n                if (N < Math.PI / 2 && Math.tan(N) * this.config.levelDistance * E._depth < 10) {\n                    return \n                }\n                var O = C.getCtx();\n                var A = O.measureText(E.name);\n                if (E.id == this.viz.root) {\n                    var M =- A.width / 2, K = 0, L = 0;\n                    var z = 0\n                } else {\n                    var D = 5;\n                    var z = G.levelDistance - D;\n                    var J = E.pos.clone();\n                    J.rho += D;\n                    var B = J.getp(true);\n                    var H = J.getc(true);\n                    var M = H.x, K = H.y;\n                    var F = Math.PI;\n                    var I = (B.theta > F / 2 && B.theta < 3 * F / 2);\n                    var L = I ? B.theta + F: B.theta;\n                    if (I) {\n                        M -= Math.abs(Math.cos(B.theta) * A.width);\n                        K += Math.sin(B.theta) * A.width\n                    } else {\n                        if (E.id == this.viz.root) {\n                            M -= A.width / 2\n                        }\n                    }\n                }\n                O.save();\n                O.translate(M, K);\n                O.rotate(L);\n                O.fillText(E.name, 0, 0);\n                O.restore()\n            }\n        });\n        w.Label.SVG = new q({\n            Implements: e.Label.SVG,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(N, C, E) {\n                var J = C.pos.getc(true), M = this.viz, A = this.viz.canvas;\n                var F = A.getSize();\n                var B = {\n                    x: Math.round(J.x + F.width / 2),\n                    y: Math.round(J.y + F.height / 2)\n                };\n                N.setAttribute(\"x\", B.x);\n                N.setAttribute(\"y\", B.y);\n                var G = N.getBBox();\n                if (G) {\n                    var L = N.getAttribute(\"x\");\n                    var I = N.getAttribute(\"y\");\n                    var z = C.pos.getp(true);\n                    var D = Math.PI;\n                    var H = (z.theta > D / 2 && z.theta < 3 * D / 2);\n                    if (H) {\n                        N.setAttribute(\"x\", L - G.width);\n                        N.setAttribute(\"y\", I - G.height)\n                    } else {\n                        if (C.id == M.root) {\n                            N.setAttribute(\"x\", L - G.width / 2)\n                        }\n                    }\n                    var K = H ? z.theta + D: z.theta;\n                    if (C._depth) {\n                        N.setAttribute(\"transform\", \"rotate(\" + K * 360 / (2 * D) + \" \" + L + \" \" + I + \")\")\n                    }\n                }\n                E.onPlaceLabel(N, C)\n            }\n        });\n        w.Label.HTML = new q({\n            Implements: e.Label.HTML,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(G, A, C) {\n                var E = A.pos.clone(), y = this.viz.canvas, F = A.getData(\"height\"), B = ((F || A._depth == 0) ? F : this.viz.config.levelDistance) / 2, D = y.getSize();\n                E.rho += B;\n                E = E.getc(true);\n                var z = {\n                    x: Math.round(E.x + D.width / 2),\n                    y: Math.round(E.y + D.height / 2)\n                };\n                var x = G.style;\n                x.left = z.x + \"px\";\n                x.top = z.y + \"px\";\n                x.display = this.fitsInCanvas(z, y) ? \"\" : \"none\";\n                C.onPlaceLabel(G, A)\n            }\n        });\n        w.Plot.NodeTypes = new q({\n            none: {\n                render: c.empty,\n                contains: c.lambda(false),\n                anglecontains: function(B, D) {\n                    var A = B.getData(\"span\") / 2, y = B.pos.theta;\n                    var z = y - A, x = y + A;\n                    if (z < 0) {\n                        z += Math.PI * 2\n                    }\n                    var C = Math.atan2(D.y, D.x);\n                    if (C < 0) {\n                        C += Math.PI * 2\n                    }\n                    if (z > x) {\n                        return (C > z && C <= Math.PI * 2) || C < x\n                    } else {\n                        return C > z && C < x\n                    }\n                }\n            },\n            pie: {\n                render: function(C, A) {\n                    var G = C.getData(\"span\") / 2, z = C.pos.theta;\n                    var B = z - G, D = z + G;\n                    var F = C.pos.getp(true);\n                    var x = new b(F.rho, B);\n                    var y = x.getc(true);\n                    x.theta = D;\n                    var E = x.getc(true);\n                    var H = A.getCtx();\n                    H.beginPath();\n                    H.moveTo(0, 0);\n                    H.lineTo(y.x, y.y);\n                    H.moveTo(0, 0);\n                    H.lineTo(E.x, E.y);\n                    H.moveTo(0, 0);\n                    H.arc(0, 0, F.rho * C.getData(\"dim-quotient\"), B, D, false);\n                    H.fill()\n                },\n                contains: function(z, B) {\n                    if (this.nodeTypes.none.anglecontains.call(this, z, B)) {\n                        var x = Math.sqrt(B.x * B.x + B.y * B.y);\n                        var y = this.config.levelDistance, A = z._depth;\n                        return (x <= y * A)\n                    }\n                    return false\n                }\n            },\n            multipie: {\n                render: function(D, B) {\n                    var K = D.getData(\"height\");\n                    var E = K ? K: this.config.levelDistance;\n                    var J = D.getData(\"span\") / 2, A = D.pos.theta;\n                    var C = A - J, G = A + J;\n                    var I = D.pos.getp(true);\n                    var y = new b(I.rho, C);\n                    var z = y.getc(true);\n                    y.theta = G;\n                    var H = y.getc(true);\n                    y.rho += E;\n                    var x = y.getc(true);\n                    y.theta = C;\n                    var F = y.getc(true);\n                    var L = B.getCtx();\n                    L.moveTo(0, 0);\n                    L.beginPath();\n                    L.arc(0, 0, I.rho, C, G, false);\n                    L.arc(0, 0, I.rho + E, G, C, true);\n                    L.moveTo(z.x, z.y);\n                    L.lineTo(F.x, F.y);\n                    L.moveTo(H.x, H.y);\n                    L.lineTo(x.x, x.y);\n                    L.fill();\n                    if (D.collapsed) {\n                        L.save();\n                        L.lineWidth = 2;\n                        L.moveTo(0, 0);\n                        L.beginPath();\n                        L.arc(0, 0, I.rho + E + 5, G-0.01, C + 0.01, true);\n                        L.stroke();\n                        L.restore()\n                    }\n                },\n                contains: function(A, D) {\n                    if (this.nodeTypes.none.anglecontains.call(this, A, D)) {\n                        var y = Math.sqrt(D.x * D.x + D.y * D.y);\n                        var x = A.getData(\"height\");\n                        var B = x ? x: this.config.levelDistance;\n                        var z = this.config.levelDistance, C = A._depth;\n                        return (y >= z * C) && (y <= (z * C + B))\n                    }\n                    return false\n                }\n            },\n            \"gradient-multipie\": {\n                render: function(A, x) {\n                    var F = x.getCtx();\n                    var E = A.getData(\"height\");\n                    var B = E ? E: this.config.levelDistance;\n                    var y = F.createRadialGradient(0, 0, A.getPos().rho, 0, 0, A.getPos().rho + B);\n                    var D = c.hexToRgb(A.getData(\"color\")), C = [];\n                    c.each(D, function(G) {\n                        C.push(parseInt(G * 0.5, 10))\n                    });\n                    var z = c.rgbToHex(C);\n                    y.addColorStop(0, z);\n                    y.addColorStop(1, A.getData(\"color\"));\n                    F.fillStyle = y;\n                    this.nodeTypes.multipie.render.call(this, A, x)\n                },\n                contains: function(x, y) {\n                    return this.nodeTypes.multipie.contains.call(this, x, y)\n                }\n            },\n            \"gradient-pie\": {\n                render: function(C, z) {\n                    var x = z.getCtx();\n                    var D = x.createRadialGradient(0, 0, 0, 0, 0, C.getPos().rho);\n                    var B = c.hexToRgb(C.getData(\"color\")), y = [];\n                    c.each(B, function(E) {\n                        y.push(parseInt(E * 0.5, 10))\n                    });\n                    var A = c.rgbToHex(y);\n                    D.addColorStop(1, A);\n                    D.addColorStop(0, C.getData(\"color\"));\n                    x.fillStyle = D;\n                    this.nodeTypes.pie.render.call(this, C, z)\n                },\n                contains: function(x, y) {\n                    return this.nodeTypes.pie.contains.call(this, x, y)\n                }\n            }\n        });\n        w.Plot.EdgeTypes = new q({\n            none: c.empty,\n            line: {\n                render: function(x, y) {\n                    var A = x.nodeFrom.pos.getc(true), z = x.nodeTo.pos.getc(true);\n                    this.edgeHelper.line.render(A, z, y)\n                },\n                contains: function(x, A) {\n                    var z = x.nodeFrom.pos.getc(true), y = x.nodeTo.pos.getc(true);\n                    return this.edgeHelper.line.contains(z, y, A, this.edge.epsilon)\n                }\n            },\n            arrow: {\n                render: function(y, z) {\n                    var D = y.nodeFrom.pos.getc(true), C = y.nodeTo.pos.getc(true), B = y.getData(\"dim\"), A = y.data.$direction, x = (A && A.length > 1 && A[0] != y.nodeFrom.id);\n                    this.edgeHelper.arrow.render(D, C, B, x, z)\n                },\n                contains: function(x, A) {\n                    var z = x.nodeFrom.pos.getc(true), y = x.nodeTo.pos.getc(true);\n                    return this.edgeHelper.arrow.contains(z, y, A, this.edge.epsilon)\n                }\n            },\n            hyperline: {\n                render: function(x, y) {\n                    var B = x.nodeFrom.pos.getc(), A = x.nodeTo.pos.getc(), z = Math.max(B.norm(), A.norm());\n                    this.edgeHelper.hyperline.render(B.$scale(1 / z), A.$scale(1 / z), z, y)\n                },\n                contains: c.lambda(false)\n            }\n        })\n    })($jit.Sunburst);\n    $jit.Sunburst.Plot.NodeTypes.implement({\n        \"piechart-stacked\": {\n            render: function(U, A) {\n                var T = U.pos.getp(true), C = U.getData(\"dimArray\"), S = U.getData(\"valueArray\"), G = U.getData(\"colorArray\"), z = G.length, M = U.getData(\"stringArray\"), P = U.getData(\"span\") / 2, K = U.pos.theta, F = K - P, J = K + P, R = new b;\n                var N = A.getCtx(), L = {}, I = U.getData(\"gradient\"), D = U.getData(\"border\"), Z = U.getData(\"config\"), ai = Z.showLabels, Y = Z.resizeLabels, ab = Z.Label;\n                var ae = Z.sliceOffset * Math.cos((F + J) / 2);\n                var E = Z.sliceOffset * Math.sin((F + J) / 2);\n                if (G && C && M) {\n                    for (var af = 0, ac = C.length, w = 0, X = 0; af < ac; af++) {\n                        var B = C[af], ag = G[af%z];\n                        if (B <= 0) {\n                            continue\n                        }\n                        N.fillStyle = N.strokeStyle = ag;\n                        if (I && B) {\n                            var ad = N.createRadialGradient(ae, E, w + Z.sliceOffset, ae, E, w + B + Z.sliceOffset);\n                            var x = c.hexToRgb(ag), W = c.map(x, function(al) {\n                                return (al * 0.8)>>0\n                            }), y = c.rgbToHex(W);\n                            ad.addColorStop(0, ag);\n                            ad.addColorStop(0.5, ag);\n                            ad.addColorStop(1, y);\n                            N.fillStyle = ad\n                        }\n                        R.rho = w + Z.sliceOffset;\n                        R.theta = F;\n                        var ah = R.getc(true);\n                        R.theta = J;\n                        var O = R.getc(true);\n                        R.rho += B;\n                        var aj = R.getc(true);\n                        R.theta = F;\n                        var Q = R.getc(true);\n                        N.beginPath();\n                        N.arc(ae, E, w + 0.01, F, J, false);\n                        N.arc(ae, E, w + B + 0.01, J, F, true);\n                        N.fill();\n                        if (D && D.name == M[af]) {\n                            L.acum = w;\n                            L.dimValue = C[af];\n                            L.begin = F;\n                            L.end = J\n                        }\n                        w += (B || 0);\n                        X += (S[af] || 0)\n                    }\n                    if (D) {\n                        N.save();\n                        N.globalCompositeOperation = \"source-over\";\n                        N.lineWidth = 2;\n                        N.strokeStyle = D.color;\n                        var aa = F < J ? 1: -1;\n                        N.beginPath();\n                        N.arc(ae, E, L.acum + 0.01 + 1, L.begin, L.end, false);\n                        N.arc(ae, E, L.acum + L.dimValue + 0.01-1, L.end, L.begin, true);\n                        N.closePath();\n                        N.stroke();\n                        N.restore()\n                    }\n                    if (ai && ab.type == \"Native\") {\n                        N.save();\n                        N.fillStyle = N.strokeStyle = ab.color;\n                        var V = Y ? U.getData(\"normalizedDim\"): 1, H = (ab.size * V)>>0;\n                        H = H<+Y?+Y : H;\n                        N.font = ab.style + \" \" + H + \"px \" + ab.family;\n                        N.textBaseline = \"middle\";\n                        N.textAlign = \"center\";\n                        R.rho = w + Z.labelOffset + Z.sliceOffset;\n                        R.theta = U.pos.theta;\n                        var ak = R.getc(true);\n                        N.fillText(U.name, ak.x, ak.y);\n                        N.restore()\n                    }\n                }\n            },\n            contains: function(z, D) {\n                if (this.nodeTypes.none.anglecontains.call(this, z, D)) {\n                    var F = Math.sqrt(D.x * D.x + D.y * D.y);\n                    var w = this.config.levelDistance, C = z._depth;\n                    var x = z.getData(\"config\");\n                    if (F <= w * C + x.sliceOffset) {\n                        var G = z.getData(\"dimArray\");\n                        for (var B = 0, A = G.length, E = x.sliceOffset; B < A; B++) {\n                            var y = G[B];\n                            if (F >= E && F <= E + y) {\n                                return {\n                                    name: z.getData(\"stringArray\")[B],\n                                    color: z.getData(\"colorArray\")[B],\n                                    value: z.getData(\"valueArray\")[B],\n                                    label: z.name\n                                }\n                            }\n                            E += y\n                        }\n                    }\n                    return false\n                }\n                return false\n            }\n        }\n    });\n    $jit.PieChart = new q({\n        sb: null,\n        colors: [\"#416D9C\", \"#70A35E\", \"#EBB056\", \"#C74243\", \"#83548B\", \"#909291\", \"#557EAA\"],\n        selected: {},\n        busy: false,\n        initialize: function(w) {\n            this.controller = this.config = c.merge(n(\"Canvas\", \"PieChart\", \"Label\"), {\n                Label: {\n                    type: \"Native\"\n                }\n            }, w);\n            this.initializeViz()\n        },\n        initializeViz: function() {\n            var x = this.config, B = this;\n            var w = x.type.split(\":\")[0];\n            var A = new $jit.Sunburst({\n                injectInto: x.injectInto,\n                width: x.width,\n                height: x.height,\n                useCanvas: x.useCanvas,\n                withLabels: x.Label.type != \"Native\",\n                Label: {\n                    type: x.Label.type\n                },\n                Node: {\n                    overridable: true,\n                    type: \"piechart-\" + w,\n                    width: 1,\n                    height: 1\n                },\n                Edge: {\n                    type: \"none\"\n                },\n                Tips: {\n                    enable: x.Tips.enable,\n                    type: \"Native\",\n                    force: true,\n                    onShow: function(F, E, C) {\n                        var D = C;\n                        x.Tips.onShow(F, D, E)\n                    }\n                },\n                Events: {\n                    enable: true,\n                    type: \"Native\",\n                    onClick: function(E, F, C) {\n                        if (!x.Events.enable) {\n                            return \n                        }\n                        var D = F.getContains();\n                        x.Events.onClick(D, F, C)\n                    },\n                    onMouseMove: function(E, F, C) {\n                        if (!x.hoveredColor) {\n                            return \n                        }\n                        if (E) {\n                            var D = F.getContains();\n                            B.select(E.id, D.name, D.index)\n                        } else {\n                            B.select(false, false, false)\n                        }\n                    }\n                },\n                onCreateLabel: function(F, E) {\n                    var C = x.Label;\n                    if (x.showLabels) {\n                        var D = F.style;\n                        D.fontSize = C.size + \"px\";\n                        D.fontFamily = C.family;\n                        D.color = C.color;\n                        D.textAlign = \"center\";\n                        F.innerHTML = E.name\n                    }\n                },\n                onPlaceLabel: function(S, M) {\n                    if (!x.showLabels) {\n                        return \n                    }\n                    var G = M.pos.getp(true), J = M.getData(\"dimArray\"), P = M.getData(\"span\") / 2, H = M.pos.theta, R = H - P, D = H + P, U = new b;\n                    var L = x.showLabels, F = x.resizeLabels, I = x.Label;\n                    if (J) {\n                        for (var Q = 0, N = J.length, O = 0; Q < N; Q++) {\n                            O += J[Q]\n                        }\n                        var T = F ? M.getData(\"normalizedDim\"): 1, C = (I.size * T)>>0;\n                        C = C<+F?+F : C;\n                        S.style.fontSize = C + \"px\";\n                        U.rho = O + x.labelOffset + x.sliceOffset;\n                        U.theta = (R + D) / 2;\n                        var G = U.getc(true);\n                        var E = B.canvas.getSize();\n                        var K = {\n                            x: Math.round(G.x + E.width / 2),\n                            y: Math.round(G.y + E.height / 2)\n                        };\n                        S.style.left = K.x + \"px\";\n                        S.style.top = K.y + \"px\"\n                    }\n                }\n            });\n            var z = A.canvas.getSize(), y = Math.min;\n            A.config.levelDistance = y(z.width, z.height) / 2 - x.offset - x.sliceOffset;\n            this.delegate = A;\n            this.canvas = this.delegate.canvas;\n            this.canvas.getCtx().globalCompositeOperation = \"lighter\"\n        },\n        loadJSON: function(K) {\n            var H = c.time(), B = [], J = this.delegate, N = c.splat(K.label), D = N.length, G = c.splat(K.color || this.colors), y = G.length, L = this.config, w=!!L.type.split(\":\")[1], z = L.animate, F = D == 1;\n            for (var I = 0, x = K.values, E = x.length; I < E; I++) {\n                var M = x[I];\n                var A = c.splat(M.values);\n                B.push({\n                    id: H + M.label,\n                    name: M.label,\n                    data: {\n                        value: A,\n                        \"$valueArray\": A,\n                        \"$colorArray\": F ? c.splat(G[I%y]): G,\n                        \"$stringArray\": N,\n                        \"$gradient\": w,\n                        \"$config\": L,\n                        \"$angularWidth\": c.reduce(A, function(O, P) {\n                            return O + P\n                        })\n                    },\n                    children: []\n                })\n            }\n            var C = {\n                id: H + \"$root\",\n                name: \"\",\n                data: {\n                    \"$type\": \"none\",\n                    \"$width\": 1,\n                    \"$height\": 1\n                },\n                children: B\n            };\n            J.loadJSON(C);\n            this.normalizeDims();\n            J.refresh();\n            if (z) {\n                J.fx.animate({\n                    modes: [\"node-property:dimArray\"],\n                    duration: 1500\n                })\n            }\n        },\n        updateJSON: function(y, C) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            var z = this.delegate;\n            var B = z.graph;\n            var x = y.values;\n            var w = this.config.animate;\n            var A = this;\n            c.each(x, function(D) {\n                var F = B.getByName(D.label), E = c.splat(D.values);\n                if (F) {\n                    F.setData(\"valueArray\", E);\n                    F.setData(\"angularWidth\", c.reduce(E, function(G, H) {\n                        return G + H\n                    }));\n                    if (y.label) {\n                        F.setData(\"stringArray\", c.splat(y.label))\n                    }\n                }\n            });\n            this.normalizeDims();\n            if (w) {\n                z.compute(\"end\");\n                z.fx.animate({\n                    modes: [\"node-property:dimArray:span\", \"linear\"],\n                    duration: 1500,\n                    onComplete: function() {\n                        A.busy = false;\n                        C && C.onComplete()\n                    }\n                })\n            } else {\n                z.refresh()\n            }\n        },\n        select: function(y, w) {\n            if (!this.config.hoveredColor) {\n                return \n            }\n            var x = this.selected;\n            if (x.id != y || x.name != w) {\n                x.id = y;\n                x.name = w;\n                x.color = this.config.hoveredColor;\n                this.delegate.graph.eachNode(function(z) {\n                    if (y == z.id) {\n                        z.setData(\"border\", x)\n                    } else {\n                        z.setData(\"border\", false)\n                    }\n                });\n                this.delegate.plot()\n            }\n        },\n        getLegend: function() {\n            var y = {};\n            var z;\n            this.delegate.graph.getNode(this.delegate.root).eachAdjacency(function(A) {\n                z = A.nodeTo\n            });\n            var x = z.getData(\"colorArray\"), w = x.length;\n            c.each(z.getData(\"stringArray\"), function(B, A) {\n                y[B] = x[A%w]\n            });\n            return y\n        },\n        getMaxValue: function() {\n            var w = 0;\n            this.delegate.graph.eachNode(function(z) {\n                var x = z.getData(\"valueArray\"), y = 0;\n                c.each(x, function(A) {\n                    y+=+A\n                });\n                w = w > y ? w : y\n            });\n            return w\n        },\n        normalizeDims: function() {\n            var x = this.delegate.graph.getNode(this.delegate.root), w = 0;\n            x.eachAdjacency(function() {\n                w++\n            });\n            var B = this.getMaxValue() || 1, A = this.config, y = A.animate, z = this.delegate.config.levelDistance;\n            this.delegate.graph.eachNode(function(G) {\n                var F = 0, C = [];\n                c.each(G.getData(\"valueArray\"), function(H) {\n                    F+=+H;\n                    C.push(1)\n                });\n                var E = (C.length == 1)&&!A.updateHeights;\n                if (y) {\n                    G.setData(\"dimArray\", c.map(G.getData(\"valueArray\"), function(H) {\n                        return E ? z : (H * z / B)\n                    }), \"end\");\n                    var D = G.getData(\"dimArray\");\n                    if (!D) {\n                        G.setData(\"dimArray\", C)\n                    }\n                } else {\n                    G.setData(\"dimArray\", c.map(G.getData(\"valueArray\"), function(H) {\n                        return E ? z : (H * z / B)\n                    }))\n                }\n                G.setData(\"normalizedDim\", F / B)\n            })\n        }\n    });\n    g.TM = {};\n    g.TM.SliceAndDice = new q({\n        compute: function(B) {\n            var x = this.graph.getNode(this.clickedNode && this.clickedNode.id || this.root);\n            this.controller.onBeforeCompute(x);\n            var z = this.canvas.getSize(), y = this.config, A = z.width, w = z.height;\n            this.graph.computeLevels(this.root, 0, \"ignore\");\n            x.getPos(B).setc( - A / 2, - w / 2);\n            x.setData(\"width\", A, B);\n            x.setData(\"height\", w + y.titleHeight, B);\n            this.computePositions(x, x, this.layout.orientation, B);\n            this.controller.onAfterCompute(x)\n        },\n        computePositions: function(F, D, P, y) {\n            var M = 0;\n            F.eachSubnode(function(R) {\n                M += R.getData(\"area\", y)\n            });\n            var Q = this.config, N = Q.offset, J = F.getData(\"width\", y), H = Math.max(F.getData(\"height\", y) - Q.titleHeight, 0), x = F == D ? 1: (D.getData(\"area\", y) / M);\n            var I, G, L, B, A, E, C;\n            var O = (P == \"h\");\n            if (O) {\n                P = \"v\";\n                I = H;\n                G = J * x;\n                L = \"height\";\n                B = \"y\";\n                A = \"x\";\n                E = Q.titleHeight;\n                C = 0\n            } else {\n                P = \"h\";\n                I = H * x;\n                G = J;\n                L = \"width\";\n                B = \"x\";\n                A = \"y\";\n                E = 0;\n                C = Q.titleHeight\n            }\n            var w = D.getPos(y);\n            D.setData(\"width\", G, y);\n            D.setData(\"height\", I, y);\n            var K = 0, z = this;\n            D.eachSubnode(function(S) {\n                var R = S.getPos(y);\n                R[B] = K + w[B] + E;\n                R[A] = w[A] + C;\n                z.computePositions(D, S, P, y);\n                K += S.getData(L, y)\n            })\n        }\n    });\n    g.TM.Area = {\n        compute: function(w) {\n            w = w || \"current\";\n            var C = this.graph.getNode(this.clickedNode && this.clickedNode.id || this.root);\n            this.controller.onBeforeCompute(C);\n            var y = this.config, F = this.canvas.getSize(), x = F.width, E = F.height, D = y.offset, z = x - D, B = E - D;\n            this.graph.computeLevels(this.root, 0, \"ignore\");\n            C.getPos(w).setc( - x / 2, - E / 2);\n            C.setData(\"width\", x, w);\n            C.setData(\"height\", E, w);\n            var A = {\n                top: - E / 2 + y.titleHeight,\n                left: - x / 2,\n                width: z,\n                height: B - y.titleHeight\n            };\n            this.computePositions(C, A, w);\n            this.controller.onAfterCompute(C)\n        },\n        computeDim: function(B, C, E, A, z, x) {\n            if (B.length + C.length == 1) {\n                var y = (B.length == 1) ? B: C;\n                this.layoutLast(y, E, A, x);\n                return \n            }\n            if (B.length >= 2 && C.length == 0) {\n                C = [B.shift()]\n            }\n            if (B.length == 0) {\n                if (C.length > 0) {\n                    this.layoutRow(C, E, A, x)\n                }\n                return \n            }\n            var D = B[0];\n            if (z(C, E) >= z([D].concat(C), E)) {\n                this.computeDim(B.slice(1), C.concat([D]), E, A, z, x)\n            } else {\n                var F = this.layoutRow(C, E, A, x);\n                this.computeDim(B, [], F.dim, F, z, x)\n            }\n        },\n        worstAspectRatio: function(x, F) {\n            if (!x || x.length == 0) {\n                return Number.MAX_VALUE\n            }\n            var y = 0, G = 0, B = Number.MAX_VALUE;\n            for (var D = 0, C = x.length; D < C; D++) {\n                var z = x[D]._area;\n                y += z;\n                B = B < z ? B : z;\n                G = G > z ? G : z\n            }\n            var E = F * F, A = y * y;\n            return Math.max(E * G / A, A / (E * B))\n        },\n        avgAspectRatio: function(B, y) {\n            if (!B || B.length == 0) {\n                return Number.MAX_VALUE\n            }\n            var D = 0;\n            for (var z = 0, x = B.length; z < x; z++) {\n                var C = B[z]._area;\n                var A = C / y;\n                D += y > A ? y / A : A / y\n            }\n            return D / x\n        },\n        layoutLast: function(y, x, B, A) {\n            var z = y[0];\n            z.getPos(A).setc(B.left, B.top);\n            z.setData(\"width\", B.width, A);\n            z.setData(\"height\", B.height, A)\n        }\n    };\n    g.TM.Squarified = new q({\n        Implements: g.TM.Area,\n        computePositions: function(A, D, x) {\n            var z = this.config, F = Math.max;\n            if (D.width >= D.height) {\n                this.layout.orientation = \"h\"\n            } else {\n                this.layout.orientation = \"v\"\n            }\n            var w = A.getSubnodes([1, 1], \"ignore\");\n            if (w.length > 0) {\n                this.processChildrenLayout(A, w, D, x);\n                for (var C = 0, B = w.length; C < B; C++) {\n                    var G = w[C], H = z.offset, I = F(G.getData(\"height\", x) - H - z.titleHeight, 0), y = F(G.getData(\"width\", x) - H, 0), E = G.getPos(x);\n                    D = {\n                        width: y,\n                        height: I,\n                        top: E.y + z.titleHeight,\n                        left: E.x\n                    };\n                    this.computePositions(G, D, x)\n                }\n            }\n        },\n        processChildrenLayout: function(G, w, C, x) {\n            var A = C.width * C.height;\n            var B, y = w.length, D = 0, H = [];\n            for (B = 0; B < y; B++) {\n                H[B] = parseFloat(w[B].getData(\"area\", x));\n                D += H[B]\n            }\n            for (B = 0; B < y; B++) {\n                w[B]._area = A * H[B] / D\n            }\n            var z = this.layout.horizontal() ? C.height: C.width;\n            w.sort(function(J, I) {\n                var K = I._area - J._area;\n                return K ? K : (I.id == J.id ? 0 : (I.id < J.id ? 1 : -1))\n            });\n            var F = [w[0]];\n            var E = w.slice(1);\n            this.squarify(E, F, z, C, x)\n        },\n        squarify: function(y, B, x, A, z) {\n            this.computeDim(y, B, x, A, this.worstAspectRatio, z)\n        },\n        layoutRow: function(y, x, A, z) {\n            if (this.layout.horizontal()) {\n                return this.layoutV(y, x, A, z)\n            } else {\n                return this.layoutH(y, x, A, z)\n            }\n        },\n        layoutV: function(x, I, E, y) {\n            var J = 0, A = function(w) {\n                return w\n            };\n            c.each(x, function(w) {\n                J += w._area\n            });\n            var z = A(J / I), F = 0;\n            for (var C = 0, B = x.length; C < B; C++) {\n                var D = A(x[C]._area / z);\n                var G = x[C];\n                G.getPos(y).setc(E.left, E.top + F);\n                G.setData(\"width\", z, y);\n                G.setData(\"height\", D, y);\n                F += D\n            }\n            var H = {\n                height: E.height,\n                width: E.width - z,\n                top: E.top,\n                left: E.left + z\n            };\n            H.dim = Math.min(H.width, H.height);\n            if (H.dim != H.height) {\n                this.layout.change()\n            }\n            return H\n        },\n        layoutH: function(x, G, C, y) {\n            var I = 0;\n            c.each(x, function(w) {\n                I += w._area\n            });\n            var H = I / G, D = C.top, z = 0;\n            for (var B = 0, A = x.length; B < A; B++) {\n                var E = x[B];\n                var G = E._area / H;\n                E.getPos(y).setc(C.left + z, D);\n                E.setData(\"width\", G, y);\n                E.setData(\"height\", H, y);\n                z += G\n            }\n            var F = {\n                height: C.height - H,\n                width: C.width,\n                top: C.top + H,\n                left: C.left\n            };\n            F.dim = Math.min(F.width, F.height);\n            if (F.dim != F.width) {\n                this.layout.change()\n            }\n            return F\n        }\n    });\n    g.TM.Strip = new q({\n        Implements: g.TM.Area,\n        computePositions: function(A, D, x) {\n            var w = A.getSubnodes([1, 1], \"ignore\"), z = this.config, F = Math.max;\n            if (w.length > 0) {\n                this.processChildrenLayout(A, w, D, x);\n                for (var C = 0, B = w.length; C < B; C++) {\n                    var G = w[C];\n                    var H = z.offset, I = F(G.getData(\"height\", x) - H - z.titleHeight, 0), y = F(G.getData(\"width\", x) - H, 0);\n                    var E = G.getPos(x);\n                    D = {\n                        width: y,\n                        height: I,\n                        top: E.y + z.titleHeight,\n                        left: E.x\n                    };\n                    this.computePositions(G, D, x)\n                }\n            }\n        },\n        processChildrenLayout: function(G, w, B, x) {\n            var z = B.width * B.height;\n            var A, y = w.length, C = 0, H = [];\n            for (A = 0; A < y; A++) {\n                H[A] =+ w[A].getData(\"area\", x);\n                C += H[A]\n            }\n            for (A = 0; A < y; A++) {\n                w[A]._area = z * H[A] / C\n            }\n            var F = this.layout.horizontal() ? B.width: B.height;\n            var E = [w[0]];\n            var D = w.slice(1);\n            this.stripify(D, E, F, B, x)\n        },\n        stripify: function(y, B, x, A, z) {\n            this.computeDim(y, B, x, A, this.avgAspectRatio, z)\n        },\n        layoutRow: function(y, x, A, z) {\n            if (this.layout.horizontal()) {\n                return this.layoutH(y, x, A, z)\n            } else {\n                return this.layoutV(y, x, A, z)\n            }\n        },\n        layoutV: function(x, G, D, y) {\n            var H = 0;\n            c.each(x, function(w) {\n                H += w._area\n            });\n            var z = H / G, E = 0;\n            for (var B = 0, A = x.length; B < A; B++) {\n                var F = x[B];\n                var C = F._area / z;\n                F.getPos(y).setc(D.left, D.top + (G - C - E));\n                F.setData(\"width\", z, y);\n                F.setData(\"height\", C, y);\n                E += C\n            }\n            return {\n                height: D.height,\n                width: D.width - z,\n                top: D.top,\n                left: D.left + z,\n                dim: G\n            }\n        },\n        layoutH: function(x, F, C, y) {\n            var H = 0;\n            c.each(x, function(w) {\n                H += w._area\n            });\n            var G = H / F, D = C.height - G, z = 0;\n            for (var B = 0, A = x.length; B < A; B++) {\n                var E = x[B];\n                var I = E._area / G;\n                E.getPos(y).setc(C.left + z, C.top + D);\n                E.setData(\"width\", I, y);\n                E.setData(\"height\", G, y);\n                z += I\n            }\n            return {\n                height: C.height - G,\n                width: C.width,\n                top: C.top,\n                left: C.left,\n                dim: F\n            }\n        }\n    });\n    g.Icicle = new q({\n        compute: function(E) {\n            E = E || \"current\";\n            var D = this.graph.getNode(this.root), z = this.config, H = this.canvas.getSize(), w = H.width, G = H.height, A = z.offset, C = z.constrained ? z.levelsToShow: Number.MAX_VALUE;\n            this.controller.onBeforeCompute(D);\n            e.Util.computeLevels(this.graph, D.id, 0, \"ignore\");\n            var F = 0;\n            e.Util.eachLevel(D, 0, false, function(J, I) {\n                if (I > F) {\n                    F = I\n                }\n            });\n            var y = this.graph.getNode(this.clickedNode && this.clickedNode.id || D.id);\n            var x = Math.min(F, C-1);\n            var B = y._depth;\n            if (this.layout.horizontal()) {\n                this.computeSubtree(y, - w / 2, - G / 2, w / (x + 1), G, B, x, E)\n            } else {\n                this.computeSubtree(y, - w / 2, - G / 2, w, G / (x + 1), B, x, E)\n            }\n        },\n        computeSubtree: function(G, I, F, w, L, E, A, H) {\n            G.getPos(H).setc(I, F);\n            G.setData(\"width\", w, H);\n            G.setData(\"height\", L, H);\n            var C, K = 0, J = 0;\n            var z = e.Util.getSubnodes(G, [1, 1], \"ignore\");\n            if (!z.length) {\n                return \n            }\n            c.each(z, function(x) {\n                J += x.getData(\"dim\")\n            });\n            for (var D = 0, B = z.length; D < B; D++) {\n                if (this.layout.horizontal()) {\n                    C = L * z[D].getData(\"dim\") / J;\n                    this.computeSubtree(z[D], I + w, F, w, C, E, A, H);\n                    F += C\n                } else {\n                    C = w * z[D].getData(\"dim\") / J;\n                    this.computeSubtree(z[D], I, F + L, C, L, E, A, H);\n                    I += C\n                }\n            }\n        }\n    });\n    $jit.Icicle = new q({\n        Implements: [d, o, g.Icicle],\n        layout: {\n            orientation: \"h\",\n            vertical: function() {\n                return this.orientation == \"v\"\n            },\n            horizontal: function() {\n                return this.orientation == \"h\"\n            },\n            change: function() {\n                this.orientation = this.vertical() ? \"h\" : \"v\"\n            }\n        },\n        initialize: function(w) {\n            var x = {\n                animate: false,\n                orientation: \"h\",\n                offset: 2,\n                levelsToShow: Number.MAX_VALUE,\n                constrained: false,\n                Node: {\n                    type: \"rectangle\",\n                    overridable: true\n                },\n                Edge: {\n                    type: \"none\"\n                },\n                Label: {\n                    type: \"Native\"\n                },\n                duration: 700,\n                fps: 45\n            };\n            var z = n(\"Canvas\", \"Node\", \"Edge\", \"Fx\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Controller\", \"Label\");\n            this.controller = this.config = c.merge(z, x, w);\n            this.layout.orientation = this.config.orientation;\n            var y = this.config;\n            if (y.useCanvas) {\n                this.canvas = y.useCanvas;\n                this.config.labelContainer = this.canvas.id + \"-label\"\n            } else {\n                this.canvas = new l(this, y);\n                this.config.labelContainer = (typeof y.injectInto == \"string\" ? y.injectInto : y.injectInto.id) + \"-label\"\n            }\n            this.graphOptions = {\n                klass: p,\n                Node: {\n                    selected: false,\n                    exist: true,\n                    drawn: true\n                }\n            };\n            this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge, this.config.Label);\n            this.labels = new $jit.Icicle.Label[this.config.Label.type](this);\n            this.fx = new $jit.Icicle.Plot(this, $jit.Icicle);\n            this.op = new $jit.Icicle.Op(this);\n            this.group = new $jit.Icicle.Group(this);\n            this.clickedNode = null;\n            this.initializeExtras()\n        },\n        refresh: function() {\n            var w = this.config.Label.type;\n            if (w != \"Native\") {\n                var x = this;\n                this.graph.eachNode(function(y) {\n                    x.labels.hideLabel(y, false)\n                })\n            }\n            this.compute();\n            this.plot()\n        },\n        plot: function() {\n            this.fx.plot(this.config)\n        },\n        enter: function(y) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            var x = this, w = this.config;\n            var z = {\n                onComplete: function() {\n                    if (w.request) {\n                        x.compute()\n                    }\n                    if (w.animate) {\n                        x.graph.nodeList.setDataset([\"current\", \"end\"], {\n                            alpha: [1, 0]\n                        });\n                        e.Util.eachSubgraph(y, function(A) {\n                            A.setData(\"alpha\", 1, \"end\")\n                        }, \"ignore\");\n                        x.fx.animate({\n                            duration: 500,\n                            modes: [\"node-property:alpha\"],\n                            onComplete: function() {\n                                x.clickedNode = y;\n                                x.compute(\"end\");\n                                x.fx.animate({\n                                    modes: [\"linear\", \"node-property:width:height\"],\n                                    duration: 1000,\n                                    onComplete: function() {\n                                        x.busy = false;\n                                        x.clickedNode = y\n                                    }\n                                })\n                            }\n                        })\n                    } else {\n                        x.clickedNode = y;\n                        x.busy = false;\n                        x.refresh()\n                    }\n                }\n            };\n            if (w.request) {\n                this.requestNodes(clickedNode, z)\n            } else {\n                z.onComplete()\n            }\n        },\n        out: function() {\n            if (this.busy) {\n                return \n            }\n            var B = this, A = e.Util, y = this.config, D = this.graph, x = A.getParents(D.getNode(this.clickedNode && this.clickedNode.id || this.root)), z = x[0], w = z, C = this.clickedNode;\n            this.busy = true;\n            this.events.hoveredNode = false;\n            if (!z) {\n                this.busy = false;\n                return \n            }\n            callback = {\n                onComplete: function() {\n                    B.clickedNode = z;\n                    if (y.request) {\n                        B.requestNodes(z, {\n                            onComplete: function() {\n                                B.compute();\n                                B.plot();\n                                B.busy = false\n                            }\n                        })\n                    } else {\n                        B.compute();\n                        B.plot();\n                        B.busy = false\n                    }\n                }\n            };\n            if (y.animate) {\n                this.clickedNode = w;\n                this.compute(\"end\");\n                this.clickedNode = C;\n                this.fx.animate({\n                    modes: [\"linear\", \"node-property:width:height\"],\n                    duration: 1000,\n                    onComplete: function() {\n                        B.clickedNode = w;\n                        D.nodeList.setDataset([\"current\", \"end\"], {\n                            alpha: [0, 1]\n                        });\n                        A.eachSubgraph(C, function(E) {\n                            E.setData(\"alpha\", 1)\n                        }, \"ignore\");\n                        B.fx.animate({\n                            duration: 500,\n                            modes: [\"node-property:alpha\"],\n                            onComplete: function() {\n                                callback.onComplete()\n                            }\n                        })\n                    }\n                })\n            } else {\n                callback.onComplete()\n            }\n        },\n        requestNodes: function(y, z) {\n            var x = c.merge(this.controller, z), w = this.config.constrained ? this.config.levelsToShow: Number.MAX_VALUE;\n            if (x.request) {\n                var B = [], A = y._depth;\n                e.Util.eachLevel(y, 0, w, function(C) {\n                    if (C.drawn&&!e.Util.anySubnode(C)) {\n                        B.push(C);\n                        C._level = C._depth - A;\n                        if (this.config.constrained) {\n                            C._level = w - C._level\n                        }\n                    }\n                });\n                this.group.requestNodes(B, x)\n            } else {\n                x.onComplete()\n            }\n        }\n    });\n    $jit.Icicle.Op = new q({\n        Implements: e.Op\n    });\n    $jit.Icicle.Group = new q({\n        initialize: function(w) {\n            this.viz = w;\n            this.canvas = w.canvas;\n            this.config = w.config\n        },\n        requestNodes: function(B, A) {\n            var z = 0, x = B.length, D = {};\n            var y = function() {\n                A.onComplete()\n            };\n            var w = this.viz;\n            if (x == 0) {\n                y()\n            }\n            for (var C = 0; C < x; C++) {\n                D[B[C].id] = B[C];\n                A.request(B[C].id, B[C]._level, {\n                    onComplete: function(F, E) {\n                        if (E && E.children) {\n                            E.id = F;\n                            w.op.sum(E, {\n                                type: \"nothing\"\n                            })\n                        }\n                        if (++z == x) {\n                            e.Util.computeLevels(w.graph, w.root, 0);\n                            y()\n                        }\n                    }\n                })\n            }\n        }\n    });\n    $jit.Icicle.Plot = new q({\n        Implements: e.Plot,\n        plot: function(A, y) {\n            A = A || this.viz.controller;\n            var w = this.viz, B = w.graph, x = B.getNode(w.clickedNode && w.clickedNode.id || w.root), z = x._depth;\n            w.canvas.clear();\n            this.plotTree(x, c.merge(A, {\n                withLabels: true,\n                hideLabels: false,\n                plotSubtree: function(C, D) {\n                    return !w.config.constrained || (D._depth - z < w.config.levelsToShow)\n                }\n            }), y)\n        }\n    });\n    $jit.Icicle.Label = {};\n    $jit.Icicle.Label.Native = new q({\n        Implements: e.Label.Native,\n        renderLabel: function(x, y, A) {\n            var D = x.getCtx(), w = y.getData(\"width\"), C = y.getData(\"height\"), E = y.getLabelData(\"size\"), z = D.measureText(y.name);\n            if (C < (E * 1.5) || w < z.width) {\n                return \n            }\n            var B = y.pos.getc(true);\n            D.fillText(y.name, B.x + w / 2, B.y + C / 2)\n        }\n    });\n    $jit.Icicle.Label.SVG = new q({\n        Implements: e.Label.SVG,\n        initialize: function(w) {\n            this.viz = w\n        },\n        placeLabel: function(x, A, y) {\n            var C = A.pos.getc(true), z = this.viz.canvas;\n            var w = z.getSize();\n            var B = {\n                x: Math.round(C.x + w.width / 2),\n                y: Math.round(C.y + w.height / 2)\n            };\n            x.setAttribute(\"x\", B.x);\n            x.setAttribute(\"y\", B.y);\n            y.onPlaceLabel(x, A)\n        }\n    });\n    $jit.Icicle.Label.HTML = new q({\n        Implements: e.Label.HTML,\n        initialize: function(w) {\n            this.viz = w\n        },\n        placeLabel: function(x, B, y) {\n            var D = B.pos.getc(true), z = this.viz.canvas;\n            var w = z.getSize();\n            var C = {\n                x: Math.round(D.x + w.width / 2),\n                y: Math.round(D.y + w.height / 2)\n            };\n            var A = x.style;\n            A.left = C.x + \"px\";\n            A.top = C.y + \"px\";\n            A.display = \"\";\n            y.onPlaceLabel(x, B)\n        }\n    });\n    $jit.Icicle.Plot.NodeTypes = new q({\n        none: {\n            render: c.empty\n        },\n        rectangle: {\n            render: function(z, x, K) {\n                var y = this.viz.config;\n                var C = y.offset;\n                var w = z.getData(\"width\");\n                var H = z.getData(\"height\");\n                var B = z.getData(\"border\");\n                var G = z.pos.getc(true);\n                var F = G.x + C / 2, D = G.y + C / 2;\n                var J = x.getCtx();\n                if (w - C < 2 || H - C < 2) {\n                    return \n                }\n                if (y.cushion) {\n                    var A = z.getData(\"color\");\n                    var I = J.createRadialGradient(F + (w - C) / 2, D + (H - C) / 2, 1, F + (w - C) / 2, D + (H - C) / 2, w < H ? H : w);\n                    var E = c.rgbToHex(c.map(c.hexToRgb(A), function(L) {\n                        return L * 0.3>>0\n                    }));\n                    I.addColorStop(0, A);\n                    I.addColorStop(1, E);\n                    J.fillStyle = I\n                }\n                if (B) {\n                    J.strokeStyle = B;\n                    J.lineWidth = 3\n                }\n                J.fillRect(F, D, Math.max(0, w - C), Math.max(0, H - C));\n                B && J.strokeRect(G.x, G.y, w, H)\n            },\n            contains: function(y, A) {\n                if (this.viz.clickedNode&&!$jit.Graph.Util.isDescendantOf(y, this.viz.clickedNode.id)) {\n                    return false\n                }\n                var z = y.pos.getc(true), x = y.getData(\"width\"), w = y.getData(\"height\");\n                return this.nodeHelper.rectangle.contains({\n                    x: z.x + x / 2,\n                    y: z.y + w / 2\n                }, A, x, w)\n            }\n        }\n    });\n    $jit.Icicle.Plot.EdgeTypes = new q({\n        none: c.empty\n    });\n    g.ForceDirected = new q({\n        getOptions: function(D) {\n            var B = this.canvas.getSize();\n            var y = B.width, A = B.height;\n            var C = 0;\n            this.graph.eachNode(function(w) {\n                C++\n            });\n            var E = y * A / C, z = Math.sqrt(E);\n            var x = this.config.levelDistance;\n            return {\n                width: y,\n                height: A,\n                tstart: y * 0.1,\n                nodef: function(w) {\n                    return E / (w || 1)\n                },\n                edgef: function(w) {\n                    return z * (w - x)\n                }\n            }\n        },\n        compute: function(x, y) {\n            var z = c.splat(x || [\"current\", \"start\", \"end\"]);\n            var w = this.getOptions();\n            f.compute(this.graph, z, this.config);\n            this.graph.computeLevels(this.root, 0, \"ignore\");\n            this.graph.eachNode(function(A) {\n                c.each(z, function(B) {\n                    var C = A.getPos(B);\n                    if (C.equals(p.KER)) {\n                        C.x = w.width / 5 * (Math.random()-0.5);\n                        C.y = w.height / 5 * (Math.random()-0.5)\n                    }\n                    A.disp = {};\n                    c.each(z, function(D) {\n                        A.disp[D] = r(0, 0)\n                    })\n                })\n            });\n            this.computePositions(z, w, y)\n        },\n        computePositions: function(A, y, B) {\n            var C = this.config.iterations, x = 0, z = this;\n            if (B) {\n                (function w() {\n                    for (var E = B.iter, D = 0; D < E; D++) {\n                        y.t = y.tstart;\n                        if (C) {\n                            y.t*=(1 - x++ / (C-1))\n                        }\n                        z.computePositionStep(A, y);\n                        if (C && x >= C) {\n                            B.onComplete();\n                            return \n                        }\n                    }\n                    B.onStep(Math.round(x / (C-1) * 100));\n                    setTimeout(w, 1)\n                })()\n            } else {\n                for (; x < C; x++) {\n                    y.t = y.tstart * (1 - x / (C-1));\n                    this.computePositionStep(A, y)\n                }\n            }\n        },\n        computePositionStep: function(D, w) {\n            var E = this.graph;\n            var y = Math.min, C = Math.max;\n            var B = r(0, 0);\n            E.eachNode(function(G) {\n                c.each(D, function(H) {\n                    G.disp[H].x = 0;\n                    G.disp[H].y = 0\n                });\n                E.eachNode(function(H) {\n                    if (H.id != G.id) {\n                        c.each(D, function(L) {\n                            var J = G.getPos(L), I = H.getPos(L);\n                            B.x = J.x - I.x;\n                            B.y = J.y - I.y;\n                            var K = B.norm() || 1;\n                            G.disp[L].$add(B.$scale(w.nodef(K) / K))\n                        })\n                    }\n                })\n            });\n            var x=!!E.getNode(this.root).visited;\n            E.eachNode(function(G) {\n                G.eachAdjacency(function(H) {\n                    var I = H.nodeTo;\n                    if (!!I.visited === x) {\n                        c.each(D, function(M) {\n                            var K = G.getPos(M), J = I.getPos(M);\n                            B.x = K.x - J.x;\n                            B.y = K.y - J.y;\n                            var L = B.norm() || 1;\n                            G.disp[M].$add(B.$scale( - w.edgef(L) / L));\n                            I.disp[M].$add(B.$scale(-1))\n                        })\n                    }\n                });\n                G.visited=!x\n            });\n            var F = w.t, z = w.width / 2, A = w.height / 2;\n            E.eachNode(function(G) {\n                c.each(D, function(J) {\n                    var H = G.disp[J];\n                    var I = H.norm() || 1;\n                    var J = G.getPos(J);\n                    J.$add(r(H.x * y(Math.abs(H.x), F) / I, H.y * y(Math.abs(H.y), F) / I));\n                    J.x = y(z, C( - z, J.x));\n                    J.y = y(A, C( - A, J.y))\n                })\n            })\n        }\n    });\n    $jit.ForceDirected = new q({\n        Implements: [d, o, g.ForceDirected],\n        initialize: function(x) {\n            var w = $jit.ForceDirected;\n            var y = {\n                iterations: 50,\n                levelDistance: 50\n            };\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Node\", \"Edge\", \"Fx\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Controller\", \"Label\"), y, x);\n            var z = this.config;\n            if (z.useCanvas) {\n                this.canvas = z.useCanvas;\n                this.config.labelContainer = this.canvas.id + \"-label\"\n            } else {\n                if (z.background) {\n                    z.background = c.merge({\n                        type: \"Circles\"\n                    }, z.background)\n                }\n                this.canvas = new l(this, z);\n                this.config.labelContainer = (typeof z.injectInto == \"string\" ? z.injectInto : z.injectInto.id) + \"-label\"\n            }\n            this.graphOptions = {\n                klass: p,\n                Node: {\n                    selected: false,\n                    exist: true,\n                    drawn: true\n                }\n            };\n            this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge);\n            this.labels = new w.Label[z.Label.type](this);\n            this.fx = new w.Plot(this, w);\n            this.op = new w.Op(this);\n            this.json = null;\n            this.busy = false;\n            this.initializeExtras()\n        },\n        refresh: function() {\n            this.compute();\n            this.plot()\n        },\n        reposition: function() {\n            this.compute(\"end\")\n        },\n        computeIncremental: function(w) {\n            w = c.merge({\n                iter: 20,\n                property: \"end\",\n                onStep: c.empty,\n                onComplete: c.empty\n            }, w || {});\n            this.config.onBeforeCompute(this.graph.getNode(this.root));\n            this.compute(w.property, w)\n        },\n        plot: function() {\n            this.fx.plot()\n        },\n        animate: function(w) {\n            this.fx.animate(c.merge({\n                modes: [\"linear\"]\n            }, w || {}))\n        }\n    });\n    $jit.ForceDirected.$extend = true;\n    (function(w) {\n        w.Op = new q({\n            Implements: e.Op\n        });\n        w.Plot = new q({\n            Implements: e.Plot\n        });\n        w.Label = {};\n        w.Label.Native = new q({\n            Implements: e.Label.Native\n        });\n        w.Label.SVG = new q({\n            Implements: e.Label.SVG,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(H, B, C) {\n                var F = B.pos.getc(true), y = this.viz.canvas, z = y.translateOffsetX, x = y.translateOffsetY, G = y.scaleOffsetX, E = y.scaleOffsetY, D = y.getSize();\n                var A = {\n                    x: Math.round(F.x * G + z + D.width / 2),\n                    y: Math.round(F.y * E + x + D.height / 2)\n                };\n                H.setAttribute(\"x\", A.x);\n                H.setAttribute(\"y\", A.y);\n                C.onPlaceLabel(H, B)\n            }\n        });\n        w.Label.HTML = new q({\n            Implements: e.Label.HTML,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(I, C, D) {\n                var G = C.pos.getc(true), z = this.viz.canvas, A = z.translateOffsetX, y = z.translateOffsetY, H = z.scaleOffsetX, F = z.scaleOffsetY, E = z.getSize();\n                var B = {\n                    x: Math.round(G.x * H + A + E.width / 2),\n                    y: Math.round(G.y * F + y + E.height / 2)\n                };\n                var x = I.style;\n                x.left = B.x + \"px\";\n                x.top = B.y + \"px\";\n                x.display = this.fitsInCanvas(B, z) ? \"\" : \"none\";\n                D.onPlaceLabel(I, C)\n            }\n        });\n        w.Plot.NodeTypes = new q({\n            none: {\n                render: c.empty,\n                contains: c.lambda(false)\n            },\n            circle: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.circle.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.circle.contains(z, A, y)\n                }\n            },\n            ellipse: {\n                render: function(A, y) {\n                    var B = A.pos.getc(true), z = A.getData(\"width\"), x = A.getData(\"height\");\n                    this.nodeHelper.ellipse.render(\"fill\", B, z, x, y)\n                },\n                contains: function(z, B) {\n                    var A = z.pos.getc(true), y = z.getData(\"width\"), x = z.getData(\"height\");\n                    return this.nodeHelper.ellipse.contains(A, B, y, x)\n                }\n            },\n            square: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.square.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.square.contains(z, A, y)\n                }\n            },\n            rectangle: {\n                render: function(A, y) {\n                    var B = A.pos.getc(true), z = A.getData(\"width\"), x = A.getData(\"height\");\n                    this.nodeHelper.rectangle.render(\"fill\", B, z, x, y)\n                },\n                contains: function(z, B) {\n                    var A = z.pos.getc(true), y = z.getData(\"width\"), x = z.getData(\"height\");\n                    return this.nodeHelper.rectangle.contains(A, B, y, x)\n                }\n            },\n            triangle: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.triangle.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.triangle.contains(z, A, y)\n                }\n            },\n            star: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.star.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.star.contains(z, A, y)\n                }\n            }\n        });\n        w.Plot.EdgeTypes = new q({\n            none: c.empty,\n            line: {\n                render: function(x, y) {\n                    var A = x.nodeFrom.pos.getc(true), z = x.nodeTo.pos.getc(true);\n                    this.edgeHelper.line.render(A, z, y)\n                },\n                contains: function(x, A) {\n                    var z = x.nodeFrom.pos.getc(true), y = x.nodeTo.pos.getc(true);\n                    return this.edgeHelper.line.contains(z, y, A, this.edge.epsilon)\n                }\n            },\n            arrow: {\n                render: function(y, z) {\n                    var D = y.nodeFrom.pos.getc(true), C = y.nodeTo.pos.getc(true), B = y.getData(\"dim\"), A = y.data.$direction, x = (A && A.length > 1 && A[0] != y.nodeFrom.id);\n                    this.edgeHelper.arrow.render(D, C, B, x, z)\n                },\n                contains: function(x, A) {\n                    var z = x.nodeFrom.pos.getc(true), y = x.nodeTo.pos.getc(true);\n                    return this.edgeHelper.arrow.contains(z, y, A, this.edge.epsilon)\n                }\n            }\n        })\n    })($jit.ForceDirected);\n    $jit.TM = {};\n    var v = $jit.TM;\n    $jit.TM.$extend = true;\n    v.Base = {\n        layout: {\n            orientation: \"h\",\n            vertical: function() {\n                return this.orientation == \"v\"\n            },\n            horizontal: function() {\n                return this.orientation == \"h\"\n            },\n            change: function() {\n                this.orientation = this.vertical() ? \"h\" : \"v\"\n            }\n        },\n        initialize: function(w) {\n            var x = {\n                orientation: \"h\",\n                titleHeight: 13,\n                offset: 2,\n                levelsToShow: 0,\n                constrained: false,\n                animate: false,\n                Node: {\n                    type: \"rectangle\",\n                    overridable: true,\n                    width: 3,\n                    height: 3,\n                    color: \"#444\"\n                },\n                Label: {\n                    textAlign: \"center\",\n                    textBaseline: \"top\"\n                },\n                Edge: {\n                    type: \"none\"\n                },\n                duration: 700,\n                fps: 45\n            };\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Node\", \"Edge\", \"Fx\", \"Controller\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Label\"), x, w);\n            this.layout.orientation = this.config.orientation;\n            var y = this.config;\n            if (y.useCanvas) {\n                this.canvas = y.useCanvas;\n                this.config.labelContainer = this.canvas.id + \"-label\"\n            } else {\n                if (y.background) {\n                    y.background = c.merge({\n                        type: \"Circles\"\n                    }, y.background)\n                }\n                this.canvas = new l(this, y);\n                this.config.labelContainer = (typeof y.injectInto == \"string\" ? y.injectInto : y.injectInto.id) + \"-label\"\n            }\n            this.graphOptions = {\n                klass: p,\n                Node: {\n                    selected: false,\n                    exist: true,\n                    drawn: true\n                }\n            };\n            this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge);\n            this.labels = new v.Label[y.Label.type](this);\n            this.fx = new v.Plot(this);\n            this.op = new v.Op(this);\n            this.group = new v.Group(this);\n            this.geom = new v.Geom(this);\n            this.clickedNode = null;\n            this.busy = false;\n            this.initializeExtras()\n        },\n        refresh: function() {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            var x = this;\n            if (this.config.animate) {\n                this.compute(\"end\");\n                this.config.levelsToShow > 0 && this.geom.setRightLevelToShow(this.graph.getNode(this.clickedNode && this.clickedNode.id || this.root));\n                this.fx.animate(c.merge(this.config, {\n                    modes: [\"linear\", \"node-property:width:height\"],\n                    onComplete: function() {\n                        x.busy = false\n                    }\n                }))\n            } else {\n                var w = this.config.Label.type;\n                if (w != \"Native\") {\n                    var x = this;\n                    this.graph.eachNode(function(y) {\n                        x.labels.hideLabel(y, false)\n                    })\n                }\n                this.busy = false;\n                this.compute();\n                this.config.levelsToShow > 0 && this.geom.setRightLevelToShow(this.graph.getNode(this.clickedNode && this.clickedNode.id || this.root));\n                this.plot()\n            }\n        },\n        plot: function() {\n            this.fx.plot()\n        },\n        leaf: function(w) {\n            return w.getSubnodes([1, 1], \"ignore\").length == 0\n        },\n        enter: function(C) {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            var y = this, x = this.config, A = this.graph, w = C, z = this.clickedNode;\n            var B = {\n                onComplete: function() {\n                    if (x.levelsToShow > 0) {\n                        y.geom.setRightLevelToShow(C)\n                    }\n                    if (x.levelsToShow > 0 || x.request) {\n                        y.compute()\n                    }\n                    if (x.animate) {\n                        A.nodeList.setData(\"alpha\", 0, \"end\");\n                        C.eachSubgraph(function(D) {\n                            D.setData(\"alpha\", 1, \"end\")\n                        }, \"ignore\");\n                        y.fx.animate({\n                            duration: 500,\n                            modes: [\"node-property:alpha\"],\n                            onComplete: function() {\n                                y.clickedNode = w;\n                                y.compute(\"end\");\n                                y.clickedNode = z;\n                                y.fx.animate({\n                                    modes: [\"linear\", \"node-property:width:height\"],\n                                    duration: 1000,\n                                    onComplete: function() {\n                                        y.busy = false;\n                                        y.clickedNode = w\n                                    }\n                                })\n                            }\n                        })\n                    } else {\n                        y.busy = false;\n                        y.clickedNode = C;\n                        y.refresh()\n                    }\n                }\n            };\n            if (x.request) {\n                this.requestNodes(w, B)\n            } else {\n                B.onComplete()\n            }\n        },\n        out: function() {\n            if (this.busy) {\n                return \n            }\n            this.busy = true;\n            this.events.hoveredNode = false;\n            var A = this, y = this.config, C = this.graph, x = C.getNode(this.clickedNode && this.clickedNode.id || this.root).getParents(), z = x[0], w = z, B = this.clickedNode;\n            if (!z) {\n                this.busy = false;\n                return \n            }\n            callback = {\n                onComplete: function() {\n                    A.clickedNode = z;\n                    if (y.request) {\n                        A.requestNodes(z, {\n                            onComplete: function() {\n                                A.compute();\n                                A.plot();\n                                A.busy = false\n                            }\n                        })\n                    } else {\n                        A.compute();\n                        A.plot();\n                        A.busy = false\n                    }\n                }\n            };\n            if (y.levelsToShow > 0) {\n                this.geom.setRightLevelToShow(z)\n            }\n            if (y.animate) {\n                this.clickedNode = w;\n                this.compute(\"end\");\n                this.clickedNode = B;\n                this.fx.animate({\n                    modes: [\"linear\", \"node-property:width:height\"],\n                    duration: 1000,\n                    onComplete: function() {\n                        A.clickedNode = w;\n                        C.eachNode(function(D) {\n                            D.setDataset([\"current\", \"end\"], {\n                                alpha: [0, 1]\n                            })\n                        }, \"ignore\");\n                        B.eachSubgraph(function(D) {\n                            D.setData(\"alpha\", 1)\n                        }, \"ignore\");\n                        A.fx.animate({\n                            duration: 500,\n                            modes: [\"node-property:alpha\"],\n                            onComplete: function() {\n                                callback.onComplete()\n                            }\n                        })\n                    }\n                })\n            } else {\n                callback.onComplete()\n            }\n        },\n        requestNodes: function(y, z) {\n            var x = c.merge(this.controller, z), w = this.config.levelsToShow;\n            if (x.request) {\n                var B = [], A = y._depth;\n                y.eachLevel(0, w, function(D) {\n                    var C = w - (D._depth - A);\n                    if (D.drawn&&!D.anySubnode() && C > 0) {\n                        B.push(D);\n                        D._level = C\n                    }\n                });\n                this.group.requestNodes(B, x)\n            } else {\n                x.onComplete()\n            }\n        },\n        reposition: function() {\n            this.compute(\"end\")\n        }\n    };\n    v.Op = new q({\n        Implements: e.Op,\n        initialize: function(w) {\n            this.viz = w\n        }\n    });\n    v.Geom = new q({\n        Implements: e.Geom,\n        getRightLevelToShow: function() {\n            return this.viz.config.levelsToShow\n        },\n        setRightLevelToShow: function(x) {\n            var y = this.getRightLevelToShow(), w = this.viz.labels;\n            x.eachLevel(0, y + 1, function(A) {\n                var z = A._depth - x._depth;\n                if (z > y) {\n                    A.drawn = false;\n                    A.exist = false;\n                    A.ignore = true;\n                    w.hideLabel(A, false)\n                } else {\n                    A.drawn = true;\n                    A.exist = true;\n                    delete A.ignore\n                }\n            });\n            x.drawn = true;\n            delete x.ignore\n        }\n    });\n    v.Group = new q({\n        initialize: function(w) {\n            this.viz = w;\n            this.canvas = w.canvas;\n            this.config = w.config\n        },\n        requestNodes: function(B, A) {\n            var z = 0, x = B.length, D = {};\n            var y = function() {\n                A.onComplete()\n            };\n            var w = this.viz;\n            if (x == 0) {\n                y()\n            }\n            for (var C = 0; C < x; C++) {\n                D[B[C].id] = B[C];\n                A.request(B[C].id, B[C]._level, {\n                    onComplete: function(F, E) {\n                        if (E && E.children) {\n                            E.id = F;\n                            w.op.sum(E, {\n                                type: \"nothing\"\n                            })\n                        }\n                        if (++z == x) {\n                            w.graph.computeLevels(w.root, 0);\n                            y()\n                        }\n                    }\n                })\n            }\n        }\n    });\n    v.Plot = new q({\n        Implements: e.Plot,\n        initialize: function(w) {\n            this.viz = w;\n            this.config = w.config;\n            this.node = this.config.Node;\n            this.edge = this.config.Edge;\n            this.animation = new u;\n            this.nodeTypes = new v.Plot.NodeTypes;\n            this.edgeTypes = new v.Plot.EdgeTypes;\n            this.labels = w.labels\n        },\n        plot: function(y, x) {\n            var w = this.viz, z = w.graph;\n            w.canvas.clear();\n            this.plotTree(z.getNode(w.clickedNode && w.clickedNode.id || w.root), c.merge(w.config, y || {}, {\n                withLabels: true,\n                hideLabels: false,\n                plotSubtree: function(B, A) {\n                    return B.anySubnode(\"exist\")\n                }\n            }), x)\n        }\n    });\n    v.Label = {};\n    v.Label.Native = new q({\n        Implements: e.Label.Native,\n        initialize: function(w) {\n            this.config = w.config;\n            this.leaf = w.leaf\n        },\n        renderLabel: function(z, A, B) {\n            if (!this.leaf(A)&&!this.config.titleHeight) {\n                return \n            }\n            var D = A.pos.getc(true), G = z.getCtx(), w = A.getData(\"width\"), F = A.getData(\"height\"), E = D.x + w / 2, C = D.y;\n            G.fillText(A.name, E, C, w)\n        }\n    });\n    v.Label.SVG = new q({\n        Implements: e.Label.SVG,\n        initialize: function(w) {\n            this.viz = w;\n            this.leaf = w.leaf;\n            this.config = w.config\n        },\n        placeLabel: function(G, A, B) {\n            var E = A.pos.getc(true), x = this.viz.canvas, y = x.translateOffsetX, w = x.translateOffsetY, F = x.scaleOffsetX, D = x.scaleOffsetY, C = x.getSize();\n            var z = {\n                x: Math.round(E.x * F + y + C.width / 2),\n                y: Math.round(E.y * D + w + C.height / 2)\n            };\n            G.setAttribute(\"x\", z.x);\n            G.setAttribute(\"y\", z.y);\n            if (!this.leaf(A)&&!this.config.titleHeight) {\n                G.style.display = \"none\"\n            }\n            B.onPlaceLabel(G, A)\n        }\n    });\n    v.Label.HTML = new q({\n        Implements: e.Label.HTML,\n        initialize: function(w) {\n            this.viz = w;\n            this.leaf = w.leaf;\n            this.config = w.config\n        },\n        placeLabel: function(H, B, C) {\n            var F = B.pos.getc(true), y = this.viz.canvas, z = y.translateOffsetX, x = y.translateOffsetY, G = y.scaleOffsetX, E = y.scaleOffsetY, D = y.getSize();\n            var A = {\n                x: Math.round(F.x * G + z + D.width / 2),\n                y: Math.round(F.y * E + x + D.height / 2)\n            };\n            var w = H.style;\n            w.left = A.x + \"px\";\n            w.top = A.y + \"px\";\n            w.width = B.getData(\"width\") * G + \"px\";\n            w.height = B.getData(\"height\") * E + \"px\";\n            w.zIndex = B._depth * 100;\n            w.display = \"\";\n            if (!this.leaf(B)&&!this.config.titleHeight) {\n                H.style.display = \"none\"\n            }\n            C.onPlaceLabel(H, B)\n        }\n    });\n    v.Plot.NodeTypes = new q({\n        none: {\n            render: c.empty\n        },\n        rectangle: {\n            render: function(z, x, M) {\n                var D = this.viz.leaf(z), y = this.config, I = y.offset, C = y.titleHeight, H = z.pos.getc(true), w = z.getData(\"width\"), J = z.getData(\"height\"), B = z.getData(\"border\"), L = x.getCtx(), G = H.x + I / 2, E = H.y + I / 2;\n                if (w <= I || J <= I) {\n                    return \n                }\n                if (D) {\n                    if (y.cushion) {\n                        var K = L.createRadialGradient(G + (w - I) / 2, E + (J - I) / 2, 1, G + (w - I) / 2, E + (J - I) / 2, w < J ? J : w);\n                        var A = z.getData(\"color\");\n                        var F = c.rgbToHex(c.map(c.hexToRgb(A), function(N) {\n                            return N * 0.2>>0\n                        }));\n                        K.addColorStop(0, A);\n                        K.addColorStop(1, F);\n                        L.fillStyle = K\n                    }\n                    L.fillRect(G, E, w - I, J - I);\n                    if (B) {\n                        L.save();\n                        L.strokeStyle = B;\n                        L.strokeRect(G, E, w - I, J - I);\n                        L.restore()\n                    }\n                } else {\n                    if (C > 0) {\n                        L.fillRect(H.x + I / 2, H.y + I / 2, w - I, C - I);\n                        if (B) {\n                            L.save();\n                            L.strokeStyle = B;\n                            L.strokeRect(H.x + I / 2, H.y + I / 2, w - I, J - I);\n                            L.restore()\n                        }\n                    }\n                }\n            },\n            contains: function(z, B) {\n                if (this.viz.clickedNode&&!z.isDescendantOf(this.viz.clickedNode.id) || z.ignore) {\n                    return false\n                }\n                var A = z.pos.getc(true), y = z.getData(\"width\"), x = this.viz.leaf(z), w = x ? z.getData(\"height\"): this.config.titleHeight;\n                return this.nodeHelper.rectangle.contains({\n                    x: A.x + y / 2,\n                    y: A.y + w / 2\n                }, B, y, w)\n            }\n        }\n    });\n    v.Plot.EdgeTypes = new q({\n        none: c.empty\n    });\n    v.SliceAndDice = new q({\n        Implements: [d, o, v.Base, g.TM.SliceAndDice]\n    });\n    v.Squarified = new q({\n        Implements: [d, o, v.Base, g.TM.Squarified]\n    });\n    v.Strip = new q({\n        Implements: [d, o, v.Base, g.TM.Strip]\n    });\n    $jit.RGraph = new q({\n        Implements: [d, o, g.Radial],\n        initialize: function(w) {\n            var x = $jit.RGraph;\n            var y = {\n                interpolation: \"linear\",\n                levelDistance: 100\n            };\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Node\", \"Edge\", \"Fx\", \"Controller\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Label\"), y, w);\n            var z = this.config;\n            if (z.useCanvas) {\n                this.canvas = z.useCanvas;\n                this.config.labelContainer = this.canvas.id + \"-label\"\n            } else {\n                if (z.background) {\n                    z.background = c.merge({\n                        type: \"Circles\"\n                    }, z.background)\n                }\n                this.canvas = new l(this, z);\n                this.config.labelContainer = (typeof z.injectInto == \"string\" ? z.injectInto : z.injectInto.id) + \"-label\"\n            }\n            this.graphOptions = {\n                klass: b,\n                Node: {\n                    selected: false,\n                    exist: true,\n                    drawn: true\n                }\n            };\n            this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge);\n            this.labels = new x.Label[z.Label.type](this);\n            this.fx = new x.Plot(this, x);\n            this.op = new x.Op(this);\n            this.json = null;\n            this.root = null;\n            this.busy = false;\n            this.parent = false;\n            this.initializeExtras()\n        },\n        createLevelDistanceFunc: function() {\n            var w = this.config.levelDistance;\n            return function(x) {\n                return (x._depth + 1) * w\n            }\n        },\n        refresh: function() {\n            this.compute();\n            this.plot()\n        },\n        reposition: function() {\n            this.compute(\"end\")\n        },\n        plot: function() {\n            this.fx.plot()\n        },\n        getNodeAndParentAngle: function(D) {\n            var y = false;\n            var C = this.graph.getNode(D);\n            var A = C.getParents();\n            var z = (A.length > 0) ? A[0]: false;\n            if (z) {\n                var w = z.pos.getc(), B = C.pos.getc();\n                var x = w.add(B.scale(-1));\n                y = Math.atan2(x.y, x.x);\n                if (y < 0) {\n                    y += 2 * Math.PI\n                }\n            }\n            return {\n                parent: z,\n                theta: y\n            }\n        },\n        tagChildren: function(A, C) {\n            if (A.angleSpan) {\n                var B = [];\n                A.eachAdjacency(function(D) {\n                    B.push(D.nodeTo)\n                }, \"ignore\");\n                var w = B.length;\n                for (var z = 0; z < w && C != B[z].id; z++) {}\n                for (var y = (z + 1)%w, x = 0; C != B[y].id; y = (y + 1)%w) {\n                    B[y].dist = x++\n                }\n            }\n        },\n        onClick: function(B, x) {\n            if (this.root != B&&!this.busy) {\n                this.busy = true;\n                this.root = B;\n                var y = this;\n                this.controller.onBeforeCompute(this.graph.getNode(B));\n                var z = this.getNodeAndParentAngle(B);\n                this.tagChildren(z.parent, B);\n                this.parent = z.parent;\n                this.compute(\"end\");\n                var w = z.theta - z.parent.endPos.theta;\n                this.graph.eachNode(function(C) {\n                    C.endPos.set(C.endPos.getp().add(k(w, 0)))\n                });\n                var A = this.config.interpolation;\n                x = c.merge({\n                    onComplete: c.empty\n                }, x || {});\n                this.fx.animate(c.merge({\n                    hideLabels: true,\n                    modes: [A]\n                }, x, {\n                    onComplete: function() {\n                        y.busy = false;\n                        x.onComplete()\n                    }\n                }))\n            }\n        }\n    });\n    $jit.RGraph.$extend = true;\n    (function(w) {\n        w.Op = new q({\n            Implements: e.Op\n        });\n        w.Plot = new q({\n            Implements: e.Plot\n        });\n        w.Label = {};\n        w.Label.Native = new q({\n            Implements: e.Label.Native\n        });\n        w.Label.SVG = new q({\n            Implements: e.Label.SVG,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(H, B, C) {\n                var F = B.pos.getc(true), y = this.viz.canvas, z = y.translateOffsetX, x = y.translateOffsetY, G = y.scaleOffsetX, E = y.scaleOffsetY, D = y.getSize();\n                var A = {\n                    x: Math.round(F.x * G + z + D.width / 2),\n                    y: Math.round(F.y * E + x + D.height / 2)\n                };\n                H.setAttribute(\"x\", A.x);\n                H.setAttribute(\"y\", A.y);\n                C.onPlaceLabel(H, B)\n            }\n        });\n        w.Label.HTML = new q({\n            Implements: e.Label.HTML,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(I, C, D) {\n                var G = C.pos.getc(true), z = this.viz.canvas, A = z.translateOffsetX, y = z.translateOffsetY, H = z.scaleOffsetX, F = z.scaleOffsetY, E = z.getSize();\n                var B = {\n                    x: Math.round(G.x * H + A + E.width / 2),\n                    y: Math.round(G.y * F + y + E.height / 2)\n                };\n                var x = I.style;\n                x.left = B.x + \"px\";\n                x.top = B.y + \"px\";\n                x.display = this.fitsInCanvas(B, z) ? \"\" : \"none\";\n                D.onPlaceLabel(I, C)\n            }\n        });\n        w.Plot.NodeTypes = new q({\n            none: {\n                render: c.empty,\n                contains: c.lambda(false)\n            },\n            circle: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.circle.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.circle.contains(z, A, y)\n                }\n            },\n            ellipse: {\n                render: function(A, y) {\n                    var B = A.pos.getc(true), z = A.getData(\"width\"), x = A.getData(\"height\");\n                    this.nodeHelper.ellipse.render(\"fill\", B, z, x, y)\n                },\n                contains: function(z, B) {\n                    var A = z.pos.getc(true), y = z.getData(\"width\"), x = z.getData(\"height\");\n                    return this.nodeHelper.ellipse.contains(A, B, y, x)\n                }\n            },\n            square: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.square.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.square.contains(z, A, y)\n                }\n            },\n            rectangle: {\n                render: function(A, y) {\n                    var B = A.pos.getc(true), z = A.getData(\"width\"), x = A.getData(\"height\");\n                    this.nodeHelper.rectangle.render(\"fill\", B, z, x, y)\n                },\n                contains: function(z, B) {\n                    var A = z.pos.getc(true), y = z.getData(\"width\"), x = z.getData(\"height\");\n                    return this.nodeHelper.rectangle.contains(A, B, y, x)\n                }\n            },\n            triangle: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.triangle.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.triangle.contains(z, A, y)\n                }\n            },\n            star: {\n                render: function(y, x) {\n                    var A = y.pos.getc(true), z = y.getData(\"dim\");\n                    this.nodeHelper.star.render(\"fill\", A, z, x)\n                },\n                contains: function(x, A) {\n                    var z = x.pos.getc(true), y = x.getData(\"dim\");\n                    return this.nodeHelper.star.contains(z, A, y)\n                }\n            }\n        });\n        w.Plot.EdgeTypes = new q({\n            none: c.empty,\n            line: {\n                render: function(x, y) {\n                    var A = x.nodeFrom.pos.getc(true), z = x.nodeTo.pos.getc(true);\n                    this.edgeHelper.line.render(A, z, y)\n                },\n                contains: function(x, A) {\n                    var z = x.nodeFrom.pos.getc(true), y = x.nodeTo.pos.getc(true);\n                    return this.edgeHelper.line.contains(z, y, A, this.edge.epsilon)\n                }\n            },\n            arrow: {\n                render: function(y, z) {\n                    var D = y.nodeFrom.pos.getc(true), C = y.nodeTo.pos.getc(true), B = y.getData(\"dim\"), A = y.data.$direction, x = (A && A.length > 1 && A[0] != y.nodeFrom.id);\n                    this.edgeHelper.arrow.render(D, C, B, x, z)\n                },\n                contains: function(x, A) {\n                    var z = x.nodeFrom.pos.getc(true), y = x.nodeTo.pos.getc(true);\n                    return this.edgeHelper.arrow.contains(z, y, A, this.edge.epsilon)\n                }\n            }\n        })\n    })($jit.RGraph);\n    p.prototype.moebiusTransformation = function(y) {\n        var w = this.add(y);\n        var x = y.$conjugate().$prod(this);\n        x.x++;\n        return w.$div(x)\n    };\n    e.Util.moebiusTransformation = function(y, A, z, x, w) {\n        this.eachNode(y, function(C) {\n            for (var B = 0; B < z.length; B++) {\n                var E = A[B].scale(-1), D = x ? x: z[B];\n                C.getPos(z[B]).set(C.getPos(D).getc().moebiusTransformation(E))\n            }\n        }, w)\n    };\n    $jit.Hypertree = new q({\n        Implements: [d, o, g.Radial],\n        initialize: function(w) {\n            var z = $jit.Hypertree;\n            var x = {\n                radius: \"auto\",\n                offset: 0,\n                Edge: {\n                    type: \"hyperline\"\n                },\n                duration: 1500,\n                fps: 35\n            };\n            this.controller = this.config = c.merge(n(\"Canvas\", \"Node\", \"Edge\", \"Fx\", \"Tips\", \"NodeStyles\", \"Events\", \"Navigation\", \"Controller\", \"Label\"), x, w);\n            var y = this.config;\n            if (y.useCanvas) {\n                this.canvas = y.useCanvas;\n                this.config.labelContainer = this.canvas.id + \"-label\"\n            } else {\n                if (y.background) {\n                    y.background = c.merge({\n                        type: \"Circles\"\n                    }, y.background)\n                }\n                this.canvas = new l(this, y);\n                this.config.labelContainer = (typeof y.injectInto == \"string\" ? y.injectInto : y.injectInto.id) + \"-label\"\n            }\n            this.graphOptions = {\n                klass: b,\n                Node: {\n                    selected: false,\n                    exist: true,\n                    drawn: true\n                }\n            };\n            this.graph = new e(this.graphOptions, this.config.Node, this.config.Edge);\n            this.labels = new z.Label[y.Label.type](this);\n            this.fx = new z.Plot(this, z);\n            this.op = new z.Op(this);\n            this.json = null;\n            this.root = null;\n            this.busy = false;\n            this.initializeExtras()\n        },\n        createLevelDistanceFunc: function() {\n            var A = this.getRadius();\n            var C = 0, w = Math.max, x = this.config;\n            this.graph.eachNode(function(D) {\n                C = w(D._depth, C)\n            }, \"ignore\");\n            C++;\n            var B = function(D) {\n                return function(F) {\n                    F.scale = A;\n                    var H = F._depth + 1;\n                    var G = 0, E = Math.pow;\n                    while (H) {\n                        G += E(D, H--)\n                    }\n                    return G - x.offset\n                }\n            };\n            for (var z = 0.51; z <= 1; z += 0.01) {\n                var y = (1 - Math.pow(z, C)) / (1 - z);\n                if (y >= 2) {\n                    return B(z-0.01)\n                }\n            }\n            return B(0.75)\n        },\n        getRadius: function() {\n            var w = this.config.radius;\n            if (w !== \"auto\") {\n                return w\n            }\n            var x = this.canvas.getSize();\n            return Math.min(x.width, x.height) / 2\n        },\n        refresh: function(w) {\n            if (w) {\n                this.reposition();\n                this.graph.eachNode(function(x) {\n                    x.startPos.rho = x.pos.rho = x.endPos.rho;\n                    x.startPos.theta = x.pos.theta = x.endPos.theta\n                })\n            } else {\n                this.compute()\n            }\n            this.plot()\n        },\n        reposition: function() {\n            this.compute(\"end\");\n            var w = this.graph.getNode(this.root).pos.getc().scale(-1);\n            e.Util.moebiusTransformation(this.graph, [w], [\"end\"], \"end\", \"ignore\");\n            this.graph.eachNode(function(x) {\n                if (x.ignore) {\n                    x.endPos.rho = x.pos.rho;\n                    x.endPos.theta = x.pos.theta\n                }\n            })\n        },\n        plot: function() {\n            this.fx.plot()\n        },\n        onClick: function(y, w) {\n            var x = this.graph.getNode(y).pos.getc(true);\n            this.move(x, w)\n        },\n        move: function(A, y) {\n            var x = r(A.x, A.y);\n            if (this.busy === false && x.norm() < 1) {\n                this.busy = true;\n                var w = this.graph.getClosestNodeToPos(x), z = this;\n                this.graph.computeLevels(w.id, 0);\n                this.controller.onBeforeCompute(w);\n                y = c.merge({\n                    onComplete: c.empty\n                }, y || {});\n                this.fx.animate(c.merge({\n                    modes: [\"moebius\"],\n                    hideLabels: true\n                }, y, {\n                    onComplete: function() {\n                        z.busy = false;\n                        y.onComplete()\n                    }\n                }), x)\n            }\n        }\n    });\n    $jit.Hypertree.$extend = true;\n    (function(w) {\n        w.Op = new q({\n            Implements: e.Op\n        });\n        w.Plot = new q({\n            Implements: e.Plot\n        });\n        w.Label = {};\n        w.Label.Native = new q({\n            Implements: e.Label.Native,\n            initialize: function(x) {\n                this.viz = x\n            },\n            renderLabel: function(z, B, y) {\n                var x = z.getCtx();\n                var C = B.pos.getc(true);\n                var A = this.viz.getRadius();\n                x.fillText(B.name, C.x * A, C.y * A)\n            }\n        });\n        w.Label.SVG = new q({\n            Implements: e.Label.SVG,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(I, C, D) {\n                var G = C.pos.getc(true), z = this.viz.canvas, A = z.translateOffsetX, y = z.translateOffsetY, H = z.scaleOffsetX, F = z.scaleOffsetY, E = z.getSize(), x = this.viz.getRadius();\n                var B = {\n                    x: Math.round((G.x * H) * x + A + E.width / 2),\n                    y: Math.round((G.y * F) * x + y + E.height / 2)\n                };\n                I.setAttribute(\"x\", B.x);\n                I.setAttribute(\"y\", B.y);\n                D.onPlaceLabel(I, C)\n            }\n        });\n        w.Label.HTML = new q({\n            Implements: e.Label.HTML,\n            initialize: function(x) {\n                this.viz = x\n            },\n            placeLabel: function(J, D, E) {\n                var H = D.pos.getc(true), A = this.viz.canvas, B = A.translateOffsetX, z = A.translateOffsetY, I = A.scaleOffsetX, G = A.scaleOffsetY, F = A.getSize(), x = this.viz.getRadius();\n                var C = {\n                    x: Math.round((H.x * I) * x + B + F.width / 2),\n                    y: Math.round((H.y * G) * x + z + F.height / 2)\n                };\n                var y = J.style;\n                y.left = C.x + \"px\";\n                y.top = C.y + \"px\";\n                y.display = this.fitsInCanvas(C, A) ? \"\" : \"none\";\n                E.onPlaceLabel(J, D)\n            }\n        });\n        w.Plot.NodeTypes = new q({\n            none: {\n                render: c.empty,\n                contains: c.lambda(false)\n            },\n            circle: {\n                render: function(z, x) {\n                    var y = this.node, B = z.getData(\"dim\"), A = z.pos.getc();\n                    B = y.transform ? B * (1 - A.squaredNorm()) : B;\n                    A.$scale(z.scale);\n                    if (B > 0.2) {\n                        this.nodeHelper.circle.render(\"fill\", A, B, x)\n                    }\n                },\n                contains: function(x, A) {\n                    var y = x.getData(\"dim\"), z = x.pos.getc().$scale(x.scale);\n                    return this.nodeHelper.circle.contains(z, A, y)\n                }\n            },\n            ellipse: {\n                render: function(A, y) {\n                    var B = A.pos.getc().$scale(A.scale), z = A.getData(\"width\"), x = A.getData(\"height\");\n                    this.nodeHelper.ellipse.render(\"fill\", B, z, x, y)\n                },\n                contains: function(z, B) {\n                    var y = z.getData(\"width\"), x = z.getData(\"height\"), A = z.pos.getc().$scale(z.scale);\n                    return this.nodeHelper.circle.contains(A, B, y, x)\n                }\n            },\n            square: {\n                render: function(z, x) {\n                    var y = this.node, B = z.getData(\"dim\"), A = z.pos.getc();\n                    B = y.transform ? B * (1 - A.squaredNorm()) : B;\n                    A.$scale(z.scale);\n                    if (B > 0.2) {\n                        this.nodeHelper.square.render(\"fill\", A, B, x)\n                    }\n                },\n                contains: function(x, A) {\n                    var y = x.getData(\"dim\"), z = x.pos.getc().$scale(x.scale);\n                    return this.nodeHelper.square.contains(z, A, y)\n                }\n            },\n            rectangle: {\n                render: function(B, y) {\n                    var A = this.node, z = B.getData(\"width\"), x = B.getData(\"height\"), C = B.pos.getc();\n                    z = A.transform ? z * (1 - C.squaredNorm()) : z;\n                    x = A.transform ? x * (1 - C.squaredNorm()) : x;\n                    C.$scale(B.scale);\n                    if (z > 0.2 && x > 0.2) {\n                        this.nodeHelper.rectangle.render(\"fill\", C, z, x, y)\n                    }\n                },\n                contains: function(z, B) {\n                    var y = z.getData(\"width\"), x = z.getData(\"height\"), A = z.pos.getc().$scale(z.scale);\n                    return this.nodeHelper.rectangle.contains(A, B, y, x)\n                }\n            },\n            triangle: {\n                render: function(z, x) {\n                    var y = this.node, B = z.getData(\"dim\"), A = z.pos.getc();\n                    B = y.transform ? B * (1 - A.squaredNorm()) : B;\n                    A.$scale(z.scale);\n                    if (B > 0.2) {\n                        this.nodeHelper.triangle.render(\"fill\", A, B, x)\n                    }\n                },\n                contains: function(x, A) {\n                    var y = x.getData(\"dim\"), z = x.pos.getc().$scale(x.scale);\n                    return this.nodeHelper.triangle.contains(z, A, y)\n                }\n            },\n            star: {\n                render: function(z, x) {\n                    var y = this.node, B = z.getData(\"dim\"), A = z.pos.getc();\n                    B = y.transform ? B * (1 - A.squaredNorm()) : B;\n                    A.$scale(z.scale);\n                    if (B > 0.2) {\n                        this.nodeHelper.star.render(\"fill\", A, B, x)\n                    }\n                },\n                contains: function(x, A) {\n                    var y = x.getData(\"dim\"), z = x.pos.getc().$scale(x.scale);\n                    return this.nodeHelper.star.contains(z, A, y)\n                }\n            }\n        });\n        w.Plot.EdgeTypes = new q({\n            none: c.empty,\n            line: {\n                render: function(x, y) {\n                    var B = x.nodeFrom.pos.getc(true), A = x.nodeTo.pos.getc(true), z = x.nodeFrom.scale;\n                    this.edgeHelper.line.render({\n                        x: B.x * z,\n                        y: B.y * z\n                    }, {\n                        x: A.x * z,\n                        y: A.y * z\n                    }, y)\n                },\n                contains: function(x, B) {\n                    var A = x.nodeFrom.pos.getc(true), z = x.nodeTo.pos.getc(true), y = x.nodeFrom.scale;\n                    this.edgeHelper.line.contains({\n                        x: A.x * y,\n                        y: A.y * y\n                    }, {\n                        x: z.x * y,\n                        y: z.y * y\n                    }, B, this.edge.epsilon)\n                }\n            },\n            arrow: {\n                render: function(y, z) {\n                    var E = y.nodeFrom.pos.getc(true), D = y.nodeTo.pos.getc(true), A = y.nodeFrom.scale, C = y.getData(\"dim\"), B = y.data.$direction, x = (B && B.length > 1 && B[0] != y.nodeFrom.id);\n                    this.edgeHelper.arrow.render({\n                        x: E.x * A,\n                        y: E.y * A\n                    }, {\n                        x: D.x * A,\n                        y: D.y * A\n                    }, C, x, z)\n                },\n                contains: function(x, B) {\n                    var A = x.nodeFrom.pos.getc(true), z = x.nodeTo.pos.getc(true), y = x.nodeFrom.scale;\n                    this.edgeHelper.arrow.contains({\n                        x: A.x * y,\n                        y: A.y * y\n                    }, {\n                        x: z.x * y,\n                        y: z.y * y\n                    }, B, this.edge.epsilon)\n                }\n            },\n            hyperline: {\n                render: function(x, y) {\n                    var B = x.nodeFrom.pos.getc(), A = x.nodeTo.pos.getc(), z = this.viz.getRadius();\n                    this.edgeHelper.hyperline.render(B, A, z, y)\n                },\n                contains: c.lambda(false)\n            }\n        })\n    })($jit.Hypertree)\n})();\n","/*\nCopyright 2012 Igor Vaynberg\n\nVersion: 3.4.5 Timestamp: Mon Nov  4 08:22:42 PST 2013\n\nThis software is licensed under the Apache License, Version 2.0 (the \"Apache License\") or the GNU\nGeneral Public License version 2 (the \"GPL License\"). You may choose either license to govern your\nuse of this software only upon the condition that you accept all of the terms of either the Apache\nLicense or the GPL License.\n\nYou may obtain a copy of the Apache License and the GPL License at:\n\nhttp://www.apache.org/licenses/LICENSE-2.0\nhttp://www.gnu.org/licenses/gpl-2.0.html\n\nUnless required by applicable law or agreed to in writing, software distributed under the Apache License\nor the GPL Licesnse is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\neither express or implied. See the Apache License and the GPL License for the specific language governing\npermissions and limitations under the Apache License and the GPL License.\n*/\n!function(a){\"undefined\"==typeof a.fn.each2&&a.extend(a.fn,{each2:function(b){for(var c=a([0]),d=-1,e=this.length;++d<e&&(c.context=c[0]=this[d])&&b.call(c[0],d,c)!==!1;);return this}})}(jQuery),function(a,b){\"use strict\";function n(a){var b,c,d,e;if(!a||a.length<1)return a;for(b=\"\",c=0,d=a.length;d>c;c++)e=a.charAt(c),b+=m[e]||e;return b}function o(a,b){for(var c=0,d=b.length;d>c;c+=1)if(q(a,b[c]))return c;return-1}function p(){var b=a(l);b.appendTo(\"body\");var c={width:b.width()-b[0].clientWidth,height:b.height()-b[0].clientHeight};return b.remove(),c}function q(a,c){return a===c?!0:a===b||c===b?!1:null===a||null===c?!1:a.constructor===String?a+\"\"==c+\"\":c.constructor===String?c+\"\"==a+\"\":!1}function r(b,c){var d,e,f;if(null===b||b.length<1)return[];for(d=b.split(c),e=0,f=d.length;f>e;e+=1)d[e]=a.trim(d[e]);return d}function s(a){return a.outerWidth(!1)-a.width()}function t(c){var d=\"keyup-change-value\";c.on(\"keydown\",function(){a.data(c,d)===b&&a.data(c,d,c.val())}),c.on(\"keyup\",function(){var e=a.data(c,d);e!==b&&c.val()!==e&&(a.removeData(c,d),c.trigger(\"keyup-change\"))})}function u(c){c.on(\"mousemove\",function(c){var d=i;(d===b||d.x!==c.pageX||d.y!==c.pageY)&&a(c.target).trigger(\"mousemove-filtered\",c)})}function v(a,c,d){d=d||b;var e;return function(){var b=arguments;window.clearTimeout(e),e=window.setTimeout(function(){c.apply(d,b)},a)}}function w(a){var c,b=!1;return function(){return b===!1&&(c=a(),b=!0),c}}function x(a,b){var c=v(a,function(a){b.trigger(\"scroll-debounced\",a)});b.on(\"scroll\",function(a){o(a.target,b.get())>=0&&c(a)})}function y(a){a[0]!==document.activeElement&&window.setTimeout(function(){var d,b=a[0],c=a.val().length;a.focus(),a.is(\":visible\")&&b===document.activeElement&&(b.setSelectionRange?b.setSelectionRange(c,c):b.createTextRange&&(d=b.createTextRange(),d.collapse(!1),d.select()))},0)}function z(b){b=a(b)[0];var c=0,d=0;if(\"selectionStart\"in b)c=b.selectionStart,d=b.selectionEnd-c;else if(\"selection\"in document){b.focus();var e=document.selection.createRange();d=document.selection.createRange().text.length,e.moveStart(\"character\",-b.value.length),c=e.text.length-d}return{offset:c,length:d}}function A(a){a.preventDefault(),a.stopPropagation()}function B(a){a.preventDefault(),a.stopImmediatePropagation()}function C(b){if(!h){var c=b[0].currentStyle||window.getComputedStyle(b[0],null);h=a(document.createElement(\"div\")).css({position:\"absolute\",left:\"-10000px\",top:\"-10000px\",display:\"none\",fontSize:c.fontSize,fontFamily:c.fontFamily,fontStyle:c.fontStyle,fontWeight:c.fontWeight,letterSpacing:c.letterSpacing,textTransform:c.textTransform,whiteSpace:\"nowrap\"}),h.attr(\"class\",\"select2-sizer\"),a(\"body\").append(h)}return h.text(b.val()),h.width()}function D(b,c,d){var e,g,f=[];e=b.attr(\"class\"),e&&(e=\"\"+e,a(e.split(\" \")).each2(function(){0===this.indexOf(\"select2-\")&&f.push(this)})),e=c.attr(\"class\"),e&&(e=\"\"+e,a(e.split(\" \")).each2(function(){0!==this.indexOf(\"select2-\")&&(g=d(this),g&&f.push(g))})),b.attr(\"class\",f.join(\" \"))}function E(a,b,c,d){var e=n(a.toUpperCase()).indexOf(n(b.toUpperCase())),f=b.length;return 0>e?(c.push(d(a)),void 0):(c.push(d(a.substring(0,e))),c.push(\"<span class='select2-match'>\"),c.push(d(a.substring(e,e+f))),c.push(\"</span>\"),c.push(d(a.substring(e+f,a.length))),void 0)}function F(a){var b={\"\\\\\":\"&#92;\",\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\",\"/\":\"&#47;\"};return String(a).replace(/[&<>\"'\\/\\\\]/g,function(a){return b[a]})}function G(c){var d,e=null,f=c.quietMillis||100,g=c.url,h=this;return function(i){window.clearTimeout(d),d=window.setTimeout(function(){var d=c.data,f=g,j=c.transport||a.fn.select2.ajaxDefaults.transport,k={type:c.type||\"GET\",cache:c.cache||!1,jsonpCallback:c.jsonpCallback||b,dataType:c.dataType||\"json\"},l=a.extend({},a.fn.select2.ajaxDefaults.params,k);d=d?d.call(h,i.term,i.page,i.context):null,f=\"function\"==typeof f?f.call(h,i.term,i.page,i.context):f,e&&e.abort(),c.params&&(a.isFunction(c.params)?a.extend(l,c.params.call(h)):a.extend(l,c.params)),a.extend(l,{url:f,dataType:c.dataType,data:d,success:function(a){var b=c.results(a,i.page);i.callback(b)}}),e=j.call(h,l)},f)}}function H(b){var d,e,c=b,f=function(a){return\"\"+a.text};a.isArray(c)&&(e=c,c={results:e}),a.isFunction(c)===!1&&(e=c,c=function(){return e});var g=c();return g.text&&(f=g.text,a.isFunction(f)||(d=g.text,f=function(a){return a[d]})),function(b){var g,d=b.term,e={results:[]};return\"\"===d?(b.callback(c()),void 0):(g=function(c,e){var h,i;if(c=c[0],c.children){h={};for(i in c)c.hasOwnProperty(i)&&(h[i]=c[i]);h.children=[],a(c.children).each2(function(a,b){g(b,h.children)}),(h.children.length||b.matcher(d,f(h),c))&&e.push(h)}else b.matcher(d,f(c),c)&&e.push(c)},a(c().results).each2(function(a,b){g(b,e.results)}),b.callback(e),void 0)}}function I(c){var d=a.isFunction(c);return function(e){var f=e.term,g={results:[]};a(d?c():c).each(function(){var a=this.text!==b,c=a?this.text:this;(\"\"===f||e.matcher(f,c))&&g.results.push(a?this:{id:this,text:this})}),e.callback(g)}}function J(b,c){if(a.isFunction(b))return!0;if(!b)return!1;throw new Error(c+\" must be a function or a falsy value\")}function K(b){return a.isFunction(b)?b():b}function L(b){var c=0;return a.each(b,function(a,b){b.children?c+=L(b.children):c++}),c}function M(a,c,d,e){var h,i,j,k,l,f=a,g=!1;if(!e.createSearchChoice||!e.tokenSeparators||e.tokenSeparators.length<1)return b;for(;;){for(i=-1,j=0,k=e.tokenSeparators.length;k>j&&(l=e.tokenSeparators[j],i=a.indexOf(l),!(i>=0));j++);if(0>i)break;if(h=a.substring(0,i),a=a.substring(i+l.length),h.length>0&&(h=e.createSearchChoice.call(this,h,c),h!==b&&null!==h&&e.id(h)!==b&&null!==e.id(h))){for(g=!1,j=0,k=c.length;k>j;j++)if(q(e.id(h),e.id(c[j]))){g=!0;break}g||d(h)}}return f!==a?a:void 0}function N(b,c){var d=function(){};return d.prototype=new b,d.prototype.constructor=d,d.prototype.parent=b.prototype,d.prototype=a.extend(d.prototype,c),d}if(window.Select2===b){var c,d,e,f,g,h,j,k,i={x:0,y:0},c={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,isArrow:function(a){switch(a=a.which?a.which:a){case c.LEFT:case c.RIGHT:case c.UP:case c.DOWN:return!0}return!1},isControl:function(a){var b=a.which;switch(b){case c.SHIFT:case c.CTRL:case c.ALT:return!0}return a.metaKey?!0:!1},isFunctionKey:function(a){return a=a.which?a.which:a,a>=112&&123>=a}},l=\"<div class='select2-measure-scrollbar'></div>\",m={\"\\u24b6\":\"A\",\"\\uff21\":\"A\",\"\\xc0\":\"A\",\"\\xc1\":\"A\",\"\\xc2\":\"A\",\"\\u1ea6\":\"A\",\"\\u1ea4\":\"A\",\"\\u1eaa\":\"A\",\"\\u1ea8\":\"A\",\"\\xc3\":\"A\",\"\\u0100\":\"A\",\"\\u0102\":\"A\",\"\\u1eb0\":\"A\",\"\\u1eae\":\"A\",\"\\u1eb4\":\"A\",\"\\u1eb2\":\"A\",\"\\u0226\":\"A\",\"\\u01e0\":\"A\",\"\\xc4\":\"A\",\"\\u01de\":\"A\",\"\\u1ea2\":\"A\",\"\\xc5\":\"A\",\"\\u01fa\":\"A\",\"\\u01cd\":\"A\",\"\\u0200\":\"A\",\"\\u0202\":\"A\",\"\\u1ea0\":\"A\",\"\\u1eac\":\"A\",\"\\u1eb6\":\"A\",\"\\u1e00\":\"A\",\"\\u0104\":\"A\",\"\\u023a\":\"A\",\"\\u2c6f\":\"A\",\"\\ua732\":\"AA\",\"\\xc6\":\"AE\",\"\\u01fc\":\"AE\",\"\\u01e2\":\"AE\",\"\\ua734\":\"AO\",\"\\ua736\":\"AU\",\"\\ua738\":\"AV\",\"\\ua73a\":\"AV\",\"\\ua73c\":\"AY\",\"\\u24b7\":\"B\",\"\\uff22\":\"B\",\"\\u1e02\":\"B\",\"\\u1e04\":\"B\",\"\\u1e06\":\"B\",\"\\u0243\":\"B\",\"\\u0182\":\"B\",\"\\u0181\":\"B\",\"\\u24b8\":\"C\",\"\\uff23\":\"C\",\"\\u0106\":\"C\",\"\\u0108\":\"C\",\"\\u010a\":\"C\",\"\\u010c\":\"C\",\"\\xc7\":\"C\",\"\\u1e08\":\"C\",\"\\u0187\":\"C\",\"\\u023b\":\"C\",\"\\ua73e\":\"C\",\"\\u24b9\":\"D\",\"\\uff24\":\"D\",\"\\u1e0a\":\"D\",\"\\u010e\":\"D\",\"\\u1e0c\":\"D\",\"\\u1e10\":\"D\",\"\\u1e12\":\"D\",\"\\u1e0e\":\"D\",\"\\u0110\":\"D\",\"\\u018b\":\"D\",\"\\u018a\":\"D\",\"\\u0189\":\"D\",\"\\ua779\":\"D\",\"\\u01f1\":\"DZ\",\"\\u01c4\":\"DZ\",\"\\u01f2\":\"Dz\",\"\\u01c5\":\"Dz\",\"\\u24ba\":\"E\",\"\\uff25\":\"E\",\"\\xc8\":\"E\",\"\\xc9\":\"E\",\"\\xca\":\"E\",\"\\u1ec0\":\"E\",\"\\u1ebe\":\"E\",\"\\u1ec4\":\"E\",\"\\u1ec2\":\"E\",\"\\u1ebc\":\"E\",\"\\u0112\":\"E\",\"\\u1e14\":\"E\",\"\\u1e16\":\"E\",\"\\u0114\":\"E\",\"\\u0116\":\"E\",\"\\xcb\":\"E\",\"\\u1eba\":\"E\",\"\\u011a\":\"E\",\"\\u0204\":\"E\",\"\\u0206\":\"E\",\"\\u1eb8\":\"E\",\"\\u1ec6\":\"E\",\"\\u0228\":\"E\",\"\\u1e1c\":\"E\",\"\\u0118\":\"E\",\"\\u1e18\":\"E\",\"\\u1e1a\":\"E\",\"\\u0190\":\"E\",\"\\u018e\":\"E\",\"\\u24bb\":\"F\",\"\\uff26\":\"F\",\"\\u1e1e\":\"F\",\"\\u0191\":\"F\",\"\\ua77b\":\"F\",\"\\u24bc\":\"G\",\"\\uff27\":\"G\",\"\\u01f4\":\"G\",\"\\u011c\":\"G\",\"\\u1e20\":\"G\",\"\\u011e\":\"G\",\"\\u0120\":\"G\",\"\\u01e6\":\"G\",\"\\u0122\":\"G\",\"\\u01e4\":\"G\",\"\\u0193\":\"G\",\"\\ua7a0\":\"G\",\"\\ua77d\":\"G\",\"\\ua77e\":\"G\",\"\\u24bd\":\"H\",\"\\uff28\":\"H\",\"\\u0124\":\"H\",\"\\u1e22\":\"H\",\"\\u1e26\":\"H\",\"\\u021e\":\"H\",\"\\u1e24\":\"H\",\"\\u1e28\":\"H\",\"\\u1e2a\":\"H\",\"\\u0126\":\"H\",\"\\u2c67\":\"H\",\"\\u2c75\":\"H\",\"\\ua78d\":\"H\",\"\\u24be\":\"I\",\"\\uff29\":\"I\",\"\\xcc\":\"I\",\"\\xcd\":\"I\",\"\\xce\":\"I\",\"\\u0128\":\"I\",\"\\u012a\":\"I\",\"\\u012c\":\"I\",\"\\u0130\":\"I\",\"\\xcf\":\"I\",\"\\u1e2e\":\"I\",\"\\u1ec8\":\"I\",\"\\u01cf\":\"I\",\"\\u0208\":\"I\",\"\\u020a\":\"I\",\"\\u1eca\":\"I\",\"\\u012e\":\"I\",\"\\u1e2c\":\"I\",\"\\u0197\":\"I\",\"\\u24bf\":\"J\",\"\\uff2a\":\"J\",\"\\u0134\":\"J\",\"\\u0248\":\"J\",\"\\u24c0\":\"K\",\"\\uff2b\":\"K\",\"\\u1e30\":\"K\",\"\\u01e8\":\"K\",\"\\u1e32\":\"K\",\"\\u0136\":\"K\",\"\\u1e34\":\"K\",\"\\u0198\":\"K\",\"\\u2c69\":\"K\",\"\\ua740\":\"K\",\"\\ua742\":\"K\",\"\\ua744\":\"K\",\"\\ua7a2\":\"K\",\"\\u24c1\":\"L\",\"\\uff2c\":\"L\",\"\\u013f\":\"L\",\"\\u0139\":\"L\",\"\\u013d\":\"L\",\"\\u1e36\":\"L\",\"\\u1e38\":\"L\",\"\\u013b\":\"L\",\"\\u1e3c\":\"L\",\"\\u1e3a\":\"L\",\"\\u0141\":\"L\",\"\\u023d\":\"L\",\"\\u2c62\":\"L\",\"\\u2c60\":\"L\",\"\\ua748\":\"L\",\"\\ua746\":\"L\",\"\\ua780\":\"L\",\"\\u01c7\":\"LJ\",\"\\u01c8\":\"Lj\",\"\\u24c2\":\"M\",\"\\uff2d\":\"M\",\"\\u1e3e\":\"M\",\"\\u1e40\":\"M\",\"\\u1e42\":\"M\",\"\\u2c6e\":\"M\",\"\\u019c\":\"M\",\"\\u24c3\":\"N\",\"\\uff2e\":\"N\",\"\\u01f8\":\"N\",\"\\u0143\":\"N\",\"\\xd1\":\"N\",\"\\u1e44\":\"N\",\"\\u0147\":\"N\",\"\\u1e46\":\"N\",\"\\u0145\":\"N\",\"\\u1e4a\":\"N\",\"\\u1e48\":\"N\",\"\\u0220\":\"N\",\"\\u019d\":\"N\",\"\\ua790\":\"N\",\"\\ua7a4\":\"N\",\"\\u01ca\":\"NJ\",\"\\u01cb\":\"Nj\",\"\\u24c4\":\"O\",\"\\uff2f\":\"O\",\"\\xd2\":\"O\",\"\\xd3\":\"O\",\"\\xd4\":\"O\",\"\\u1ed2\":\"O\",\"\\u1ed0\":\"O\",\"\\u1ed6\":\"O\",\"\\u1ed4\":\"O\",\"\\xd5\":\"O\",\"\\u1e4c\":\"O\",\"\\u022c\":\"O\",\"\\u1e4e\":\"O\",\"\\u014c\":\"O\",\"\\u1e50\":\"O\",\"\\u1e52\":\"O\",\"\\u014e\":\"O\",\"\\u022e\":\"O\",\"\\u0230\":\"O\",\"\\xd6\":\"O\",\"\\u022a\":\"O\",\"\\u1ece\":\"O\",\"\\u0150\":\"O\",\"\\u01d1\":\"O\",\"\\u020c\":\"O\",\"\\u020e\":\"O\",\"\\u01a0\":\"O\",\"\\u1edc\":\"O\",\"\\u1eda\":\"O\",\"\\u1ee0\":\"O\",\"\\u1ede\":\"O\",\"\\u1ee2\":\"O\",\"\\u1ecc\":\"O\",\"\\u1ed8\":\"O\",\"\\u01ea\":\"O\",\"\\u01ec\":\"O\",\"\\xd8\":\"O\",\"\\u01fe\":\"O\",\"\\u0186\":\"O\",\"\\u019f\":\"O\",\"\\ua74a\":\"O\",\"\\ua74c\":\"O\",\"\\u01a2\":\"OI\",\"\\ua74e\":\"OO\",\"\\u0222\":\"OU\",\"\\u24c5\":\"P\",\"\\uff30\":\"P\",\"\\u1e54\":\"P\",\"\\u1e56\":\"P\",\"\\u01a4\":\"P\",\"\\u2c63\":\"P\",\"\\ua750\":\"P\",\"\\ua752\":\"P\",\"\\ua754\":\"P\",\"\\u24c6\":\"Q\",\"\\uff31\":\"Q\",\"\\ua756\":\"Q\",\"\\ua758\":\"Q\",\"\\u024a\":\"Q\",\"\\u24c7\":\"R\",\"\\uff32\":\"R\",\"\\u0154\":\"R\",\"\\u1e58\":\"R\",\"\\u0158\":\"R\",\"\\u0210\":\"R\",\"\\u0212\":\"R\",\"\\u1e5a\":\"R\",\"\\u1e5c\":\"R\",\"\\u0156\":\"R\",\"\\u1e5e\":\"R\",\"\\u024c\":\"R\",\"\\u2c64\":\"R\",\"\\ua75a\":\"R\",\"\\ua7a6\":\"R\",\"\\ua782\":\"R\",\"\\u24c8\":\"S\",\"\\uff33\":\"S\",\"\\u1e9e\":\"S\",\"\\u015a\":\"S\",\"\\u1e64\":\"S\",\"\\u015c\":\"S\",\"\\u1e60\":\"S\",\"\\u0160\":\"S\",\"\\u1e66\":\"S\",\"\\u1e62\":\"S\",\"\\u1e68\":\"S\",\"\\u0218\":\"S\",\"\\u015e\":\"S\",\"\\u2c7e\":\"S\",\"\\ua7a8\":\"S\",\"\\ua784\":\"S\",\"\\u24c9\":\"T\",\"\\uff34\":\"T\",\"\\u1e6a\":\"T\",\"\\u0164\":\"T\",\"\\u1e6c\":\"T\",\"\\u021a\":\"T\",\"\\u0162\":\"T\",\"\\u1e70\":\"T\",\"\\u1e6e\":\"T\",\"\\u0166\":\"T\",\"\\u01ac\":\"T\",\"\\u01ae\":\"T\",\"\\u023e\":\"T\",\"\\ua786\":\"T\",\"\\ua728\":\"TZ\",\"\\u24ca\":\"U\",\"\\uff35\":\"U\",\"\\xd9\":\"U\",\"\\xda\":\"U\",\"\\xdb\":\"U\",\"\\u0168\":\"U\",\"\\u1e78\":\"U\",\"\\u016a\":\"U\",\"\\u1e7a\":\"U\",\"\\u016c\":\"U\",\"\\xdc\":\"U\",\"\\u01db\":\"U\",\"\\u01d7\":\"U\",\"\\u01d5\":\"U\",\"\\u01d9\":\"U\",\"\\u1ee6\":\"U\",\"\\u016e\":\"U\",\"\\u0170\":\"U\",\"\\u01d3\":\"U\",\"\\u0214\":\"U\",\"\\u0216\":\"U\",\"\\u01af\":\"U\",\"\\u1eea\":\"U\",\"\\u1ee8\":\"U\",\"\\u1eee\":\"U\",\"\\u1eec\":\"U\",\"\\u1ef0\":\"U\",\"\\u1ee4\":\"U\",\"\\u1e72\":\"U\",\"\\u0172\":\"U\",\"\\u1e76\":\"U\",\"\\u1e74\":\"U\",\"\\u0244\":\"U\",\"\\u24cb\":\"V\",\"\\uff36\":\"V\",\"\\u1e7c\":\"V\",\"\\u1e7e\":\"V\",\"\\u01b2\":\"V\",\"\\ua75e\":\"V\",\"\\u0245\":\"V\",\"\\ua760\":\"VY\",\"\\u24cc\":\"W\",\"\\uff37\":\"W\",\"\\u1e80\":\"W\",\"\\u1e82\":\"W\",\"\\u0174\":\"W\",\"\\u1e86\":\"W\",\"\\u1e84\":\"W\",\"\\u1e88\":\"W\",\"\\u2c72\":\"W\",\"\\u24cd\":\"X\",\"\\uff38\":\"X\",\"\\u1e8a\":\"X\",\"\\u1e8c\":\"X\",\"\\u24ce\":\"Y\",\"\\uff39\":\"Y\",\"\\u1ef2\":\"Y\",\"\\xdd\":\"Y\",\"\\u0176\":\"Y\",\"\\u1ef8\":\"Y\",\"\\u0232\":\"Y\",\"\\u1e8e\":\"Y\",\"\\u0178\":\"Y\",\"\\u1ef6\":\"Y\",\"\\u1ef4\":\"Y\",\"\\u01b3\":\"Y\",\"\\u024e\":\"Y\",\"\\u1efe\":\"Y\",\"\\u24cf\":\"Z\",\"\\uff3a\":\"Z\",\"\\u0179\":\"Z\",\"\\u1e90\":\"Z\",\"\\u017b\":\"Z\",\"\\u017d\":\"Z\",\"\\u1e92\":\"Z\",\"\\u1e94\":\"Z\",\"\\u01b5\":\"Z\",\"\\u0224\":\"Z\",\"\\u2c7f\":\"Z\",\"\\u2c6b\":\"Z\",\"\\ua762\":\"Z\",\"\\u24d0\":\"a\",\"\\uff41\":\"a\",\"\\u1e9a\":\"a\",\"\\xe0\":\"a\",\"\\xe1\":\"a\",\"\\xe2\":\"a\",\"\\u1ea7\":\"a\",\"\\u1ea5\":\"a\",\"\\u1eab\":\"a\",\"\\u1ea9\":\"a\",\"\\xe3\":\"a\",\"\\u0101\":\"a\",\"\\u0103\":\"a\",\"\\u1eb1\":\"a\",\"\\u1eaf\":\"a\",\"\\u1eb5\":\"a\",\"\\u1eb3\":\"a\",\"\\u0227\":\"a\",\"\\u01e1\":\"a\",\"\\xe4\":\"a\",\"\\u01df\":\"a\",\"\\u1ea3\":\"a\",\"\\xe5\":\"a\",\"\\u01fb\":\"a\",\"\\u01ce\":\"a\",\"\\u0201\":\"a\",\"\\u0203\":\"a\",\"\\u1ea1\":\"a\",\"\\u1ead\":\"a\",\"\\u1eb7\":\"a\",\"\\u1e01\":\"a\",\"\\u0105\":\"a\",\"\\u2c65\":\"a\",\"\\u0250\":\"a\",\"\\ua733\":\"aa\",\"\\xe6\":\"ae\",\"\\u01fd\":\"ae\",\"\\u01e3\":\"ae\",\"\\ua735\":\"ao\",\"\\ua737\":\"au\",\"\\ua739\":\"av\",\"\\ua73b\":\"av\",\"\\ua73d\":\"ay\",\"\\u24d1\":\"b\",\"\\uff42\":\"b\",\"\\u1e03\":\"b\",\"\\u1e05\":\"b\",\"\\u1e07\":\"b\",\"\\u0180\":\"b\",\"\\u0183\":\"b\",\"\\u0253\":\"b\",\"\\u24d2\":\"c\",\"\\uff43\":\"c\",\"\\u0107\":\"c\",\"\\u0109\":\"c\",\"\\u010b\":\"c\",\"\\u010d\":\"c\",\"\\xe7\":\"c\",\"\\u1e09\":\"c\",\"\\u0188\":\"c\",\"\\u023c\":\"c\",\"\\ua73f\":\"c\",\"\\u2184\":\"c\",\"\\u24d3\":\"d\",\"\\uff44\":\"d\",\"\\u1e0b\":\"d\",\"\\u010f\":\"d\",\"\\u1e0d\":\"d\",\"\\u1e11\":\"d\",\"\\u1e13\":\"d\",\"\\u1e0f\":\"d\",\"\\u0111\":\"d\",\"\\u018c\":\"d\",\"\\u0256\":\"d\",\"\\u0257\":\"d\",\"\\ua77a\":\"d\",\"\\u01f3\":\"dz\",\"\\u01c6\":\"dz\",\"\\u24d4\":\"e\",\"\\uff45\":\"e\",\"\\xe8\":\"e\",\"\\xe9\":\"e\",\"\\xea\":\"e\",\"\\u1ec1\":\"e\",\"\\u1ebf\":\"e\",\"\\u1ec5\":\"e\",\"\\u1ec3\":\"e\",\"\\u1ebd\":\"e\",\"\\u0113\":\"e\",\"\\u1e15\":\"e\",\"\\u1e17\":\"e\",\"\\u0115\":\"e\",\"\\u0117\":\"e\",\"\\xeb\":\"e\",\"\\u1ebb\":\"e\",\"\\u011b\":\"e\",\"\\u0205\":\"e\",\"\\u0207\":\"e\",\"\\u1eb9\":\"e\",\"\\u1ec7\":\"e\",\"\\u0229\":\"e\",\"\\u1e1d\":\"e\",\"\\u0119\":\"e\",\"\\u1e19\":\"e\",\"\\u1e1b\":\"e\",\"\\u0247\":\"e\",\"\\u025b\":\"e\",\"\\u01dd\":\"e\",\"\\u24d5\":\"f\",\"\\uff46\":\"f\",\"\\u1e1f\":\"f\",\"\\u0192\":\"f\",\"\\ua77c\":\"f\",\"\\u24d6\":\"g\",\"\\uff47\":\"g\",\"\\u01f5\":\"g\",\"\\u011d\":\"g\",\"\\u1e21\":\"g\",\"\\u011f\":\"g\",\"\\u0121\":\"g\",\"\\u01e7\":\"g\",\"\\u0123\":\"g\",\"\\u01e5\":\"g\",\"\\u0260\":\"g\",\"\\ua7a1\":\"g\",\"\\u1d79\":\"g\",\"\\ua77f\":\"g\",\"\\u24d7\":\"h\",\"\\uff48\":\"h\",\"\\u0125\":\"h\",\"\\u1e23\":\"h\",\"\\u1e27\":\"h\",\"\\u021f\":\"h\",\"\\u1e25\":\"h\",\"\\u1e29\":\"h\",\"\\u1e2b\":\"h\",\"\\u1e96\":\"h\",\"\\u0127\":\"h\",\"\\u2c68\":\"h\",\"\\u2c76\":\"h\",\"\\u0265\":\"h\",\"\\u0195\":\"hv\",\"\\u24d8\":\"i\",\"\\uff49\":\"i\",\"\\xec\":\"i\",\"\\xed\":\"i\",\"\\xee\":\"i\",\"\\u0129\":\"i\",\"\\u012b\":\"i\",\"\\u012d\":\"i\",\"\\xef\":\"i\",\"\\u1e2f\":\"i\",\"\\u1ec9\":\"i\",\"\\u01d0\":\"i\",\"\\u0209\":\"i\",\"\\u020b\":\"i\",\"\\u1ecb\":\"i\",\"\\u012f\":\"i\",\"\\u1e2d\":\"i\",\"\\u0268\":\"i\",\"\\u0131\":\"i\",\"\\u24d9\":\"j\",\"\\uff4a\":\"j\",\"\\u0135\":\"j\",\"\\u01f0\":\"j\",\"\\u0249\":\"j\",\"\\u24da\":\"k\",\"\\uff4b\":\"k\",\"\\u1e31\":\"k\",\"\\u01e9\":\"k\",\"\\u1e33\":\"k\",\"\\u0137\":\"k\",\"\\u1e35\":\"k\",\"\\u0199\":\"k\",\"\\u2c6a\":\"k\",\"\\ua741\":\"k\",\"\\ua743\":\"k\",\"\\ua745\":\"k\",\"\\ua7a3\":\"k\",\"\\u24db\":\"l\",\"\\uff4c\":\"l\",\"\\u0140\":\"l\",\"\\u013a\":\"l\",\"\\u013e\":\"l\",\"\\u1e37\":\"l\",\"\\u1e39\":\"l\",\"\\u013c\":\"l\",\"\\u1e3d\":\"l\",\"\\u1e3b\":\"l\",\"\\u017f\":\"l\",\"\\u0142\":\"l\",\"\\u019a\":\"l\",\"\\u026b\":\"l\",\"\\u2c61\":\"l\",\"\\ua749\":\"l\",\"\\ua781\":\"l\",\"\\ua747\":\"l\",\"\\u01c9\":\"lj\",\"\\u24dc\":\"m\",\"\\uff4d\":\"m\",\"\\u1e3f\":\"m\",\"\\u1e41\":\"m\",\"\\u1e43\":\"m\",\"\\u0271\":\"m\",\"\\u026f\":\"m\",\"\\u24dd\":\"n\",\"\\uff4e\":\"n\",\"\\u01f9\":\"n\",\"\\u0144\":\"n\",\"\\xf1\":\"n\",\"\\u1e45\":\"n\",\"\\u0148\":\"n\",\"\\u1e47\":\"n\",\"\\u0146\":\"n\",\"\\u1e4b\":\"n\",\"\\u1e49\":\"n\",\"\\u019e\":\"n\",\"\\u0272\":\"n\",\"\\u0149\":\"n\",\"\\ua791\":\"n\",\"\\ua7a5\":\"n\",\"\\u01cc\":\"nj\",\"\\u24de\":\"o\",\"\\uff4f\":\"o\",\"\\xf2\":\"o\",\"\\xf3\":\"o\",\"\\xf4\":\"o\",\"\\u1ed3\":\"o\",\"\\u1ed1\":\"o\",\"\\u1ed7\":\"o\",\"\\u1ed5\":\"o\",\"\\xf5\":\"o\",\"\\u1e4d\":\"o\",\"\\u022d\":\"o\",\"\\u1e4f\":\"o\",\"\\u014d\":\"o\",\"\\u1e51\":\"o\",\"\\u1e53\":\"o\",\"\\u014f\":\"o\",\"\\u022f\":\"o\",\"\\u0231\":\"o\",\"\\xf6\":\"o\",\"\\u022b\":\"o\",\"\\u1ecf\":\"o\",\"\\u0151\":\"o\",\"\\u01d2\":\"o\",\"\\u020d\":\"o\",\"\\u020f\":\"o\",\"\\u01a1\":\"o\",\"\\u1edd\":\"o\",\"\\u1edb\":\"o\",\"\\u1ee1\":\"o\",\"\\u1edf\":\"o\",\"\\u1ee3\":\"o\",\"\\u1ecd\":\"o\",\"\\u1ed9\":\"o\",\"\\u01eb\":\"o\",\"\\u01ed\":\"o\",\"\\xf8\":\"o\",\"\\u01ff\":\"o\",\"\\u0254\":\"o\",\"\\ua74b\":\"o\",\"\\ua74d\":\"o\",\"\\u0275\":\"o\",\"\\u01a3\":\"oi\",\"\\u0223\":\"ou\",\"\\ua74f\":\"oo\",\"\\u24df\":\"p\",\"\\uff50\":\"p\",\"\\u1e55\":\"p\",\"\\u1e57\":\"p\",\"\\u01a5\":\"p\",\"\\u1d7d\":\"p\",\"\\ua751\":\"p\",\"\\ua753\":\"p\",\"\\ua755\":\"p\",\"\\u24e0\":\"q\",\"\\uff51\":\"q\",\"\\u024b\":\"q\",\"\\ua757\":\"q\",\"\\ua759\":\"q\",\"\\u24e1\":\"r\",\"\\uff52\":\"r\",\"\\u0155\":\"r\",\"\\u1e59\":\"r\",\"\\u0159\":\"r\",\"\\u0211\":\"r\",\"\\u0213\":\"r\",\"\\u1e5b\":\"r\",\"\\u1e5d\":\"r\",\"\\u0157\":\"r\",\"\\u1e5f\":\"r\",\"\\u024d\":\"r\",\"\\u027d\":\"r\",\"\\ua75b\":\"r\",\"\\ua7a7\":\"r\",\"\\ua783\":\"r\",\"\\u24e2\":\"s\",\"\\uff53\":\"s\",\"\\xdf\":\"s\",\"\\u015b\":\"s\",\"\\u1e65\":\"s\",\"\\u015d\":\"s\",\"\\u1e61\":\"s\",\"\\u0161\":\"s\",\"\\u1e67\":\"s\",\"\\u1e63\":\"s\",\"\\u1e69\":\"s\",\"\\u0219\":\"s\",\"\\u015f\":\"s\",\"\\u023f\":\"s\",\"\\ua7a9\":\"s\",\"\\ua785\":\"s\",\"\\u1e9b\":\"s\",\"\\u24e3\":\"t\",\"\\uff54\":\"t\",\"\\u1e6b\":\"t\",\"\\u1e97\":\"t\",\"\\u0165\":\"t\",\"\\u1e6d\":\"t\",\"\\u021b\":\"t\",\"\\u0163\":\"t\",\"\\u1e71\":\"t\",\"\\u1e6f\":\"t\",\"\\u0167\":\"t\",\"\\u01ad\":\"t\",\"\\u0288\":\"t\",\"\\u2c66\":\"t\",\"\\ua787\":\"t\",\"\\ua729\":\"tz\",\"\\u24e4\":\"u\",\"\\uff55\":\"u\",\"\\xf9\":\"u\",\"\\xfa\":\"u\",\"\\xfb\":\"u\",\"\\u0169\":\"u\",\"\\u1e79\":\"u\",\"\\u016b\":\"u\",\"\\u1e7b\":\"u\",\"\\u016d\":\"u\",\"\\xfc\":\"u\",\"\\u01dc\":\"u\",\"\\u01d8\":\"u\",\"\\u01d6\":\"u\",\"\\u01da\":\"u\",\"\\u1ee7\":\"u\",\"\\u016f\":\"u\",\"\\u0171\":\"u\",\"\\u01d4\":\"u\",\"\\u0215\":\"u\",\"\\u0217\":\"u\",\"\\u01b0\":\"u\",\"\\u1eeb\":\"u\",\"\\u1ee9\":\"u\",\"\\u1eef\":\"u\",\"\\u1eed\":\"u\",\"\\u1ef1\":\"u\",\"\\u1ee5\":\"u\",\"\\u1e73\":\"u\",\"\\u0173\":\"u\",\"\\u1e77\":\"u\",\"\\u1e75\":\"u\",\"\\u0289\":\"u\",\"\\u24e5\":\"v\",\"\\uff56\":\"v\",\"\\u1e7d\":\"v\",\"\\u1e7f\":\"v\",\"\\u028b\":\"v\",\"\\ua75f\":\"v\",\"\\u028c\":\"v\",\"\\ua761\":\"vy\",\"\\u24e6\":\"w\",\"\\uff57\":\"w\",\"\\u1e81\":\"w\",\"\\u1e83\":\"w\",\"\\u0175\":\"w\",\"\\u1e87\":\"w\",\"\\u1e85\":\"w\",\"\\u1e98\":\"w\",\"\\u1e89\":\"w\",\"\\u2c73\":\"w\",\"\\u24e7\":\"x\",\"\\uff58\":\"x\",\"\\u1e8b\":\"x\",\"\\u1e8d\":\"x\",\"\\u24e8\":\"y\",\"\\uff59\":\"y\",\"\\u1ef3\":\"y\",\"\\xfd\":\"y\",\"\\u0177\":\"y\",\"\\u1ef9\":\"y\",\"\\u0233\":\"y\",\"\\u1e8f\":\"y\",\"\\xff\":\"y\",\"\\u1ef7\":\"y\",\"\\u1e99\":\"y\",\"\\u1ef5\":\"y\",\"\\u01b4\":\"y\",\"\\u024f\":\"y\",\"\\u1eff\":\"y\",\"\\u24e9\":\"z\",\"\\uff5a\":\"z\",\"\\u017a\":\"z\",\"\\u1e91\":\"z\",\"\\u017c\":\"z\",\"\\u017e\":\"z\",\"\\u1e93\":\"z\",\"\\u1e95\":\"z\",\"\\u01b6\":\"z\",\"\\u0225\":\"z\",\"\\u0240\":\"z\",\"\\u2c6c\":\"z\",\"\\ua763\":\"z\"};j=a(document),g=function(){var a=1;return function(){return a++}}(),j.on(\"mousemove\",function(a){i.x=a.pageX,i.y=a.pageY}),d=N(Object,{bind:function(a){var b=this;return function(){a.apply(b,arguments)}},init:function(c){var d,e,f=\".select2-results\";this.opts=c=this.prepareOpts(c),this.id=c.id,c.element.data(\"select2\")!==b&&null!==c.element.data(\"select2\")&&c.element.data(\"select2\").destroy(),this.container=this.createContainer(),this.containerId=\"s2id_\"+(c.element.attr(\"id\")||\"autogen\"+g()),this.containerSelector=\"#\"+this.containerId.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g,\"\\\\$1\"),this.container.attr(\"id\",this.containerId),this.body=w(function(){return c.element.closest(\"body\")}),D(this.container,this.opts.element,this.opts.adaptContainerCssClass),this.container.attr(\"style\",c.element.attr(\"style\")),this.container.css(K(c.containerCss)),this.container.addClass(K(c.containerCssClass)),this.elementTabIndex=this.opts.element.attr(\"tabindex\"),this.opts.element.data(\"select2\",this).attr(\"tabindex\",\"-1\").before(this.container).on(\"click.select2\",A),this.container.data(\"select2\",this),this.dropdown=this.container.find(\".select2-drop\"),D(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass),this.dropdown.addClass(K(c.dropdownCssClass)),this.dropdown.data(\"select2\",this),this.dropdown.on(\"click\",A),this.results=d=this.container.find(f),this.search=e=this.container.find(\"input.select2-input\"),this.queryCount=0,this.resultsPage=0,this.context=null,this.initContainer(),this.container.on(\"click\",A),u(this.results),this.dropdown.on(\"mousemove-filtered touchstart touchmove touchend\",f,this.bind(this.highlightUnderEvent)),x(80,this.results),this.dropdown.on(\"scroll-debounced\",f,this.bind(this.loadMoreIfNeeded)),a(this.container).on(\"change\",\".select2-input\",function(a){a.stopPropagation()}),a(this.dropdown).on(\"change\",\".select2-input\",function(a){a.stopPropagation()}),a.fn.mousewheel&&d.mousewheel(function(a,b,c,e){var f=d.scrollTop();e>0&&0>=f-e?(d.scrollTop(0),A(a)):0>e&&d.get(0).scrollHeight-d.scrollTop()+e<=d.height()&&(d.scrollTop(d.get(0).scrollHeight-d.height()),A(a))}),t(e),e.on(\"keyup-change input paste\",this.bind(this.updateResults)),e.on(\"focus\",function(){e.addClass(\"select2-focused\")}),e.on(\"blur\",function(){e.removeClass(\"select2-focused\")}),this.dropdown.on(\"mouseup\",f,this.bind(function(b){a(b.target).closest(\".select2-result-selectable\").length>0&&(this.highlightUnderEvent(b),this.selectHighlighted(b))})),this.dropdown.on(\"click mouseup mousedown\",function(a){a.stopPropagation()}),a.isFunction(this.opts.initSelection)&&(this.initSelection(),this.monitorSource()),null!==c.maximumInputLength&&this.search.attr(\"maxlength\",c.maximumInputLength);var h=c.element.prop(\"disabled\");h===b&&(h=!1),this.enable(!h);var i=c.element.prop(\"readonly\");i===b&&(i=!1),this.readonly(i),k=k||p(),this.autofocus=c.element.prop(\"autofocus\"),c.element.prop(\"autofocus\",!1),this.autofocus&&this.focus(),this.nextSearchTerm=b},destroy:function(){var a=this.opts.element,c=a.data(\"select2\");this.close(),this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null),c!==b&&(c.container.remove(),c.dropdown.remove(),a.removeClass(\"select2-offscreen\").removeData(\"select2\").off(\".select2\").prop(\"autofocus\",this.autofocus||!1),this.elementTabIndex?a.attr({tabindex:this.elementTabIndex}):a.removeAttr(\"tabindex\"),a.show())},optionToData:function(a){return a.is(\"option\")?{id:a.prop(\"value\"),text:a.text(),element:a.get(),css:a.attr(\"class\"),disabled:a.prop(\"disabled\"),locked:q(a.attr(\"locked\"),\"locked\")||q(a.data(\"locked\"),!0)}:a.is(\"optgroup\")?{text:a.attr(\"label\"),children:[],element:a.get(),css:a.attr(\"class\")}:void 0},prepareOpts:function(c){var d,e,f,g,h=this;if(d=c.element,\"select\"===d.get(0).tagName.toLowerCase()&&(this.select=e=c.element),e&&a.each([\"id\",\"multiple\",\"ajax\",\"query\",\"createSearchChoice\",\"initSelection\",\"data\",\"tags\"],function(){if(this in c)throw new Error(\"Option '\"+this+\"' is not allowed for Select2 when attached to a <select> element.\")}),c=a.extend({},{populateResults:function(d,e,f){var g,i=this.opts.id;g=function(d,e,j){var k,l,m,n,o,p,q,r,s,t;for(d=c.sortResults(d,e,f),k=0,l=d.length;l>k;k+=1)m=d[k],o=m.disabled===!0,n=!o&&i(m)!==b,p=m.children&&m.children.length>0,q=a(\"<li></li>\"),q.addClass(\"select2-results-dept-\"+j),q.addClass(\"select2-result\"),q.addClass(n?\"select2-result-selectable\":\"select2-result-unselectable\"),o&&q.addClass(\"select2-disabled\"),p&&q.addClass(\"select2-result-with-children\"),q.addClass(h.opts.formatResultCssClass(m)),r=a(document.createElement(\"div\")),r.addClass(\"select2-result-label\"),t=c.formatResult(m,r,f,h.opts.escapeMarkup),t!==b&&r.html(t),q.append(r),p&&(s=a(\"<ul></ul>\"),s.addClass(\"select2-result-sub\"),g(m.children,s,j+1),q.append(s)),q.data(\"select2-data\",m),e.append(q)},g(e,d,0)}},a.fn.select2.defaults,c),\"function\"!=typeof c.id&&(f=c.id,c.id=function(a){return a[f]}),a.isArray(c.element.data(\"select2Tags\"))){if(\"tags\"in c)throw\"tags specified as both an attribute 'data-select2-tags' and in options of Select2 \"+c.element.attr(\"id\");c.tags=c.element.data(\"select2Tags\")}if(e?(c.query=this.bind(function(a){var f,g,i,c={results:[],more:!1},e=a.term;i=function(b,c){var d;b.is(\"option\")?a.matcher(e,b.text(),b)&&c.push(h.optionToData(b)):b.is(\"optgroup\")&&(d=h.optionToData(b),b.children().each2(function(a,b){i(b,d.children)}),d.children.length>0&&c.push(d))},f=d.children(),this.getPlaceholder()!==b&&f.length>0&&(g=this.getPlaceholderOption(),g&&(f=f.not(g))),f.each2(function(a,b){i(b,c.results)}),a.callback(c)}),c.id=function(a){return a.id},c.formatResultCssClass=function(a){return a.css}):\"query\"in c||(\"ajax\"in c?(g=c.element.data(\"ajax-url\"),g&&g.length>0&&(c.ajax.url=g),c.query=G.call(c.element,c.ajax)):\"data\"in c?c.query=H(c.data):\"tags\"in c&&(c.query=I(c.tags),c.createSearchChoice===b&&(c.createSearchChoice=function(b){return{id:a.trim(b),text:a.trim(b)}}),c.initSelection===b&&(c.initSelection=function(b,d){var e=[];a(r(b.val(),c.separator)).each(function(){var b={id:this,text:this},d=c.tags;a.isFunction(d)&&(d=d()),a(d).each(function(){return q(this.id,b.id)?(b=this,!1):void 0}),e.push(b)}),d(e)}))),\"function\"!=typeof c.query)throw\"query function not defined for Select2 \"+c.element.attr(\"id\");return c},monitorSource:function(){var c,d,a=this.opts.element;a.on(\"change.select2\",this.bind(function(){this.opts.element.data(\"select2-change-triggered\")!==!0&&this.initSelection()})),c=this.bind(function(){var c=a.prop(\"disabled\");c===b&&(c=!1),this.enable(!c);var d=a.prop(\"readonly\");d===b&&(d=!1),this.readonly(d),D(this.container,this.opts.element,this.opts.adaptContainerCssClass),this.container.addClass(K(this.opts.containerCssClass)),D(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass),this.dropdown.addClass(K(this.opts.dropdownCssClass))}),a.on(\"propertychange.select2\",c),this.mutationCallback===b&&(this.mutationCallback=function(a){a.forEach(c)}),d=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver,d!==b&&(this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null),this.propertyObserver=new d(this.mutationCallback),this.propertyObserver.observe(a.get(0),{attributes:!0,subtree:!1}))},triggerSelect:function(b){var c=a.Event(\"select2-selecting\",{val:this.id(b),object:b});return this.opts.element.trigger(c),!c.isDefaultPrevented()},triggerChange:function(b){b=b||{},b=a.extend({},b,{type:\"change\",val:this.val()}),this.opts.element.data(\"select2-change-triggered\",!0),this.opts.element.trigger(b),this.opts.element.data(\"select2-change-triggered\",!1),this.opts.element.click(),this.opts.blurOnChange&&this.opts.element.blur()},isInterfaceEnabled:function(){return this.enabledInterface===!0},enableInterface:function(){var a=this._enabled&&!this._readonly,b=!a;return a===this.enabledInterface?!1:(this.container.toggleClass(\"select2-container-disabled\",b),this.close(),this.enabledInterface=a,!0)},enable:function(a){a===b&&(a=!0),this._enabled!==a&&(this._enabled=a,this.opts.element.prop(\"disabled\",!a),this.enableInterface())},disable:function(){this.enable(!1)},readonly:function(a){return a===b&&(a=!1),this._readonly===a?!1:(this._readonly=a,this.opts.element.prop(\"readonly\",a),this.enableInterface(),!0)},opened:function(){return this.container.hasClass(\"select2-dropdown-open\")},positionDropdown:function(){var t,u,v,w,x,b=this.dropdown,c=this.container.offset(),d=this.container.outerHeight(!1),e=this.container.outerWidth(!1),f=b.outerHeight(!1),g=a(window),h=g.width(),i=g.height(),j=g.scrollLeft()+h,l=g.scrollTop()+i,m=c.top+d,n=c.left,o=l>=m+f,p=c.top-f>=this.body().scrollTop(),q=b.outerWidth(!1),r=j>=n+q,s=b.hasClass(\"select2-drop-above\");s?(u=!0,!p&&o&&(v=!0,u=!1)):(u=!1,!o&&p&&(v=!0,u=!0)),v&&(b.hide(),c=this.container.offset(),d=this.container.outerHeight(!1),e=this.container.outerWidth(!1),f=b.outerHeight(!1),j=g.scrollLeft()+h,l=g.scrollTop()+i,m=c.top+d,n=c.left,q=b.outerWidth(!1),r=j>=n+q,b.show()),this.opts.dropdownAutoWidth?(x=a(\".select2-results\",b)[0],b.addClass(\"select2-drop-auto-width\"),b.css(\"width\",\"\"),q=b.outerWidth(!1)+(x.scrollHeight===x.clientHeight?0:k.width),q>e?e=q:q=e,r=j>=n+q):this.container.removeClass(\"select2-drop-auto-width\"),\"static\"!==this.body().css(\"position\")&&(t=this.body().offset(),m-=t.top,n-=t.left),r||(n=c.left+e-q),w={left:n,width:e},u?(w.bottom=i-c.top,w.top=\"auto\",this.container.addClass(\"select2-drop-above\"),b.addClass(\"select2-drop-above\")):(w.top=m,w.bottom=\"auto\",this.container.removeClass(\"select2-drop-above\"),b.removeClass(\"select2-drop-above\")),w=a.extend(w,K(this.opts.dropdownCss)),b.css(w)},shouldOpen:function(){var b;return this.opened()?!1:this._enabled===!1||this._readonly===!0?!1:(b=a.Event(\"select2-opening\"),this.opts.element.trigger(b),!b.isDefaultPrevented())},clearDropdownAlignmentPreference:function(){this.container.removeClass(\"select2-drop-above\"),this.dropdown.removeClass(\"select2-drop-above\")},open:function(){return this.shouldOpen()?(this.opening(),!0):!1},opening:function(){var f,b=this.containerId,c=\"scroll.\"+b,d=\"resize.\"+b,e=\"orientationchange.\"+b;this.container.addClass(\"select2-dropdown-open\").addClass(\"select2-container-active\"),this.clearDropdownAlignmentPreference(),this.dropdown[0]!==this.body().children().last()[0]&&this.dropdown.detach().appendTo(this.body()),f=a(\"#select2-drop-mask\"),0==f.length&&(f=a(document.createElement(\"div\")),f.attr(\"id\",\"select2-drop-mask\").attr(\"class\",\"select2-drop-mask\"),f.hide(),f.appendTo(this.body()),f.on(\"mousedown touchstart click\",function(b){var d,c=a(\"#select2-drop\");c.length>0&&(d=c.data(\"select2\"),d.opts.selectOnBlur&&d.selectHighlighted({noFocus:!0}),d.close({focus:!0}),b.preventDefault(),b.stopPropagation())})),this.dropdown.prev()[0]!==f[0]&&this.dropdown.before(f),a(\"#select2-drop\").removeAttr(\"id\"),this.dropdown.attr(\"id\",\"select2-drop\"),f.show(),this.positionDropdown(),this.dropdown.show(),this.positionDropdown(),this.dropdown.addClass(\"select2-drop-active\");var g=this;this.container.parents().add(window).each(function(){a(this).on(d+\" \"+c+\" \"+e,function(){g.positionDropdown()})})},close:function(){if(this.opened()){var b=this.containerId,c=\"scroll.\"+b,d=\"resize.\"+b,e=\"orientationchange.\"+b;this.container.parents().add(window).each(function(){a(this).off(c).off(d).off(e)}),this.clearDropdownAlignmentPreference(),a(\"#select2-drop-mask\").hide(),this.dropdown.removeAttr(\"id\"),this.dropdown.hide(),this.container.removeClass(\"select2-dropdown-open\").removeClass(\"select2-container-active\"),this.results.empty(),this.clearSearch(),this.search.removeClass(\"select2-active\"),this.opts.element.trigger(a.Event(\"select2-close\"))}},externalSearch:function(a){this.open(),this.search.val(a),this.updateResults(!1)},clearSearch:function(){},getMaximumSelectionSize:function(){return K(this.opts.maximumSelectionSize)},ensureHighlightVisible:function(){var c,d,e,f,g,h,i,b=this.results;if(d=this.highlight(),!(0>d)){if(0==d)return b.scrollTop(0),void 0;c=this.findHighlightableChoices().find(\".select2-result-label\"),e=a(c[d]),f=e.offset().top+e.outerHeight(!0),d===c.length-1&&(i=b.find(\"li.select2-more-results\"),i.length>0&&(f=i.offset().top+i.outerHeight(!0))),g=b.offset().top+b.outerHeight(!0),f>g&&b.scrollTop(b.scrollTop()+(f-g)),h=e.offset().top-b.offset().top,0>h&&\"none\"!=e.css(\"display\")&&b.scrollTop(b.scrollTop()+h)}},findHighlightableChoices:function(){return this.results.find(\".select2-result-selectable:not(.select2-disabled, .select2-selected)\")},moveHighlight:function(b){for(var c=this.findHighlightableChoices(),d=this.highlight();d>-1&&d<c.length;){d+=b;var e=a(c[d]);if(e.hasClass(\"select2-result-selectable\")&&!e.hasClass(\"select2-disabled\")&&!e.hasClass(\"select2-selected\")){this.highlight(d);break}}},highlight:function(b){var d,e,c=this.findHighlightableChoices();return 0===arguments.length?o(c.filter(\".select2-highlighted\")[0],c.get()):(b>=c.length&&(b=c.length-1),0>b&&(b=0),this.removeHighlight(),d=a(c[b]),d.addClass(\"select2-highlighted\"),this.ensureHighlightVisible(),e=d.data(\"select2-data\"),e&&this.opts.element.trigger({type:\"select2-highlight\",val:this.id(e),choice:e}),void 0)},removeHighlight:function(){this.results.find(\".select2-highlighted\").removeClass(\"select2-highlighted\")},countSelectableResults:function(){return this.findHighlightableChoices().length},highlightUnderEvent:function(b){var c=a(b.target).closest(\".select2-result-selectable\");if(c.length>0&&!c.is(\".select2-highlighted\")){var d=this.findHighlightableChoices();this.highlight(d.index(c))}else 0==c.length&&this.removeHighlight()},loadMoreIfNeeded:function(){var c,a=this.results,b=a.find(\"li.select2-more-results\"),d=this.resultsPage+1,e=this,f=this.search.val(),g=this.context;0!==b.length&&(c=b.offset().top-a.offset().top-a.height(),c<=this.opts.loadMorePadding&&(b.addClass(\"select2-active\"),this.opts.query({element:this.opts.element,term:f,page:d,context:g,matcher:this.opts.matcher,callback:this.bind(function(c){e.opened()&&(e.opts.populateResults.call(this,a,c.results,{term:f,page:d,context:g}),e.postprocessResults(c,!1,!1),c.more===!0?(b.detach().appendTo(a).text(e.opts.formatLoadMore(d+1)),window.setTimeout(function(){e.loadMoreIfNeeded()},10)):b.remove(),e.positionDropdown(),e.resultsPage=d,e.context=c.context,this.opts.element.trigger({type:\"select2-loaded\",items:c}))})})))},tokenize:function(){},updateResults:function(c){function m(){d.removeClass(\"select2-active\"),h.positionDropdown()}function n(a){e.html(a),m()}var g,i,l,d=this.search,e=this.results,f=this.opts,h=this,j=d.val(),k=a.data(this.container,\"select2-last-term\");if((c===!0||!k||!q(j,k))&&(a.data(this.container,\"select2-last-term\",j),c===!0||this.showSearchInput!==!1&&this.opened())){l=++this.queryCount;var o=this.getMaximumSelectionSize();if(o>=1&&(g=this.data(),a.isArray(g)&&g.length>=o&&J(f.formatSelectionTooBig,\"formatSelectionTooBig\")))return n(\"<li class='select2-selection-limit'>\"+f.formatSelectionTooBig(o)+\"</li>\"),void 0;if(d.val().length<f.minimumInputLength)return J(f.formatInputTooShort,\"formatInputTooShort\")?n(\"<li class='select2-no-results'>\"+f.formatInputTooShort(d.val(),f.minimumInputLength)+\"</li>\"):n(\"\"),c&&this.showSearch&&this.showSearch(!0),void 0;\nif(f.maximumInputLength&&d.val().length>f.maximumInputLength)return J(f.formatInputTooLong,\"formatInputTooLong\")?n(\"<li class='select2-no-results'>\"+f.formatInputTooLong(d.val(),f.maximumInputLength)+\"</li>\"):n(\"\"),void 0;f.formatSearching&&0===this.findHighlightableChoices().length&&n(\"<li class='select2-searching'>\"+f.formatSearching()+\"</li>\"),d.addClass(\"select2-active\"),this.removeHighlight(),i=this.tokenize(),i!=b&&null!=i&&d.val(i),this.resultsPage=1,f.query({element:f.element,term:d.val(),page:this.resultsPage,context:null,matcher:f.matcher,callback:this.bind(function(g){var i;if(l==this.queryCount){if(!this.opened())return this.search.removeClass(\"select2-active\"),void 0;if(this.context=g.context===b?null:g.context,this.opts.createSearchChoice&&\"\"!==d.val()&&(i=this.opts.createSearchChoice.call(h,d.val(),g.results),i!==b&&null!==i&&h.id(i)!==b&&null!==h.id(i)&&0===a(g.results).filter(function(){return q(h.id(this),h.id(i))}).length&&g.results.unshift(i)),0===g.results.length&&J(f.formatNoMatches,\"formatNoMatches\"))return n(\"<li class='select2-no-results'>\"+f.formatNoMatches(d.val())+\"</li>\"),void 0;e.empty(),h.opts.populateResults.call(this,e,g.results,{term:d.val(),page:this.resultsPage,context:null}),g.more===!0&&J(f.formatLoadMore,\"formatLoadMore\")&&(e.append(\"<li class='select2-more-results'>\"+h.opts.escapeMarkup(f.formatLoadMore(this.resultsPage))+\"</li>\"),window.setTimeout(function(){h.loadMoreIfNeeded()},10)),this.postprocessResults(g,c),m(),this.opts.element.trigger({type:\"select2-loaded\",items:g})}})})}},cancel:function(){this.close()},blur:function(){this.opts.selectOnBlur&&this.selectHighlighted({noFocus:!0}),this.close(),this.container.removeClass(\"select2-container-active\"),this.search[0]===document.activeElement&&this.search.blur(),this.clearSearch(),this.selection.find(\".select2-search-choice-focus\").removeClass(\"select2-search-choice-focus\")},focusSearch:function(){y(this.search)},selectHighlighted:function(a){var b=this.highlight(),c=this.results.find(\".select2-highlighted\"),d=c.closest(\".select2-result\").data(\"select2-data\");d?(this.highlight(b),this.onSelect(d,a)):a&&a.noFocus&&this.close()},getPlaceholder:function(){var a;return this.opts.element.attr(\"placeholder\")||this.opts.element.attr(\"data-placeholder\")||this.opts.element.data(\"placeholder\")||this.opts.placeholder||((a=this.getPlaceholderOption())!==b?a.text():b)},getPlaceholderOption:function(){if(this.select){var a=this.select.children(\"option\").first();if(this.opts.placeholderOption!==b)return\"first\"===this.opts.placeholderOption&&a||\"function\"==typeof this.opts.placeholderOption&&this.opts.placeholderOption(this.select);if(\"\"===a.text()&&\"\"===a.val())return a}},initContainerWidth:function(){function c(){var c,d,e,f,g,h;if(\"off\"===this.opts.width)return null;if(\"element\"===this.opts.width)return 0===this.opts.element.outerWidth(!1)?\"auto\":this.opts.element.outerWidth(!1)+\"px\";if(\"copy\"===this.opts.width||\"resolve\"===this.opts.width){if(c=this.opts.element.attr(\"style\"),c!==b)for(d=c.split(\";\"),f=0,g=d.length;g>f;f+=1)if(h=d[f].replace(/\\s/g,\"\"),e=h.match(/^width:(([-+]?([0-9]*\\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i),null!==e&&e.length>=1)return e[1];return\"resolve\"===this.opts.width?(c=this.opts.element.css(\"width\"),c.indexOf(\"%\")>0?c:0===this.opts.element.outerWidth(!1)?\"auto\":this.opts.element.outerWidth(!1)+\"px\"):null}return a.isFunction(this.opts.width)?this.opts.width():this.opts.width}var d=c.call(this);null!==d&&this.container.css(\"width\",d)}}),e=N(d,{createContainer:function(){var b=a(document.createElement(\"div\")).attr({\"class\":\"select2-container\"}).html([\"<a href='javascript:void(0)' onclick='return false;' class='select2-choice' tabindex='-1'>\",\"   <span class='select2-chosen'>&nbsp;</span><abbr class='select2-search-choice-close'></abbr>\",\"   <span class='select2-arrow'><b></b></span>\",\"</a>\",\"<input class='select2-focusser select2-offscreen' type='text'/>\",\"<div class='select2-drop select2-display-none'>\",\"   <div class='select2-search'>\",\"       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'/>\",\"   </div>\",\"   <ul class='select2-results'>\",\"   </ul>\",\"</div>\"].join(\"\"));return b},enableInterface:function(){this.parent.enableInterface.apply(this,arguments)&&this.focusser.prop(\"disabled\",!this.isInterfaceEnabled())},opening:function(){var c,d,e;this.opts.minimumResultsForSearch>=0&&this.showSearch(!0),this.parent.opening.apply(this,arguments),this.showSearchInput!==!1&&this.search.val(this.focusser.val()),this.search.focus(),c=this.search.get(0),c.createTextRange?(d=c.createTextRange(),d.collapse(!1),d.select()):c.setSelectionRange&&(e=this.search.val().length,c.setSelectionRange(e,e)),\"\"===this.search.val()&&this.nextSearchTerm!=b&&(this.search.val(this.nextSearchTerm),this.search.select()),this.focusser.prop(\"disabled\",!0).val(\"\"),this.updateResults(!0),this.opts.element.trigger(a.Event(\"select2-open\"))},close:function(a){this.opened()&&(this.parent.close.apply(this,arguments),a=a||{focus:!0},this.focusser.removeAttr(\"disabled\"),a.focus&&this.focusser.focus())},focus:function(){this.opened()?this.close():(this.focusser.removeAttr(\"disabled\"),this.focusser.focus())},isFocused:function(){return this.container.hasClass(\"select2-container-active\")},cancel:function(){this.parent.cancel.apply(this,arguments),this.focusser.removeAttr(\"disabled\"),this.focusser.focus()},destroy:function(){a(\"label[for='\"+this.focusser.attr(\"id\")+\"']\").attr(\"for\",this.opts.element.attr(\"id\")),this.parent.destroy.apply(this,arguments)},initContainer:function(){var b,d=this.container,e=this.dropdown;this.opts.minimumResultsForSearch<0?this.showSearch(!1):this.showSearch(!0),this.selection=b=d.find(\".select2-choice\"),this.focusser=d.find(\".select2-focusser\"),this.focusser.attr(\"id\",\"s2id_autogen\"+g()),a(\"label[for='\"+this.opts.element.attr(\"id\")+\"']\").attr(\"for\",this.focusser.attr(\"id\")),this.focusser.attr(\"tabindex\",this.elementTabIndex),this.search.on(\"keydown\",this.bind(function(a){if(this.isInterfaceEnabled()){if(a.which===c.PAGE_UP||a.which===c.PAGE_DOWN)return A(a),void 0;switch(a.which){case c.UP:case c.DOWN:return this.moveHighlight(a.which===c.UP?-1:1),A(a),void 0;case c.ENTER:return this.selectHighlighted(),A(a),void 0;case c.TAB:return this.selectHighlighted({noFocus:!0}),void 0;case c.ESC:return this.cancel(a),A(a),void 0}}})),this.search.on(\"blur\",this.bind(function(){document.activeElement===this.body().get(0)&&window.setTimeout(this.bind(function(){this.search.focus()}),0)})),this.focusser.on(\"keydown\",this.bind(function(a){if(this.isInterfaceEnabled()&&a.which!==c.TAB&&!c.isControl(a)&&!c.isFunctionKey(a)&&a.which!==c.ESC){if(this.opts.openOnEnter===!1&&a.which===c.ENTER)return A(a),void 0;if(a.which==c.DOWN||a.which==c.UP||a.which==c.ENTER&&this.opts.openOnEnter){if(a.altKey||a.ctrlKey||a.shiftKey||a.metaKey)return;return this.open(),A(a),void 0}return a.which==c.DELETE||a.which==c.BACKSPACE?(this.opts.allowClear&&this.clear(),A(a),void 0):void 0}})),t(this.focusser),this.focusser.on(\"keyup-change input\",this.bind(function(a){if(this.opts.minimumResultsForSearch>=0){if(a.stopPropagation(),this.opened())return;this.open()}})),b.on(\"mousedown\",\"abbr\",this.bind(function(a){this.isInterfaceEnabled()&&(this.clear(),B(a),this.close(),this.selection.focus())})),b.on(\"mousedown\",this.bind(function(b){this.container.hasClass(\"select2-container-active\")||this.opts.element.trigger(a.Event(\"select2-focus\")),this.opened()?this.close():this.isInterfaceEnabled()&&this.open(),A(b)})),e.on(\"mousedown\",this.bind(function(){this.search.focus()})),b.on(\"focus\",this.bind(function(a){A(a)})),this.focusser.on(\"focus\",this.bind(function(){this.container.hasClass(\"select2-container-active\")||this.opts.element.trigger(a.Event(\"select2-focus\")),this.container.addClass(\"select2-container-active\")})).on(\"blur\",this.bind(function(){this.opened()||(this.container.removeClass(\"select2-container-active\"),this.opts.element.trigger(a.Event(\"select2-blur\")))})),this.search.on(\"focus\",this.bind(function(){this.container.hasClass(\"select2-container-active\")||this.opts.element.trigger(a.Event(\"select2-focus\")),this.container.addClass(\"select2-container-active\")})),this.initContainerWidth(),this.opts.element.addClass(\"select2-offscreen\"),this.setPlaceholder()},clear:function(b){var c=this.selection.data(\"select2-data\");if(c){var d=a.Event(\"select2-clearing\");if(this.opts.element.trigger(d),d.isDefaultPrevented())return;var e=this.getPlaceholderOption();this.opts.element.val(e?e.val():\"\"),this.selection.find(\".select2-chosen\").empty(),this.selection.removeData(\"select2-data\"),this.setPlaceholder(),b!==!1&&(this.opts.element.trigger({type:\"select2-removed\",val:this.id(c),choice:c}),this.triggerChange({removed:c}))}},initSelection:function(){if(this.isPlaceholderOptionSelected())this.updateSelection(null),this.close(),this.setPlaceholder();else{var c=this;this.opts.initSelection.call(null,this.opts.element,function(a){a!==b&&null!==a&&(c.updateSelection(a),c.close(),c.setPlaceholder())})}},isPlaceholderOptionSelected:function(){var a;return this.getPlaceholder()?(a=this.getPlaceholderOption())!==b&&a.prop(\"selected\")||\"\"===this.opts.element.val()||this.opts.element.val()===b||null===this.opts.element.val():!1},prepareOpts:function(){var b=this.parent.prepareOpts.apply(this,arguments),c=this;return\"select\"===b.element.get(0).tagName.toLowerCase()?b.initSelection=function(a,b){var d=a.find(\"option\").filter(function(){return this.selected});b(c.optionToData(d))}:\"data\"in b&&(b.initSelection=b.initSelection||function(c,d){var e=c.val(),f=null;b.query({matcher:function(a,c,d){var g=q(e,b.id(d));return g&&(f=d),g},callback:a.isFunction(d)?function(){d(f)}:a.noop})}),b},getPlaceholder:function(){return this.select&&this.getPlaceholderOption()===b?b:this.parent.getPlaceholder.apply(this,arguments)},setPlaceholder:function(){var a=this.getPlaceholder();if(this.isPlaceholderOptionSelected()&&a!==b){if(this.select&&this.getPlaceholderOption()===b)return;this.selection.find(\".select2-chosen\").html(this.opts.escapeMarkup(a)),this.selection.addClass(\"select2-default\"),this.container.removeClass(\"select2-allowclear\")}},postprocessResults:function(a,b,c){var d=0,e=this;if(this.findHighlightableChoices().each2(function(a,b){return q(e.id(b.data(\"select2-data\")),e.opts.element.val())?(d=a,!1):void 0}),c!==!1&&(b===!0&&d>=0?this.highlight(d):this.highlight(0)),b===!0){var g=this.opts.minimumResultsForSearch;g>=0&&this.showSearch(L(a.results)>=g)}},showSearch:function(b){this.showSearchInput!==b&&(this.showSearchInput=b,this.dropdown.find(\".select2-search\").toggleClass(\"select2-search-hidden\",!b),this.dropdown.find(\".select2-search\").toggleClass(\"select2-offscreen\",!b),a(this.dropdown,this.container).toggleClass(\"select2-with-searchbox\",b))},onSelect:function(a,b){if(this.triggerSelect(a)){var c=this.opts.element.val(),d=this.data();this.opts.element.val(this.id(a)),this.updateSelection(a),this.opts.element.trigger({type:\"select2-selected\",val:this.id(a),choice:a}),this.nextSearchTerm=this.opts.nextSearchTerm(a,this.search.val()),this.close(),b&&b.noFocus||this.focusser.focus(),q(c,this.id(a))||this.triggerChange({added:a,removed:d})}},updateSelection:function(a){var d,e,c=this.selection.find(\".select2-chosen\");this.selection.data(\"select2-data\",a),c.empty(),null!==a&&(d=this.opts.formatSelection(a,c,this.opts.escapeMarkup)),d!==b&&c.append(d),e=this.opts.formatSelectionCssClass(a,c),e!==b&&c.addClass(e),this.selection.removeClass(\"select2-default\"),this.opts.allowClear&&this.getPlaceholder()!==b&&this.container.addClass(\"select2-allowclear\")},val:function(){var a,c=!1,d=null,e=this,f=this.data();if(0===arguments.length)return this.opts.element.val();if(a=arguments[0],arguments.length>1&&(c=arguments[1]),this.select)this.select.val(a).find(\"option\").filter(function(){return this.selected}).each2(function(a,b){return d=e.optionToData(b),!1}),this.updateSelection(d),this.setPlaceholder(),c&&this.triggerChange({added:d,removed:f});else{if(!a&&0!==a)return this.clear(c),void 0;if(this.opts.initSelection===b)throw new Error(\"cannot call val() if initSelection() is not defined\");this.opts.element.val(a),this.opts.initSelection(this.opts.element,function(a){e.opts.element.val(a?e.id(a):\"\"),e.updateSelection(a),e.setPlaceholder(),c&&e.triggerChange({added:a,removed:f})})}},clearSearch:function(){this.search.val(\"\"),this.focusser.val(\"\")},data:function(a){var c,d=!1;return 0===arguments.length?(c=this.selection.data(\"select2-data\"),c==b&&(c=null),c):(arguments.length>1&&(d=arguments[1]),a?(c=this.data(),this.opts.element.val(a?this.id(a):\"\"),this.updateSelection(a),d&&this.triggerChange({added:a,removed:c})):this.clear(d),void 0)}}),f=N(d,{createContainer:function(){var b=a(document.createElement(\"div\")).attr({\"class\":\"select2-container select2-container-multi\"}).html([\"<ul class='select2-choices'>\",\"  <li class='select2-search-field'>\",\"    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>\",\"  </li>\",\"</ul>\",\"<div class='select2-drop select2-drop-multi select2-display-none'>\",\"   <ul class='select2-results'>\",\"   </ul>\",\"</div>\"].join(\"\"));return b},prepareOpts:function(){var b=this.parent.prepareOpts.apply(this,arguments),c=this;return\"select\"===b.element.get(0).tagName.toLowerCase()?b.initSelection=function(a,b){var d=[];a.find(\"option\").filter(function(){return this.selected}).each2(function(a,b){d.push(c.optionToData(b))}),b(d)}:\"data\"in b&&(b.initSelection=b.initSelection||function(c,d){var e=r(c.val(),b.separator),f=[];b.query({matcher:function(c,d,g){var h=a.grep(e,function(a){return q(a,b.id(g))}).length;return h&&f.push(g),h},callback:a.isFunction(d)?function(){for(var a=[],c=0;c<e.length;c++)for(var g=e[c],h=0;h<f.length;h++){var i=f[h];if(q(g,b.id(i))){a.push(i),f.splice(h,1);break}}d(a)}:a.noop})}),b},selectChoice:function(a){var b=this.container.find(\".select2-search-choice-focus\");b.length&&a&&a[0]==b[0]||(b.length&&this.opts.element.trigger(\"choice-deselected\",b),b.removeClass(\"select2-search-choice-focus\"),a&&a.length&&(this.close(),a.addClass(\"select2-search-choice-focus\"),this.opts.element.trigger(\"choice-selected\",a)))},destroy:function(){a(\"label[for='\"+this.search.attr(\"id\")+\"']\").attr(\"for\",this.opts.element.attr(\"id\")),this.parent.destroy.apply(this,arguments)},initContainer:function(){var d,b=\".select2-choices\";this.searchContainer=this.container.find(\".select2-search-field\"),this.selection=d=this.container.find(b);var e=this;this.selection.on(\"click\",\".select2-search-choice:not(.select2-locked)\",function(){e.search[0].focus(),e.selectChoice(a(this))}),this.search.attr(\"id\",\"s2id_autogen\"+g()),a(\"label[for='\"+this.opts.element.attr(\"id\")+\"']\").attr(\"for\",this.search.attr(\"id\")),this.search.on(\"input paste\",this.bind(function(){this.isInterfaceEnabled()&&(this.opened()||this.open())})),this.search.attr(\"tabindex\",this.elementTabIndex),this.keydowns=0,this.search.on(\"keydown\",this.bind(function(a){if(this.isInterfaceEnabled()){++this.keydowns;var b=d.find(\".select2-search-choice-focus\"),e=b.prev(\".select2-search-choice:not(.select2-locked)\"),f=b.next(\".select2-search-choice:not(.select2-locked)\"),g=z(this.search);if(b.length&&(a.which==c.LEFT||a.which==c.RIGHT||a.which==c.BACKSPACE||a.which==c.DELETE||a.which==c.ENTER)){var h=b;return a.which==c.LEFT&&e.length?h=e:a.which==c.RIGHT?h=f.length?f:null:a.which===c.BACKSPACE?(this.unselect(b.first()),this.search.width(10),h=e.length?e:f):a.which==c.DELETE?(this.unselect(b.first()),this.search.width(10),h=f.length?f:null):a.which==c.ENTER&&(h=null),this.selectChoice(h),A(a),h&&h.length||this.open(),void 0}if((a.which===c.BACKSPACE&&1==this.keydowns||a.which==c.LEFT)&&0==g.offset&&!g.length)return this.selectChoice(d.find(\".select2-search-choice:not(.select2-locked)\").last()),A(a),void 0;if(this.selectChoice(null),this.opened())switch(a.which){case c.UP:case c.DOWN:return this.moveHighlight(a.which===c.UP?-1:1),A(a),void 0;case c.ENTER:return this.selectHighlighted(),A(a),void 0;case c.TAB:return this.selectHighlighted({noFocus:!0}),this.close(),void 0;case c.ESC:return this.cancel(a),A(a),void 0}if(a.which!==c.TAB&&!c.isControl(a)&&!c.isFunctionKey(a)&&a.which!==c.BACKSPACE&&a.which!==c.ESC){if(a.which===c.ENTER){if(this.opts.openOnEnter===!1)return;if(a.altKey||a.ctrlKey||a.shiftKey||a.metaKey)return}this.open(),(a.which===c.PAGE_UP||a.which===c.PAGE_DOWN)&&A(a),a.which===c.ENTER&&A(a)}}})),this.search.on(\"keyup\",this.bind(function(){this.keydowns=0,this.resizeSearch()})),this.search.on(\"blur\",this.bind(function(b){this.container.removeClass(\"select2-container-active\"),this.search.removeClass(\"select2-focused\"),this.selectChoice(null),this.opened()||this.clearSearch(),b.stopImmediatePropagation(),this.opts.element.trigger(a.Event(\"select2-blur\"))})),this.container.on(\"click\",b,this.bind(function(b){this.isInterfaceEnabled()&&(a(b.target).closest(\".select2-search-choice\").length>0||(this.selectChoice(null),this.clearPlaceholder(),this.container.hasClass(\"select2-container-active\")||this.opts.element.trigger(a.Event(\"select2-focus\")),this.open(),this.focusSearch(),b.preventDefault()))})),this.container.on(\"focus\",b,this.bind(function(){this.isInterfaceEnabled()&&(this.container.hasClass(\"select2-container-active\")||this.opts.element.trigger(a.Event(\"select2-focus\")),this.container.addClass(\"select2-container-active\"),this.dropdown.addClass(\"select2-drop-active\"),this.clearPlaceholder())})),this.initContainerWidth(),this.opts.element.addClass(\"select2-offscreen\"),this.clearSearch()},enableInterface:function(){this.parent.enableInterface.apply(this,arguments)&&this.search.prop(\"disabled\",!this.isInterfaceEnabled())},initSelection:function(){if(\"\"===this.opts.element.val()&&\"\"===this.opts.element.text()&&(this.updateSelection([]),this.close(),this.clearSearch()),this.select||\"\"!==this.opts.element.val()){var c=this;this.opts.initSelection.call(null,this.opts.element,function(a){a!==b&&null!==a&&(c.updateSelection(a),c.close(),c.clearSearch())})}},clearSearch:function(){var a=this.getPlaceholder(),c=this.getMaxSearchWidth();a!==b&&0===this.getVal().length&&this.search.hasClass(\"select2-focused\")===!1?(this.search.val(a).addClass(\"select2-default\"),this.search.width(c>0?c:this.container.css(\"width\"))):this.search.val(\"\").width(10)},clearPlaceholder:function(){this.search.hasClass(\"select2-default\")&&this.search.val(\"\").removeClass(\"select2-default\")},opening:function(){this.clearPlaceholder(),this.resizeSearch(),this.parent.opening.apply(this,arguments),this.focusSearch(),this.updateResults(!0),this.search.focus(),this.opts.element.trigger(a.Event(\"select2-open\"))},close:function(){this.opened()&&this.parent.close.apply(this,arguments)},focus:function(){this.close(),this.search.focus()},isFocused:function(){return this.search.hasClass(\"select2-focused\")},updateSelection:function(b){var c=[],d=[],e=this;a(b).each(function(){o(e.id(this),c)<0&&(c.push(e.id(this)),d.push(this))}),b=d,this.selection.find(\".select2-search-choice\").remove(),a(b).each(function(){e.addSelectedChoice(this)}),e.postprocessResults()},tokenize:function(){var a=this.search.val();a=this.opts.tokenizer.call(this,a,this.data(),this.bind(this.onSelect),this.opts),null!=a&&a!=b&&(this.search.val(a),a.length>0&&this.open())},onSelect:function(a,b){this.triggerSelect(a)&&(this.addSelectedChoice(a),this.opts.element.trigger({type:\"selected\",val:this.id(a),choice:a}),(this.select||!this.opts.closeOnSelect)&&this.postprocessResults(a,!1,this.opts.closeOnSelect===!0),this.opts.closeOnSelect?(this.close(),this.search.width(10)):this.countSelectableResults()>0?(this.search.width(10),this.resizeSearch(),this.getMaximumSelectionSize()>0&&this.val().length>=this.getMaximumSelectionSize()&&this.updateResults(!0),this.positionDropdown()):(this.close(),this.search.width(10)),this.triggerChange({added:a}),b&&b.noFocus||this.focusSearch())},cancel:function(){this.close(),this.focusSearch()},addSelectedChoice:function(c){var j,k,d=!c.locked,e=a(\"<li class='select2-search-choice'>    <div></div>    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a></li>\"),f=a(\"<li class='select2-search-choice select2-locked'><div></div></li>\"),g=d?e:f,h=this.id(c),i=this.getVal();j=this.opts.formatSelection(c,g.find(\"div\"),this.opts.escapeMarkup),j!=b&&g.find(\"div\").replaceWith(\"<div>\"+j+\"</div>\"),k=this.opts.formatSelectionCssClass(c,g.find(\"div\")),k!=b&&g.addClass(k),d&&g.find(\".select2-search-choice-close\").on(\"mousedown\",A).on(\"click dblclick\",this.bind(function(b){this.isInterfaceEnabled()&&(a(b.target).closest(\".select2-search-choice\").fadeOut(\"fast\",this.bind(function(){this.unselect(a(b.target)),this.selection.find(\".select2-search-choice-focus\").removeClass(\"select2-search-choice-focus\"),this.close(),this.focusSearch()})).dequeue(),A(b))})).on(\"focus\",this.bind(function(){this.isInterfaceEnabled()&&(this.container.addClass(\"select2-container-active\"),this.dropdown.addClass(\"select2-drop-active\"))})),g.data(\"select2-data\",c),g.insertBefore(this.searchContainer),i.push(h),this.setVal(i)},unselect:function(b){var d,e,c=this.getVal();if(b=b.closest(\".select2-search-choice\"),0===b.length)throw\"Invalid argument: \"+b+\". Must be .select2-search-choice\";if(d=b.data(\"select2-data\")){for(;(e=o(this.id(d),c))>=0;)c.splice(e,1),this.setVal(c),this.select&&this.postprocessResults();var f=a.Event(\"select2-removing\");f.val=this.id(d),f.choice=d,this.opts.element.trigger(f),f.isDefaultPrevented()||(b.remove(),this.opts.element.trigger({type:\"select2-removed\",val:this.id(d),choice:d}),this.triggerChange({removed:d}))}},postprocessResults:function(a,b,c){var d=this.getVal(),e=this.results.find(\".select2-result\"),f=this.results.find(\".select2-result-with-children\"),g=this;e.each2(function(a,b){var c=g.id(b.data(\"select2-data\"));o(c,d)>=0&&(b.addClass(\"select2-selected\"),b.find(\".select2-result-selectable\").addClass(\"select2-selected\"))}),f.each2(function(a,b){b.is(\".select2-result-selectable\")||0!==b.find(\".select2-result-selectable:not(.select2-selected)\").length||b.addClass(\"select2-selected\")}),-1==this.highlight()&&c!==!1&&g.highlight(0),!this.opts.createSearchChoice&&!e.filter(\".select2-result:not(.select2-selected)\").length>0&&(!a||a&&!a.more&&0===this.results.find(\".select2-no-results\").length)&&J(g.opts.formatNoMatches,\"formatNoMatches\")&&this.results.append(\"<li class='select2-no-results'>\"+g.opts.formatNoMatches(g.search.val())+\"</li>\")},getMaxSearchWidth:function(){return this.selection.width()-s(this.search)},resizeSearch:function(){var a,b,c,d,e,f=s(this.search);a=C(this.search)+10,b=this.search.offset().left,c=this.selection.width(),d=this.selection.offset().left,e=c-(b-d)-f,a>e&&(e=c-f),40>e&&(e=c-f),0>=e&&(e=a),this.search.width(Math.floor(e))},getVal:function(){var a;return this.select?(a=this.select.val(),null===a?[]:a):(a=this.opts.element.val(),r(a,this.opts.separator))},setVal:function(b){var c;this.select?this.select.val(b):(c=[],a(b).each(function(){o(this,c)<0&&c.push(this)}),this.opts.element.val(0===c.length?\"\":c.join(this.opts.separator)))},buildChangeDetails:function(a,b){for(var b=b.slice(0),a=a.slice(0),c=0;c<b.length;c++)for(var d=0;d<a.length;d++)q(this.opts.id(b[c]),this.opts.id(a[d]))&&(b.splice(c,1),c>0&&c--,a.splice(d,1),d--);return{added:b,removed:a}},val:function(c,d){var e,f=this;if(0===arguments.length)return this.getVal();if(e=this.data(),e.length||(e=[]),!c&&0!==c)return this.opts.element.val(\"\"),this.updateSelection([]),this.clearSearch(),d&&this.triggerChange({added:this.data(),removed:e}),void 0;if(this.setVal(c),this.select)this.opts.initSelection(this.select,this.bind(this.updateSelection)),d&&this.triggerChange(this.buildChangeDetails(e,this.data()));else{if(this.opts.initSelection===b)throw new Error(\"val() cannot be called if initSelection() is not defined\");this.opts.initSelection(this.opts.element,function(b){var c=a.map(b,f.id);f.setVal(c),f.updateSelection(b),f.clearSearch(),d&&f.triggerChange(f.buildChangeDetails(e,f.data()))})}this.clearSearch()},onSortStart:function(){if(this.select)throw new Error(\"Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.\");this.search.width(0),this.searchContainer.hide()},onSortEnd:function(){var b=[],c=this;this.searchContainer.show(),this.searchContainer.appendTo(this.searchContainer.parent()),this.resizeSearch(),this.selection.find(\".select2-search-choice\").each(function(){b.push(c.opts.id(a(this).data(\"select2-data\")))}),this.setVal(b),this.triggerChange()},data:function(b,c){var e,f,d=this;return 0===arguments.length?this.selection.find(\".select2-search-choice\").map(function(){return a(this).data(\"select2-data\")}).get():(f=this.data(),b||(b=[]),e=a.map(b,function(a){return d.opts.id(a)}),this.setVal(e),this.updateSelection(b),this.clearSearch(),c&&this.triggerChange(this.buildChangeDetails(f,this.data())),void 0)}}),a.fn.select2=function(){var d,g,h,i,j,c=Array.prototype.slice.call(arguments,0),k=[\"val\",\"destroy\",\"opened\",\"open\",\"close\",\"focus\",\"isFocused\",\"container\",\"dropdown\",\"onSortStart\",\"onSortEnd\",\"enable\",\"disable\",\"readonly\",\"positionDropdown\",\"data\",\"search\"],l=[\"opened\",\"isFocused\",\"container\",\"dropdown\"],m=[\"val\",\"data\"],n={search:\"externalSearch\"};return this.each(function(){if(0===c.length||\"object\"==typeof c[0])d=0===c.length?{}:a.extend({},c[0]),d.element=a(this),\"select\"===d.element.get(0).tagName.toLowerCase()?j=d.element.prop(\"multiple\"):(j=d.multiple||!1,\"tags\"in d&&(d.multiple=j=!0)),g=j?new f:new e,g.init(d);else{if(\"string\"!=typeof c[0])throw\"Invalid arguments to select2 plugin: \"+c;if(o(c[0],k)<0)throw\"Unknown method: \"+c[0];if(i=b,g=a(this).data(\"select2\"),g===b)return;if(h=c[0],\"container\"===h?i=g.container:\"dropdown\"===h?i=g.dropdown:(n[h]&&(h=n[h]),i=g[h].apply(g,c.slice(1))),o(c[0],l)>=0||o(c[0],m)&&1==c.length)return!1}}),i===b?this:i},a.fn.select2.defaults={width:\"copy\",loadMorePadding:0,closeOnSelect:!0,openOnEnter:!0,containerCss:{},dropdownCss:{},containerCssClass:\"\",dropdownCssClass:\"\",formatResult:function(a,b,c,d){var e=[];return E(a.text,c.term,e,d),e.join(\"\")},formatSelection:function(a,c,d){return a?d(a.text):b},sortResults:function(a){return a},formatResultCssClass:function(){return b},formatSelectionCssClass:function(){return b},formatNoMatches:function(){return\"No matches found\"},formatInputTooShort:function(a,b){var c=b-a.length;return\"Please enter \"+c+\" more character\"+(1==c?\"\":\"s\")},formatInputTooLong:function(a,b){var c=a.length-b;return\"Please delete \"+c+\" character\"+(1==c?\"\":\"s\")},formatSelectionTooBig:function(a){return\"You can only select \"+a+\" item\"+(1==a?\"\":\"s\")},formatLoadMore:function(){return\"Loading more results...\"},formatSearching:function(){return\"Searching...\"},minimumResultsForSearch:0,minimumInputLength:0,maximumInputLength:null,maximumSelectionSize:0,id:function(a){return a.id},matcher:function(a,b){return n(\"\"+b).toUpperCase().indexOf(n(\"\"+a).toUpperCase())>=0},separator:\",\",tokenSeparators:[],tokenizer:M,escapeMarkup:F,blurOnChange:!1,selectOnBlur:!1,adaptContainerCssClass:function(a){return a},adaptDropdownCssClass:function(){return null},nextSearchTerm:function(){return b}},a.fn.select2.ajaxDefaults={transport:a.ajax,params:{type:\"GET\",cache:!1,dataType:\"json\"}},window.Select2={query:{ajax:G,local:H,tags:I},util:{debounce:v,markMatch:E,escapeMarkup:F,stripDiacritics:n},\"class\":{\"abstract\":d,single:e,multi:f}}}}(jQuery);","(function() {\n  var WebSocket = window.WebSocket || window.MozWebSocket;\n  var br = window.brunch || {};\n  var ar = br['auto-reload'] || {};\n  if (!WebSocket || !ar.enabled) return;\n\n  var cacheBuster = function(url){\n    var date = Math.round(Date.now() / 1000).toString();\n    url = url.replace(/(\\&|\\\\?)cacheBuster=\\d*/, '');\n    return url + (url.indexOf('?') >= 0 ? '&' : '?') +'cacheBuster=' + date;\n  };\n\n  var reloaders = {\n    page: function(){\n      window.location.reload(true);\n    },\n\n    stylesheet: function(){\n      [].slice\n        .call(document.querySelectorAll('link[rel=\"stylesheet\"]'))\n        .filter(function(link){\n          return (link != null && link.href != null);\n        })\n        .forEach(function(link) {\n          link.href = cacheBuster(link.href);\n        });\n    }\n  };\n  var port = ar.port || 9485;\n  var host = (!br['server']) ? window.location.hostname : br['server'];\n  var connection = new WebSocket('ws://' + host + ':' + port);\n  connection.onmessage = function(event) {\n    var message = event.data;\n    var b = window.brunch;\n    if (!b || !b['auto-reload'] || !b['auto-reload'].enabled) return;\n    if (reloaders[message] != null) {\n      reloaders[message]();\n    } else {\n      reloaders.page();\n    }\n  };\n})();\n","// lib/handlebars/base.js\n\n/*jshint eqnull:true*/\nthis.Handlebars = {};\n\n(function(Handlebars) {\n\nHandlebars.VERSION = \"1.0.rc.1\";\n\nHandlebars.helpers  = {};\nHandlebars.partials = {};\n\nHandlebars.registerHelper = function(name, fn, inverse) {\n  if(inverse) { fn.not = inverse; }\n  this.helpers[name] = fn;\n};\n\nHandlebars.registerPartial = function(name, str) {\n  this.partials[name] = str;\n};\n\nHandlebars.registerHelper('helperMissing', function(arg) {\n  if(arguments.length === 2) {\n    return undefined;\n  } else {\n    throw new Error(\"Could not find property '\" + arg + \"'\");\n  }\n});\n\nvar toString = Object.prototype.toString, functionType = \"[object Function]\";\n\nHandlebars.registerHelper('blockHelperMissing', function(context, options) {\n  var inverse = options.inverse || function() {}, fn = options.fn;\n\n\n  var ret = \"\";\n  var type = toString.call(context);\n\n  if(type === functionType) { context = context.call(this); }\n\n  if(context === true) {\n    return fn(this);\n  } else if(context === false || context == null) {\n    return inverse(this);\n  } else if(type === \"[object Array]\") {\n    if(context.length > 0) {\n      return Handlebars.helpers.each(context, options);\n    } else {\n      return inverse(this);\n    }\n  } else {\n    return fn(context);\n  }\n});\n\nHandlebars.K = function() {};\n\nHandlebars.createFrame = Object.create || function(object) {\n  Handlebars.K.prototype = object;\n  var obj = new Handlebars.K();\n  Handlebars.K.prototype = null;\n  return obj;\n};\n\nHandlebars.registerHelper('each', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  var ret = \"\", data;\n\n  if (options.data) {\n    data = Handlebars.createFrame(options.data);\n  }\n\n  if(context && context.length > 0) {\n    for(var i=0, j=context.length; i<j; i++) {\n      if (data) { data.index = i; }\n      ret = ret + fn(context[i], { data: data });\n    }\n  } else {\n    ret = inverse(this);\n  }\n  return ret;\n});\n\nHandlebars.registerHelper('if', function(context, options) {\n  var type = toString.call(context);\n  if(type === functionType) { context = context.call(this); }\n\n  if(!context || Handlebars.Utils.isEmpty(context)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(this);\n  }\n});\n\nHandlebars.registerHelper('unless', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  options.fn = inverse;\n  options.inverse = fn;\n\n  return Handlebars.helpers['if'].call(this, context, options);\n});\n\nHandlebars.registerHelper('with', function(context, options) {\n  return options.fn(context);\n});\n\nHandlebars.registerHelper('log', function(context) {\n  Handlebars.log(context);\n});\n\n}(this.Handlebars));\n;\n// lib/handlebars/utils.js\nHandlebars.Exception = function(message) {\n  var tmp = Error.prototype.constructor.apply(this, arguments);\n\n  for (var p in tmp) {\n    if (tmp.hasOwnProperty(p)) { this[p] = tmp[p]; }\n  }\n\n  this.message = tmp.message;\n};\nHandlebars.Exception.prototype = new Error();\n\n// Build out our basic SafeString type\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n\n(function() {\n  var escape = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\"\n  };\n\n  var badChars = /[&<>\"'`]/g;\n  var possible = /[&<>\"'`]/;\n\n  var escapeChar = function(chr) {\n    return escape[chr] || \"&amp;\";\n  };\n\n  Handlebars.Utils = {\n    escapeExpression: function(string) {\n      // don't escape SafeStrings, since they're already safe\n      if (string instanceof Handlebars.SafeString) {\n        return string.toString();\n      } else if (string == null || string === false) {\n        return \"\";\n      }\n\n      if(!possible.test(string)) { return string; }\n      return string.replace(badChars, escapeChar);\n    },\n\n    isEmpty: function(value) {\n      if (typeof value === \"undefined\") {\n        return true;\n      } else if (value === null) {\n        return true;\n      } else if (value === false) {\n        return true;\n      } else if(Object.prototype.toString.call(value) === \"[object Array]\" && value.length === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  };\n})();;\n// lib/handlebars/runtime.js\nHandlebars.VM = {\n  template: function(templateSpec) {\n    // Just add water\n    var container = {\n      escapeExpression: Handlebars.Utils.escapeExpression,\n      invokePartial: Handlebars.VM.invokePartial,\n      programs: [],\n      program: function(i, fn, data) {\n        var programWrapper = this.programs[i];\n        if(data) {\n          return Handlebars.VM.program(fn, data);\n        } else if(programWrapper) {\n          return programWrapper;\n        } else {\n          programWrapper = this.programs[i] = Handlebars.VM.program(fn);\n          return programWrapper;\n        }\n      },\n      programWithDepth: Handlebars.VM.programWithDepth,\n      noop: Handlebars.VM.noop\n    };\n\n    return function(context, options) {\n      options = options || {};\n      return templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);\n    };\n  },\n\n  programWithDepth: function(fn, data, $depth) {\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    return function(context, options) {\n      options = options || {};\n\n      return fn.apply(this, [context, options.data || data].concat(args));\n    };\n  },\n  program: function(fn, data) {\n    return function(context, options) {\n      options = options || {};\n\n      return fn(context, options.data || data);\n    };\n  },\n  noop: function() { return \"\"; },\n  invokePartial: function(partial, name, context, helpers, partials, data) {\n    var options = { helpers: helpers, partials: partials, data: data };\n\n    if(partial === undefined) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be found\");\n    } else if(partial instanceof Function) {\n      return partial(context, options);\n    } else if (!Handlebars.compile) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    } else {\n      partials[name] = Handlebars.compile(partial, {data: data !== undefined});\n      return partials[name](context, options);\n    }\n  }\n};\n\nHandlebars.template = Handlebars.VM.template;\n;\n"]}