/**
 * View Description
 * 
 * @langversion JavaScript
 * 
 * @author University Of Alcala
 * @since  2013
 */


 var View = require('core/View');
 var GraphCollection = require('collections/GraphCollection'); 

 // Templates & Partials
 var HomeTemplate = require('templates/HomeTemplate');
 var RelatedsTemplate = require('templates/relateds');
 var BreadcrumbTemplate = require('templates/breadcrumb');
 var LanguagesTemplate = require('templates/languages');

 var HomeView = View.extend({

    /*
     * @private
     */
     
     id: 'home-view',


    /*
     * @private
     */
     

     // FAO's Agrovoc
     // currentUri:'http://......./c_4788',
     
     // Cropontology's
     currentUri: 'http://www.cropontology.org/rdf/CO_010%3A0000000',
     currentLang:'EN',
     
     pagesStore:[], // stores current page number on each level
     levelLocked:[],
     idToUri: [],
     uriToId: [],
     currentId: '1', // cached id; autogenerated
    
     rootId: '1', // same as previous currentId     
     rootUri: 'http://www.cropontology.org/rdf/CO_010%3A0000000', // same as currentUri
     rootlabel: 'root', // auto regenerated after graph is downloaded.
     
     // Backbone templates
     
     homeTemplate: HomeTemplate,
     relatedsTemplate: RelatedsTemplate,
     breadcrumbTemplate: BreadcrumbTemplate,
     languagesTemplate: LanguagesTemplate,

     // graphic framework's attributes
     
     labelType : false, 
     useGradients: false, 
     nativeTextSupport: false, 
     animate: false, 
     graph: false,
     json: false,

     breadCrumbs: null, // te be implemented

    //--------------------------------------
    //+ INHERITED / OVERRIDES
    //--------------------------------------

  /*
   * @private
   */
   
   events: {

    'click .related-click'  :   'onRelatedLabelClick', // not implemented yet
    'click .breadcrumb-click':    'onBreadcrumbClick'
   },

  /*
   * @private
   */


   initialize: function() {

      // map uri and dom's id <-- less mem, more performance
      this.idToUri[this.currentId] = this.currentUri;
      this.uriToId[this.currentUri] = this.currentId;
      
      this.pagesStore[this.currentId] = 1;
      this.collection = new GraphCollection();        
      this.initNavigational();

      _.bindAll( this );

  },


  render: function() {

      var self = this;
      var homeTemplate = this.homeTemplate();
      var relatedsTemplate = this.relatedsTemplate({'related':[]});
      var breadcrumbTemplate = this.breadcrumbTemplate({'breadcrumb':[]});


      self.$el.html(homeTemplate);

      /* commented out */
      // self.$el.find('#related-container').html(relatedsTemplate); 

      self.$el.find('#breadcrumb-container').html(breadcrumbTemplate);

      $.get('/json/languages.json', function(data) {
        var languagesTemplate = self.languagesTemplate({'languages':data});
        self.$el.find('#language-container').html(languagesTemplate);    
        self.initLanguages();
      });


      return self;
    },


      getNewSubtree: function(nodeId) {

        var self = this;
        var data, uri = '';

        if (nodeId.toString().substring(0, 5) === '_pag_') {
           
           // we have clicked on an arrow, change to parent node
           return {};
        }
                        
        if (typeof self.pagesStore[nodeId] === 'undefined') {
        
          self.pagesStore[self.currentId] = 1;
        }
        
        
        pag = self.pagesStore[nodeId];
        
        
        if (typeof self.idToUri[nodeId] !== 'undefined') {
          uri = self.idToUri[nodeId];
        }

        self.collection.url = '/api/getnarrowerconcepts?uri=' + encodeURI(uri)         
            + '&lang='+self.currentLang+ '&pag='+pag;
        
          
          self.collection.fetch({async:false}) // set Backbone to synchronous mode
          .done(function() {
            data = self.collection.toJSON();            
          })
          .fail(function (){
            self.Spinner.hide();
            self.Log.write('Error retrieving data');
            data = {};

          }); 



          if (typeof data === 'object' && data.length > 0){
    
            return data[0];
                    
          } else {
          
            return {};
          }



      },

      redrawRelated: function(newRelated){ // not implemented yet
        $("#relateds").empty();
        var relatedNumber = newRelated.length;
        var relatedElementWidth = 150;
        var relatedSpace = relatedNumber*relatedElementWidth;
        var canvasWidth = $(window).innerWidth();
        var relatedSpaceBeginning = canvasWidth/2 - relatedSpace/2;
        var relatedHeight = 350;
        var radioDiff = 14;

        var graphReference = this.graph;
        var canvas = this.graph.canvas;
        graphReference.fx.edgeHelper.line.render({ x: 10, y: 30 }, { x: 10, y: 50 }, canvas); 
        
        for (var i = 0; i < relatedNumber; i++) {
          var relHeight = relatedHeight + radioDiff * Math.round(Math.pow(Math.abs(i-relatedNumber/2), 1.1));
          var relWidth = Math.floor(relatedSpaceBeginning + i*relatedElementWidth);
          $("#relateds").append('<div class="related-label" style="top:' + relHeight + 'px; left:' + relWidth + 'px">' + newRelated[i].name + '</div>');

          // graph.edgeHelper.line.render({ x: 10, y: 30 }, { x: 10, y: 50 }, canvas); 
          // test.moveTo(100,100);
          // test.lineTo(relWidth,relHeight);
          // test.stroke();
          // this.graph.canvas.getContext("2d").moveTo(100,100);
          // this.graph.canvas.getContext("2d").lineTo(relWidth,relHeight);
          // this.graph.canvas.getContext("2d").stroke;
        };
        

      },

      initLanguages: function () {     
        
        function format(state) {
          if (!state.id) {
            return state.text; 
          }

          /* commented out: flags */
          // return "<img class='flag' width='16' height='16' src='images/flags/" + state.id.toLowerCase() + ".png'/>"+ state.text;
          return state.text;
        }
        $("#language").select2({
           formatResult: format,
           formatSelection: format,
           width: '100%',
           escapeMarkup: function(m) { return m; }
        });
        $('#language').select2("val", this.currentLang.toLowerCase()); 

        $('#language').on('change', this.changeLanguage);
      },


      changeLanguage: function (e) {

        self = this;
        self.currentLang = e.val.toUpperCase();        
        self.Log.write('Changed language, retriving data...');
        // Saying hello to garbage collection
        self.graph = undefined;
        $('#infovis').html('');
        $('#infovis').css('height', '500px');
        // .append('<div id="spinner" class="text-center" style="display:none;"><img src="/images/spinner.gif" height="66" width="66" style="width:66px;height:66px;" title="loading"></div>');
        self.initNavigational();
  
  },


  initNavigational: function() {

      var self = this;
      
      self.collection.url = '/api/getnarrowerconcepts?uri=' + encodeURI(self.currentUri) +'&lang='+self.currentLang;
      self.collection.fetch().done(function() {

         self.afterRender();
      }).fail(function (){
         self.Spinner.hide();
         self.Log.write('Error retrieving data');
      }); 
      return self;
  },


  afterRender: function () {

    if (!this.json) { 
      this.initializeScreen();
    }
    this.initSearchBox();
    
    this.customRenderingFunctionsInit();
    this.createGraph();
    this.drawGraph();
  },

        
            
   initSearchBox: function(){

                sURL = '/api/getsimilarconcepts?lang='+this.currentLang+'&term='
                $("#selector").select2({
                  width: '100%',
                  allowClear: true,
                  minimumInputLength: 3,
                        ajax: { // instead of writing the function to execute the request we use Select2's convenient helper
                        url: sURL,
                        cache: true,
                        dataType : 'json',
                        data: function (term, page) {
                          return {
                            q: term
                          };
                        },
                        results: function (data, page) {
                          return {
                            results: data
                          };
                        }
                    },
                            
                    formatResult: function(item) {
                        return item.text;
                    },
                    formatSelection: function(item) {
                        return item.text;
                    },
                    id: function (obj) {
                        return obj.uri;
                    },
                                
                    dropdownCssClass: "bigdrop",
                    // escapeMarkup: function (m) { return m; } // we do not want to escape markup since we are displaying html in results
                });
                
                $('#selector').on('change', this.onSearchTerm);


  },


  //--------------------------------------
  //+ PUBLIC METHODS / GETTERS / SETTERS
  //--------------------------------------
  
  //--------------------------------------
  //+ EVENT HANDLERS
  //--------------------------------------
  
  onRelatedLabelClick: function (e) {


      e.stopImmediatePropagation();
      e.preventDefault();
      
      var dataId = $(e.currentTarget).data('id');

      $('#'+dataId).trigger('click');

  },

  onBreadcrumbClick: function (e) {

    e.stopImmediatePropagation();
    e.preventDefault();

    var dataId = $(e.currentTarget).data('id');

      $('#'+dataId).trigger('click');
      
      

  },


  //--------------------------------------
  //+ PRIVATE AND PROTECTED METHODS
  //--------------------------------------




        //----------------------------------------------------------
        //+ JavaScript InfoVis Toolkit http://philogb.github.io/jit/
        //----------------------------------------------------------



        updateRelateds: function (newRelated){

          var relatedsTemplate = this.relatedsTemplate({'related':newRelated});
          this.$el.find('#related-container').html(relatedsTemplate);
       },

       initializeScreen: function () {
           
           
           var ua = navigator.userAgent,
            iStuff = ua.match(/iPhone/i) || ua.match(/iPad/i),
            typeOfCanvas = typeof HTMLCanvasElement, 
            nativeCanvasSupport = (typeOfCanvas == 'object' || typeOfCanvas == 'function'),
            textSupport = nativeCanvasSupport && (typeof document.createElement('canvas').getContext('2d').fillText == 'function');

           //I'm setting this based on the fact that ExCanvas provides text support for IE
           //and that as of today iPhone/iPad current text support is lame
           this.labelType = (!nativeCanvasSupport || (textSupport && !iStuff))? 'Native' : 'HTML';           
           this.nativeTextSupport = this.labelType === 'Native';
           this.useGradients = nativeCanvasSupport;
           this.animate = !(iStuff || !nativeCanvasSupport);
           
           this.json = {'name':'root', 'id': this.currentId, 'children': [], 'related': []};

       },


        //--------------------------------------
        //+ PRIVATE METHODS
        //--------------------------------------

        getTree: function(nodeId, level) {

              var pag, tree;
              
              if ( typeof this.pagesStore[nodeId] === 'undefined') {
                  
                  this.pagesStore[nodeId] = 1;
              } 
              pag = this.pagesStore[nodeId];              
              
              
              tree = this.getNewSubtree(nodeId, pag);
            
console.dir(tree);                
              this.updateRootNode(tree);
              
              return this.addSubtreeAndPagers(nodeId, tree);
        },

            
              

        customRenderingFunctionsInit: function () {
              
           //Implement a node rendering function called 'nodeline' that plots a straight line
           //when contracting or expanding a subtree.
           $jit.ST.Plot.NodeTypes.implement({
            'nodeline': {
              'render': function(node, canvas, animating) {
                if(animating === 'expand' || animating === 'contract') {
                  var pos = node.pos.getc(true), nconfig = this.node, data = node.data;
                  var width  = nconfig.width, height = nconfig.height;
                  var algnPos = this.getAlignedPos(pos, width, height);
                  var ctx = canvas.getCtx(), ort = this.config.orientation;
                  ctx.beginPath();
                  if(ort == 'left' || ort == 'right') {
                    ctx.moveTo(algnPos.x, algnPos.y + height / 2);
                    ctx.lineTo(algnPos.x + width, algnPos.y + height / 2);
                  } else {

                     ctx.moveTo(algnPos.x + width / 2, algnPos.y);
                     ctx.lineTo(algnPos.x + width / 2, algnPos.y + height);
                      
                  }
                 ctx.stroke();
                 } 
               }
             },

             'roundrect': { 
                'render': function(node, canvas, animating) { 
                    var pos = node.pos.getc(true), nconfig = this.node, data = node.data; 
                    var width  = nconfig.width, height = nconfig.height; 
                    var algnPos = this.getAlignedPos(pos, width, height); 
                    var ctx = canvas.getCtx(), ort = this.config.orientation; 
                    ctx.beginPath(); 
                    var r = 10; //corner radius 
                    var x = algnPos.x; 
                    var y = algnPos.y; 
                    var h = height; 
                    var w = width; 
                    ctx.moveTo(x + r, y); 
                    ctx.lineTo(x + w - r, y); 
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r); 
                    ctx.lineTo(x + w, y + h - r); 
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); 
                    ctx.lineTo(x + r, y + h); 
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r); 
                    ctx.lineTo(x, y + r); 
                    ctx.quadraticCurveTo(x, y, x + r, y); 
                    ctx.fill(); 
                } 
             } 
          });
              
        },

        createGraph: function (){

           var self = this;

           // semaphore
           var removing = false;

           
           //Create a new ST instance
           self.graph = new $jit.ST({
              injectInto: 'infovis',
              orientation: 'bottom',
              //set duration for the animation
               duration: 800,
               //set animation transition type
               transition: $jit.Trans.Quart.easeInOut,
               //set distance between node and its children
               levelDistance: 90,
               levelsToShow: 1,
               
             Navigation: {
                enable:true,
                panning:true
                 // zooming:10
             },
             
             Events: {
               enable:true,
               onClick: function (nodeId, eventInfo, e){

               },    
                //Implement handler for TouchScreens
                onTouchMove: function(node, eventInfo, e) {
                    $jit.util.event.stop(e); //stop default touchmove event
                    this.onDragMove(node, eventInfo, e);
                }
            },
            
            Tips: {
               enable: true,
               onShow: function (tip, node){

                  

                  if (typeof node.id != 'undefined' && node.id.toString().substring(0, 6) === '_pag_r') {
                    tip.innerHTML = 'Click here to see more terms of this ontology';
                  } else if (typeof node.id != 'undefined' && node.id.toString().substring(0, 6) === '_pag_l') {
                    tip.innerHTML = 'Click here to see more terms of this ontology';
                  
                  } else {
                    
                    // no time to use a better solution  
                    if (node.id === self.rootId && tip.innerText !== self.rootLabel) {
                      tip.innerHTML = self.rootLabel;
                      tip.innerText = self.rootLabel;
                    } else {
                    
                      tip.innerHTML = node.name;
                    }
                  }
               }                                
            },
            
            Node: {
              height: 30,
              width: 150,
                   //use a custom
                   //node rendering function
                   type: 'nodeline', // roundrect, nodeline
                   align:"center",
                   overridable: true
               },

             Edge: {
                type: 'bezier',
                lineWidth: 1,
                color: '#444444',
                   overridable: true
             },

             request: function(nodeId, level, callback) {

                self.Log.loading();

                var response = self.getTree(nodeId, level);
                
                if (typeof response.id !== 'undefined') {
                  callback.onComplete(nodeId, response);  
                }
             },

             onBeforeCompute: function(id){
                 // self.Log.loading();
             },

             onAfterCompute: function(id){

                self.Log.done();
                self.Spinner.hide();
             },

             onCreateLabel: function(label, node){
               
                var m = {
                    offsetX: self.graph.canvas.translateOffsetX,
                    offsetY: self.graph.canvas.translateOffsetY + 100
                };
                
                label.id = node.id;            
                label.innerHTML = node.name;
                label.onclick = function(){
                  // normal node
                  if (label.id.toString().substring(0, 7) != '_pag_l_' && label.id.toString().substring(0, 7) != '_pag_r_') {

                      self.currentId = node.id;
                      self.graph.onClick(node.id);
                  // go forwards arrow
                  } else if (label.id.toString().substring(0, 7) === '_pag_r_'){
                      
                      var id;
                      self.Log.write("Retrieving data, please wait...");    
                      id = self.getParentId(label.id);
                      
                      self.paginateForwards(label.id);                      
                      // self.graph.onClick(label.id, {Move: m});
                  } else { // go backwards
                  
                      self.Log.write("Retrieving data, please wait...");                          
                      self.paginateBackwards(label.id);
                  };
                };
                   //set label styles
                   var style = label.style;
                   style.width = 150 + 'px';
                   style.height = 'auto';            
                   style.cursor = 'pointer';
                   // style.color = 'black';
                // style.backgroundColor = '#1a1a1a';
                   // style.fontSize = '12px';
                   style.textAlign= 'center';
               },

               onBeforePlotNode: function(node){

                if (node.selected) {
                
                   // node.data.$color = "#ff7";
                   // node.data.$color = "#23A4FF";
                   }
                   else {
                    // delete node.data.$color;
                   }
               },

               onBeforePlotLine: function(adj){
                if (adj.nodeFrom.selected && adj.nodeTo.selected) {
                       // adj.data.$color = "#eed";

                       adj.data.$color = "#23A4FF";
                       adj.data.$lineWidth = 3;
                   }
                   else {
                    adj.data.$color = "#666";
                       // delete adj.data.$color;
                       delete adj.data.$lineWidth;
                   }
               },
               
               // handler to change label
               /*
               onCreateLabel: function(domElement, node){
                 
                 domElement.innerHTML = node.name;
                 domElement.onclick = function(){
        
                        doc_rgraph[document_id].onClick(node.id, {
                        onComplete: function() {
                        Log.write("Done");
                        }
                    });
                    
                  };
                  
                },
                */
               onPlaceLabel: function(label, node, controllers){          

                var style = label.style;
                
                // console.log (label.id +' '+ self.rootId +' '+ label.innerText +' '+ self.rootLabel);
                // no time to use a better solution  
                if (label.id === self.rootId && label.innerText !== self.rootLabel) {
                  label.innerHTML = self.rootLabel;
                  label.innerText = self.rootLabel;
                }
                  
                
                if (node.selected) {    
                  style.color = '#23A4FF';
                  style.fontSize = '15px';
                  style.lineHeight='15px';
                  style.fontWeight = 'bold';
                }
                else {
                  style.color = '#666';
                  style.fontSize = '13px';
                  style.lineHeight='13px';
                  style.fontWeight = 'normal';
                }
                   // show the label and let the canvas clip it
                   style.display = ''; 
               }       
           });
           
           return self;
       },

       drawGraph: function () {

           // load json data
           this.graph.loadJSON(this.json);

           // compute node positions and layout
           this.graph.compute();

           // emulate a click on the root node.
           this.graph.onClick(this.graph.root);
           
       
       },

       ////////////////////////////////////
       //+      SUBCLASSES
       ////////////////////////////////////
       
       

       Log: {

        elem: false,

        write: function(txt){
          if (!this.elem) {
            this.elem = $('#log');
          }      
          this.elem.attr("style", "opacity:1;");
          this.elem.text(txt);
        },
        loading: function(txt){
          if (!this.elem) {
            this.elem = $('#log');
          }      
          this.elem.attr("style", "opacity:1;")    
          this.elem.text('loading...');
        },
        done: function(txt){
          if (!this.elem) {
            this.elem = $('#log');
          }      
          this.elem.attr("style", "opacity:0;")    
           // this.elem.text('done');
       }
   },




   Spinner: {

    elem: false,
    show: function () {
      if (!this.elem) {
        this.elem = $("#spinner");
      }
      this.elem.attr("style", "display:block;");

    },
    hide: function () {
      if (!this.elem) {
        this.elem = $("#spinner");
      }
      this.elem.attr("style", "display:none;");
    } 
   },
   
   // Helpers 
   
   computeParentNode: function (node) {
     
     var parent = node.replace(/_pag_(l|r)_/g,'');
     
     return parent;
   },

 
   paginateForwards: function(node) {

      this.paginate(node, function (a) { 
        return a + 1; 
      });        
              
   },   
   
   paginateBackwards: function(node) {

      this.paginate(node, function (a) { 
        return a - 1; 
      });        
   },   
   

   paginate: function(node, fx) {

      var parentNode = this.computeParentNode(node);
      var subtree;
      
      if ( typeof this.levelLocked[parentNode] === 'undefined' || 
           this.levelLocked[parentNode] === false) {
        // semaphore set to on
        this.levelLocked[parentNode] = true;
        
        // increment current page num.
        if (typeof this.pagesStore[parentNode] === 'undefined') {
           this.pagesStore[parentNode]= 1;
        }
        if ( typeof fx === 'function' ) {
          this.pagesStore[parentNode] = fx(this.pagesStore[parentNode]);
        } else {
          // use default
          this.pagesStore[parentNode] += 1; 
        }
        
        
        this.Log.write("Retrieving data, please wait...");    
        subtree = this.getNewSubtree(parentNode);
        
        this.paginateUpdate(parentNode, subtree);
      }
        
   },   

   addIdsFromUris: function (tree) {

        var self = this;
        var newTree = _.map(tree,function (obj) { 
          
          var uri = obj.uri;

          if (typeof obj.uri !== 'undefined') {


            if (typeof self.uriToId[uri] === 'undefined') {
              
              // add Id if it doesnt exists on array
              var id = self.generateId();

              while (typeof self.uriToId[uri] === 'undefined') {

                self.uriToId[uri] = id;
                self.idToUri[id] = uri;
                obj.id = id;
                id = self.generateId();
              }
            } else {
              obj.id = self.uriToId[obj.uri];
            }
          }  
        });
   
        return tree;
   },
  
  
   generateId: function () {
   
     var randomId = Math.floor(Math.random()*10000 +1); 
     randomId = 'c_' + randomId;
     return randomId;
   },
   
   
   paginateUpdate: function(parentNode, newSubtree) {
   
      var self = this;
      
      var node = self.graph.graph.getNode(parentNode);
      console.dir(node);
      console.log(parentNode);
      var name = node.name;
      var pages = node.pages;
      var page = self.pagesStore[parentNode];
      var related = [];
      
      // removing old subtree  
      self.graph.removeSubtree(parentNode, false, 'animate', {  
        hideLabels: false,  
        onComplete: function() {    
          
              newSubtree = self.addSubtreeAndPagers(parentNode, newSubtree);
              

              // adding new subtree 
              self.graph.addSubtree(newSubtree, 'animate', {  
                hideLabels: false,  
                onComplete: function() {  
                    self.Log.done();
                    self.levelLocked[parentNode] = false;
                    self.graph.onClick(parentNode);
                }  
              });
        }
      });  
      return self;
   },

   getParentId: function(arrowId) {
     
     var id = arrowId.toString();
     var parentId = false;
     
     parentId = id.substring(7,id.length);
     
     if (!parentId) {
        
        return null;
     } else {
        return parentId;
     }

   },
   
   
   addSubtreeAndPagers: function(nodeId, tree) {
   
              var paginator_right = '_pag_r_' + nodeId;
              var paginator_left = '_pag_l_' + nodeId;
              var pag = this.pagesStore[nodeId];
              
              var newSubtreeCenter = this.addIdsFromUris(tree.children);
                 
              var pages = tree.pages;
              var page = tree.page;
              var newSubtree, newSubtreeRight = [], newSubtreeLeft = [];
              var id = tree.id;
              var name = tree.name;
              var parent;
                              
                
                if (pages > 0){
                 
                 // Go Forwards arrow                
                 if (page < pages) {
                   newSubtreeRight = [{
                     'name': '&raquo;',
                     'id': paginator_right,
                     'children': [],
                     'pages':0,
                     'related': [],
                     'related_count':0,
                     'data': {
                        '$color': '#777',
                        '$type': 'circle',
                        '$dim': 40
                     }
                    }];
                 } 
                 
                 // Go BackWards arrow
                 if (page > 1) {
                   newSubtreeLeft = [{
                     'name': '&laquo;',
                     'id': paginator_left,
                     'children': [],
                     'pages':0,
                     'related':[],
                     'related_count':0,
                     'data': {
                        '$color': '#777',
                        '$type': 'circle',
                        '$dim': 40
                     }
                  }];
                 }
                }
                
                newSubtree = newSubtreeLeft.concat(
                  newSubtreeCenter,
                  newSubtreeRight
                );
                
                /* Commented out: Relateds */
                // this.updateRelateds(newSubtree);
                 
                 
                 return {

                      'name': name, 
                      'id': id, 
                      'children': newSubtree, 
                      'related': [], // not implemented yet
                      'pages':pages,
                      'page':page
                 };
        },
        
        updateRootNode: function (tree) {

              // update root's label
              if (typeof tree.uri !== 'undefined' && tree.uri === this.rootUri) {
              
                this.rootLabel = tree.name;
                
              }
              
              
              // update root's ...
              // ...
        }
   
   
}); // Backbone View end


module.exports = HomeView;
